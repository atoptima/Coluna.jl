var documenterSearchIndex = {"docs":
[{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"man/algorithm/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"TODO : Description of how algorithms work.","category":"page"},{"location":"man/algorithm/#References","page":"Algorithms","title":"References","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"TreeSearchAlgorithm","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.TreeSearchAlgorithm","page":"Algorithms","title":"Coluna.Algorithm.TreeSearchAlgorithm","text":"Coluna.Algorithm.TreeSearchAlgorithm(\n    conqueralg::AbstractConquerAlgorithm = ColCutGenConquer(),\n    dividealg::AbstractDivideAlgorithm = SimpleBranching(),\n    explorestrategy::AbstractTreeExploreStrategy = DepthFirstStrategy(),\n    maxnumnodes::Int = 100000,\n    opennodeslimit::Int = 100,\n    opt_atol::Float64 = DEF_OPTIMALITY_ATOL,\n    opt_rtol::Float64 = DEF_OPTIMALITY_RTOL,\n    branchingtreefile = nothing\n)\n\nThis algorithm is a branch and bound that uses a search tree to optimize the reformulation. At each node in the tree, it applies conqueralg to improve the bounds,  dividealg to generate child nodes, and explorestrategy to select the next node to treat.\n\nParameters : \n\nmaxnumnodes : maximum number of nodes explored by the algorithm\nopennodeslimit : maximum number of nodes waiting to be explored\nopt_atol : optimality absolute tolerance (alpha)\nopt_rtol : optimality relative tolerance (alpha)\n\nOptions :\n\nbranchingtreefile : name of the file in which the algorithm writes an overview of the branching tree\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"ColCutGenConquer","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.ColCutGenConquer","page":"Algorithms","title":"Coluna.Algorithm.ColCutGenConquer","text":"Coluna.Algorithm.ColCutGenConquer(\n    stages = ColumnGeneration[ColumnGeneration()],\n    primal_heuristics = ParameterisedHeuristic[ParamRestrictedMasterHeuristic()],\n    cutgen = CutCallbacks(),\n    max_nb_cut_rounds = 3\n)\n\nColumn-and-cut-generation based algorithm to find primal and dual bounds for a  problem decomposed using Dantzig-Wolfe paradigm.\n\nThis algorithm applies a set of column generation algorithms whose definitions are stored in stages. These algorithms are called in the reverse order of vector stages. So usually, the first stage is the one with exact pricing, and other stages use heuristic pricing (the higher is the position of the stage,  the faster is the heuristic). \n\nThis algorithm also applies cutgen for the cut generation phase. It can apply several primal heuristics stored in primal_heuristics to more efficiently find feasible solutions.\n\nParameters :\n\nstages: column generation algorithms from the exact one to the most heuristic one\nprimal_heuristics: heuristics to find a feasible solution\ncutgen: cut generation algorithm\nmax_nb_cut_rounds : number of cut generation done by the algorithm\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"ColumnGeneration","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.ColumnGeneration","page":"Algorithms","title":"Coluna.Algorithm.ColumnGeneration","text":"Coluna.Algorithm.ColumnGeneration(\n    restr_master_solve_alg = SolveLpForm(get_dual_solution = true),\n    pricing_prob_solve_alg = SolveIpForm(\n        moi_params = MoiOptimize(\n            deactivate_artificial_vars = false,\n            enforce_integrality = false\n        )\n    ),\n    essential_cut_gen_alg = CutCallbacks(call_robust_facultative = false),\n    max_nb_iterations = 1000,\n    log_print_frequency = 1,\n    redcost_tol = 1e-5,\n    cleanup_threshold = 10000,\n    cleanup_ratio = 0.66,\n    smoothing_stabilization = 0.0 # should be in [0, 1],\n)\n\nColumn generation algorithm that can be applied to formulation reformulated using Dantzog-Wolfe decomposition. \n\nThis algorithm first solves the linear relaxation of the master (master LP) using restr_master_solve_alg. Then, it solves the subproblems by calling pricing_prob_solve_alg to get the columns that have the best reduced costs and that hence, may improve the master LP's objective the most.\n\nIn order for the algorithm to converge towards the optimal solution of the master LP, it suffices that the pricing oracle returns, at each iteration, a negative reduced cost solution if one exists.  The algorithm stops when all subproblems fail to generate a column with negative (positive) reduced cost in the case of a minimization (maximization) problem or when it reaches the maximum number of iterations.\n\nParameters : \n\nrestr_master_solve_alg: algorithm to optimize the master LP\npricing_prob_solve_alg: algorithm to optimize the subproblems\nessential_cut_gen_alg: algorithm to generate essential cuts which is run when the solution of the master LP is integer.\n\nOptions:\n\nmax_nb_iterations: maximum number of iterations\nlog_print_frequency: display frequency of iterations statistics\n\nUndocumented parameters are in alpha version.\n\nAbout the ouput\n\nAt each iteration (depending on log_print_frequency),  the column generation algorithm can display following statistics.\n\n<it= 90> <et=15.62> <mst= 0.02> <sp= 0.05> <cols= 4> <al= 0.00> <DB=  300.2921> <mlp=  310.3000> <PB=310.3000>\n\nHere are their meanings :\n\nit stands for the current number of iterations of the algorithm\net is the elapsed time in seconds since Coluna has started the optimisation\nmst is the time in seconds spent solving the master LP at the current iteration\nsp is the time in seconds spent solving the subproblems at the current iteration\ncols is the number of column generated by the subproblems at the current iteration\nal is the smoothing factor of the stabilisation at the current iteration (alpha version)\nDB is the dual bound of the master LP at the current iteration\nmlp is the objective value of the master LP at the current iteration\nPB is the objective value of the best primal solution found by Coluna at the current iteration\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Basic-algorithms","page":"Algorithms","title":"Basic algorithms","text":"","category":"section"},{"location":"man/algorithm/#Optimize-a-linear-program","page":"Algorithms","title":"Optimize a linear program","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"SolveLpForm","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.SolveLpForm","page":"Algorithms","title":"Coluna.Algorithm.SolveLpForm","text":"Coluna.Algorithm.SolveLpForm(\n    get_dual_solution = false,\n    relax_integrality = false,\n    get_dual_bound = false,\n    silent = true\n)\n\nSolve a linear program stored in a formulation using its first optimizer. This algorithm works only if the optimizer is interfaced with MathOptInterface.\n\nYou can define the optimizer using the default_optimizer attribute of Coluna or with the method specify! from BlockDecomposition\n\nParameters:\n\nget_dual_solution: retrieve the dual solution and store it in the ouput if equals true\nrelax_integrality: relax integer variables of the formulation before optimization if equals true\nget_dual_bound: store the dual objective value in the output if equals true\nsilent: set MOI.Silent() to its value\n\nUndocumented parameters are alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Optimize-an-mixed-integer-program-/-solve-a-combinatorial-problem","page":"Algorithms","title":"Optimize an mixed-integer program / solve a combinatorial problem","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"SolveIpForm\nMoiOptimize\nUserOptimize\nCustomOptimize","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.SolveIpForm","page":"Algorithms","title":"Coluna.Algorithm.SolveIpForm","text":"Coluna.Algorithm.SolveIpForm(\n    optimizer_id = 1\n    moi_params = MoiOptimize()\n    user_params = UserOptimize()\n    custom_params = CustomOptimize()\n)\n\nSolve an optimization problem. This algorithm can call different type of optimizers :\n\nsubsolver interfaced with MathOptInterface to optimize a mixed integer program\npricing callback defined by the user\ncustom optimizer to solve a custom model\n\nYou can specify an optimizer using the default_optimizer attribute of Coluna or with the method specify! from BlockDecomposition. If you want to define several optimizers for a given subproblem, you must use specify!:\n\nspecify!(subproblem, optimizers = [optimizer1, optimizer2, optimizer3])\n\nValue of optimizer_id is the position of the optimizer you want to use. For example, if optimizer_id is equal to 2, the algorithm will use optimizer2.\n\nBy default, the algorihm uses the first optimizer or the default optimizer if no optimizer has been specified through specify!.\n\nDepending on the type of the optimizer chosen, the algorithm will use one the  three configurations : \n\nmoi_params for subsolver interfaced with MathOptInterface\nuser_params for pricing callbacks\ncustom_params for custom solvers\n\nCustom solver is undocumented because alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.MoiOptimize","page":"Algorithms","title":"Coluna.Algorithm.MoiOptimize","text":"MoiOptimize(\n    time_limit = 600\n    deactivate_artificial_vars = false\n    enforce_integrality = false\n    get_dual_bound = true\n)\n\nConfiguration for an optimizer that calls a subsolver through MathOptInterface.\n\nParameters:\n\ntime_limit: in seconds\ndeactivate_artificial_vars: deactivate all artificial variables of the formulation if equals true\nenforce_integrality: enforce integer variables that are relaxed if equals true\nget_dual_bound: store the dual objective value in the output if equals true\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.UserOptimize","page":"Algorithms","title":"Coluna.Algorithm.UserOptimize","text":"UserOptimize(\n    stage = 1\n    max_nb_ip_primal_sols = 50\n)\n\nConfiguration for an optimizer that calls a pricing callback to solve the problem.\n\nParameters:\n\nmax_nb_ip_primal_sols: maximum number of solutions returned by the callback kept\n\nUndocumented parameters are alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.CustomOptimize","page":"Algorithms","title":"Coluna.Algorithm.CustomOptimize","text":"CustomOptimize()\n\nConfiguration for an optimizer that calls a custom solver to solve a custom model.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/start.jl\"","category":"page"},{"location":"start/start/#Quick-start","page":"Getting started","title":"Quick start","text":"","category":"section"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"This quick start guide introduces the main features of Coluna through the example of the Generalized Assignment Problem.","category":"page"},{"location":"start/start/#Problem","page":"Getting started","title":"Problem","text":"","category":"section"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"Consider a set of machines M = 1:nb_machines and a set of jobs J = 1:nb_jobs. A machine m has a resource capacity Q_m . A job j assigned to a machine m has a cost c_mj and consumes w_mj resource units of the machine m. The goal is to minimize the sum of job costs while assigning each job to a machine and not exceeding the capacity of each machine.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"Let x_mj equal to one if job j is assigned to machine m; 0 otherwise. The problem has the original formulation:","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"beginalignedat4\ntextGAP equiv min mathrlapsum_m in Msum_j in J c_mj x_mj  \ntextst  sum_m in M x_mj = 1  quad j in J \n sum_j in J w_mj x_mj leq Q_m  quad  quad m in M  \n x_mj  in 01  m in M j in J\nendalignedat","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"In this tutorial, you will solve the instance below using a \"simple\" branch-and-cut-and-price algorithm:","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"nb_machines = 4;\nnb_jobs = 30;\n\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5 15.2 14.3 12.6 9.2 20.8 11.7 17.3 9.2 20.3 11.4 6.2 13.8 10.0 20.9 20.6;  19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2 19.7 19.5 7.2 6.4 23.2 8.1 13.6 24.6 15.6 22.3 8.8 19.1 18.4 22.9 8.0;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7 16.6 8.3 15.9 24.3 18.6 21.1 7.5 16.8 20.9 8.9 15.2 15.7 12.7 20.8 10.4;  13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2 12.9 11.3 7.5 6.5 11.3 7.8 13.8 20.7 16.8 23.6 19.1 16.8 19.3 12.5 11.0];\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78 71 50 99 92 83 53 91 68 61 63 97 91 77 68 80; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91 75 66 100 69 60 87 98 78 62 90 89 67 87 65 100; 91 81 66 63 59 81 87 90 65 55 57 68 92 91 86 74 80 89 95 57 55 96 77 60 55 57 56 67 81 52;  62 79 73 60 75 66 68 99 69 60 56 100 67 68 54 66 50 56 70 56 72 62 85 70 100 57 96 69 65 50];\nQ = [1020 1460 1530 1190];\nnothing #hide","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"This model has a block structure: each knapsack constraint defines an independent block and the set-partitioning constraints couple these independent blocks. By applying the Dantzig-Wolfe reformulation, each knapsack constraint forms a tractable subproblem and the set-partitioning constraints are handled in a master problem.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"To introduce the model, you need to load packages JuMP and BlockDecomposition. To optimize the problem, you need Coluna and a Julia package that provides a MIP solver such as GLPK.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"using JuMP, BlockDecomposition, Coluna, GLPK;\nnothing #hide","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"Next, you instantiate the solver and define the algorithm that you use to optimize the problem. In this case, the algorithm is a \"simple\" branch-and-cut-and-price provided by Coluna.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"In BlockDecomposition, an axis is the index set of subproblems. Let M be the index set of machines; it defines an axis along which we can implement the desired decomposition. In this example, the axis M defines one knapsack subproblem for each machine.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"Jobs are not involved in the decomposition, you thus define the set J of jobs as a classic range.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"@axis(M, 1:nb_machines);\nJ = 1:nb_jobs;\nnothing #hide","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"The model takes the form :","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"model = BlockModel(coluna);\n@variable(model, x[m in M, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M) >= 1);\n@constraint(model, knp[m in M], sum(w[m, j] * x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M, j in J));\nnothing #hide","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"You then apply a Dantzig-Wolfe decomposition along the M axis:","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"@dantzig_wolfe_decomposition(model, decomposition, M)","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"where decomposition is a variable that contains information about the decomposition.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"Once the decomposition is defined, you can retrieve the master and the subproblems to give additional information to the solver.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"master = getmaster(decomposition)\nsubproblems = getsubproblems(decomposition)","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"The multiplicity of a subproblem is the number of times that the same independent block shaped by the subproblem appears in the model. This multiplicy also specifies the number of solutions to the subproblem that can appear in the solution to the original problem.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"In this GAP instance, the upper multiplicity is 1 because every subproblem is different, i.e., every machine is different and used at most once.","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"The lower multiplicity is 0 because a machine may stay unused. The multiplicity specifications take the form:","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"specify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)\ngetsubproblems(decomposition)","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"The model is now fully defined. To solve it, you need to call:","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"optimize!(model)","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"Finally, you can retrieve the solution to the original formulation with JuMP methods. For example, if we want to know if the job 3 is assigned to machine 1 :","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"value(x[1,3])","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"start/start/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/decomposition/#Decomposition-and-reformulation","page":"Decomposition","title":"Decomposition & reformulation","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Coluna is a framework to optimizate mixed-integer programs that you can decompose. In other words, if you remove the linking constraints or linking variables from you program, you'll get sets of constraints (blocks) that you can solve independently.","category":"page"},{"location":"man/decomposition/#Dantzig-Wolfe","page":"Decomposition","title":"Dantzig-Wolfe","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following coefficient matrix that has a block diagonal structure in gray and some linking constraints in blue :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Dantzig-Wolfe decomposition)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You penalize the violation of the linking constraints in the objective function. You can then solve the blocks independently.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The Dantzig-Wolfe reformulation gives raise to a master problem with an exponential number of variables. Coluna dynamically generates these variables by solving the subproblems. It's the column generation algorithm.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following original formulation in which we partition variables into two vectors x_1 and x_2 :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Original formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"When you apply a Dantzig-Wofe decomposition to this formulation,  Coluna reformulates it into the following master problem :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Master formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"where Q_1 is the index-set of the solutions to the first subproblem and  Q_2 is the index-set of the solutions to the second subproblem. The set of the solutions to the first and the second subproblems are tildex^q_1_q in Q_1 and tildex^q_2_q in Q_2 respectively. These solutions are expressed in terms of the original variables. The multiplicity of the subproblems is defined in the convexity constraints. Lower and upper multiplicity are 1 by default.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"At the beginning of the column generation algorithm, the master formulation does not have any master columns. Therefore, the master may be infeasible.  To prevent this, Coluna adds a local artifical variable specific to each constraint of the master and a global artificial variable. Costs of articial and global artificial variables can be defined in Coluna.Params.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Subproblems take the following form (here, it's the first subproblem) :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Subproblem n°1 formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"where barc is the reduced cost of the original variables computed by the column generation algorithm.","category":"page"},{"location":"man/decomposition/#Benders-(alpha)","page":"Decomposition","title":"Benders (alpha)","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following coefficient matrix that has a block diagonal structure in gray and some linking variables in blue :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Benders decomposition)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You fix the complicated variables, then you can solve the blocks independently.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"This decomposition is an alpha feature.","category":"page"},{"location":"man/decomposition/#Identical-subproblems-(alpha)","page":"Decomposition","title":"Identical subproblems (alpha)","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"When some subproblems are identical (same coefficient matrix and rhs),  you can avoid solving all of them at each iteration by defining only one subproblem and setting its multiplicity to the number of time it appears.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let us see an example with Dantzig-Wolfe and a variant of the Generalized Assignment Problem.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Consider a set of machine type T = 1:nb_machine_types and a set of jobs J = 1:nb_jobs. A machine type t has a resource capacity Q[t] and the factory contains U[t] machines of type t. A job j assigned to a machine of type t has a cost c[t,j] and consumes w[t,j] resource units of the machine of type t.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Consider the following instance :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"nb_machine_types = 2;\nnb_jobs = 10;\nJ = 1:nb_jobs;\nQ = [10, 15];\nU = [3, 2];  # 3 machines of type 1 & 2 machines of type 2\nc = [10 11 13 11 12 14 15 8 9 11; 20 21 23 21 22 24 25 18 19 21];\nw = [4 4 5 4 4 3 4 5 6 5; 5 5 6 5 5 4 5 6 7 6];\nnothing #hide","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Here is the JuMP model to optimize this instance a classic solver : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"using JuMP, GLPK;\n\nT1 = [1, 2, 3]; # U[1] machines\nT2 = [4, 5]; # U[2] machines\nM = union(T1, T2);\nm2t = [1, 1, 1, 2, 2]; # machine id -> type id\n\nmodel = Model(GLPK.Optimizer);\n@variable(model, x[M, J], Bin); # 1 if job j assigned to machine m\n@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1);\n@constraint(model, knp[m in M], sum(w[m2t[m],j] * x[m,j] for j in J) <= Q[m2t[m]]);\n@objective(model, Min, sum(c[m2t[m],j] * x[m,j] for m in M, j in J));\n\noptimize!(model);\nobjective_value(model)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You can decompose over the machines by defining an axis on M. However, if you want to take advantage of the identical subproblems, you must  define the formulation as follows : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"using BlockDecomposition, Coluna, JuMP, GLPK;\nconst BD = BlockDecomposition\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\n\n@axis(T, 1:nb_machine_types);\n\nmodel = BlockModel(coluna);\n@variable(model, x[T, J], Bin); # 1 if job j assigned to machine m\n@constraint(model, cov[j in J], sum(x[t,j] for t in T) == 1);\n@constraint(model, knp[t in T], sum(w[t] * x[t,j] for j in J) <= Q[t]);\n@objective(model, Min, sum(c[t,j] * x[t,j] for t in T, j in J));\nnothing #hide","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We assign jobs to a type of machine and we define one knapsack constraint for each type. This formulation cannot be solved as it stands with a commercial solver.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Then, we decompose and specify the multiplicity of each knapsack subproblem : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"@dantzig_wolfe_decomposition(model, dec_on_types, T);\nsps = getsubproblems(dec_on_types)\nfor t in T\n    specify!(sps[t], lower_multiplicity = 0, upper_multiplicity = U[t]);\nend\ngetsubproblems(dec_on_types)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We see that subproblem for machine type 1 has upper multiplicity equals to 3, and second subproblem for machine type 2 has upper multiplicity equals to 2. It means that we can use at most 3 machines of type 1 and at most 2 machines of type 2.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We can then optimize","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"optimize!(model);","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"and retrieve the disagreggated solution","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"for t in T\n    assignment_patterns = BD.getsolutions(model, t);\n    for pattern in assignment_patterns\n        nb_times_pattern_used = BD.value(pattern);\n        jobs_in_pattern = [];\n        for j in J\n            if BD.value(pattern, x[t, j]) ≈ 1\n                push!(jobs_in_pattern, j);\n            end\n        end\n        println(\"Pattern of machine type $t used $nb_times_pattern_used times : $jobs_in_pattern\");\n    end\nend","category":"page"},{"location":"man/decomposition/#BlockDecomposition","page":"Decomposition","title":"BlockDecomposition","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The index-set of the subproblems is declared through an BlockDecomposition.@axis.  It returns an array. Each value of the array is a subproblem index wrapped into a BlockDecomposition.AxisId. Each time BlockDecomposition finds an AxisId in the indices of a variable and a constraint, it knows to which subproblem the variable or the constraint belongs.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockDecomposition allows the user to perform two types of decomposition using BlockDecomposition.@dantzig_wolfe_decomposition and BlockDecomposition.@benders_decomposition.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The macro creates a decomposition tree where the root is the master and the depth is the number of nested decomposition. A classic Dantzig-Wolfe or Benders decomposition produces a decomposition tree of depth 1. At the moment, nested decomposition is not supported.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You can get the subproblem membership of all variables and constraints using the method BlockDecomposition.annotation.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockDecomposition does not change the JuMP model. It decorates the model with additional information. All these information are stored in the ext field of the JuMP model.","category":"page"},{"location":"man/decomposition/#References","page":"Decomposition","title":"References","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"CurrentModule = BlockDecomposition\nDocTestSetup = quote\n    using BlockDecomposition\nend","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockModel","category":"page"},{"location":"man/decomposition/#BlockDecomposition.BlockModel","page":"Decomposition","title":"BlockDecomposition.BlockModel","text":"BlockModel(optimizer [, direct_model = false])\n\nReturn a JuMP model which BlockDecomposition will decompose using instructions given by the user.\n\nIf you define direct_model = true, the method creates the model with JuMP.direct_model, otherwise it uses JuMP.Model.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"These are the methods to decompose a JuMP model :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"@axis\n@benders_decomposition\n@dantzig_wolfe_decomposition","category":"page"},{"location":"man/decomposition/#BlockDecomposition.@axis","page":"Decomposition","title":"BlockDecomposition.@axis","text":"@axis(name, collection)\n\nDeclare collection as an index-set of subproblems.  You can access the axis using the variable name.\n\nExamples\n\nConsider a formulation that has a decomposition which gives raise to 5 subproblems. Let {1,2,3,4,5} be the index-set of the subproblems.\n\nTo perform this decomposition with BlockDecomposition, we must declare an axis that contains the index-set of the subproblems :\n\njulia> L = 1:5\n1:5\n\njulia> @axis(K, L)\nBlockDecomposition.Axis{:K, Int64}(:K, BlockDecomposition.AxisId{:K, Int64}[1, 2, 3, 4, 5])\n\njulia> K[1]\n1\n\njulia> typeof(K[1])\nBlockDecomposition.AxisId{:K, Int64}\n\nThe elements of the axis are AxisId. You must use AxisId in the indices of the variables and the constraints that you declare otherwise BlockDecomposition assign them to the master problem.\n\n@variable(model, x[l in L]) # x[l] belongs to the master for any l ∈ L\n@variable(model, y[k in K]) # y[k], k ∈ K, belongs to subproblem k (because K is an axis)\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/#BlockDecomposition.@benders_decomposition","page":"Decomposition","title":"BlockDecomposition.@benders_decomposition","text":"@benders_decomposition(model, name, axis)\n\nRegister a Benders decomposition on the JuMP model model where the index-set of the subproblems is defined by the axis axis.\n\nCreate a variable name from which the user can access decomposition tree.\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/#BlockDecomposition.@dantzig_wolfe_decomposition","page":"Decomposition","title":"BlockDecomposition.@dantzig_wolfe_decomposition","text":"@dantzig_wolfe_decomposition(model, name, axis)\n\nRegister a Dantzig-Wolfe decomposition on the JuMP model model where the index-set of the subproblems is defined by the axis axis.\n\nCreate a variable name from which the user can access the decomposition tree.\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"These are the methods to set additional information to the decomposition (multiplcity and optimizers) :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"getmaster\ngetsubproblems\nspecify!","category":"page"},{"location":"man/decomposition/#BlockDecomposition.getmaster","page":"Decomposition","title":"BlockDecomposition.getmaster","text":"getmaster(node) -> MasterForm\n\nReturn an object that wraps the annotation that describes the master formulation of a decomposition stored at the node of the decomposition tree.\n\nThis method is not defined if the node is a leaf of the decomposition tree.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/#BlockDecomposition.getsubproblems","page":"Decomposition","title":"BlockDecomposition.getsubproblems","text":"getsubproblems(node) -> Vector{SubproblemForm}\n\nReturn a vector of objects that wrap the annotations that describe subproblem formulations of a decomposition stored at node of the decomposition tree.\n\nThis method is not defined if the node is a leaf of the decomposition tree.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/#BlockDecomposition.specify!","page":"Decomposition","title":"BlockDecomposition.specify!","text":"specify!(\n    subproblem, \n    lower_multiplicity = 1,\n    upper_multiplicity = 1,\n    solver = nothing\n)\n\nMethod that allows the user to specify additional property of the subproblems.\n\nThe multiplicity of subproblem is the number of times that the same independant block shaped by the subproblem in the coefficient matrix appears in the model. It is equivalent to the number of solutions to the subproblem that can appear in the solution  of the original problem.\n\nThe solver of the subproblem is the way the subproblem will be optimized. It can be either a function (pricing callback), an optimizer of MathOptInterface  (e.g. Gurobi.Optimizer, CPLEX.Optimizer, Glpk.Optimizer... with attributes),  or nothing. In the latter case, the solver will use a default optimizer that  should be defined in the parameters of the main solver.\n\nAdvanced usage :  The user can use several solvers to optimize a subproblem : \n\nspecify!(subproblem, solver = [Gurobi.Optimizer, my_callback, my_second_callback])\n\nColuna always uses the first solver by default. Be cautious because changes are always buffered to all solvers. So you may degrade performances if you use a lot of solvers.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"This method help you to check your decomposition :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"annotation","category":"page"},{"location":"man/decomposition/#BlockDecomposition.annotation","page":"Decomposition","title":"BlockDecomposition.annotation","text":"annotation(node)\n\nReturn the annotation that describes the master/subproblem of a given node of the decomposition tree.\n\nannotation(model, variable)\nannotation(model, constraint)\n\nReturn the subproblem to which a variable or a constraint belongs.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"qa/#Question-and-Answer","page":"Q&A","title":"Question & Answer","text":"","category":"section"},{"location":"qa/#Default-algorithms-of-Coluna-do-not-beat-the-commercial-solver-I-usually-use.-Is-it-normal-?","page":"Q&A","title":"Default algorithms of Coluna do not beat the commercial solver I usually use. Is it normal ?","text":"","category":"section"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Yes it is.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Solvers such as Gurobi, Cplex ... are handy powerful black-box tools.  They can run a very efficient presolve step to simplify the formulation, automatically apply lots of valid inequalities (such as MIR or cover cuts),  choose good branching strategies, or also run heuristics. However, when your formulation reaches a certain size, commercial solvers may run for hours without finding anything. This is the point where you may want to decompose your formulation.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Coluna is a framework not a solver. It provides algorithms to try column generation on your problem very easily. Then, you can devise your own branch-cut-and-price algorithm on top of Coluna's algorithms. to scale up and hopefully beats the commercial solver.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"To start customizing Coluna for your own problem,  you can separate valid inequalities  or call your own algorithm that optimizes subproblems.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/man/callbacks.jl\"","category":"page"},{"location":"man/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callbacks are functions defined by the user that allow him to take over part of the default algorithm. The more classical callbacks in a branch-and-price solver are:","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Pricing callback that takes over the procedure to determine whether the current master LP   solution is optimum or produces an entering variable with negative reduced cost by solving subproblems\nSeparation callback that takes over the procedure to determine whether the current master   LP solution is feasible or produces a valid problem constraint that is violated\nBranching callback that takes over the procedure to determine whether the current master   LP solution is integer or produces a valid branching disjunctive constraint that rules out   the current fractional solution.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"note: Note\nYou can't change the original formulation in a callback because Coluna does not propagate the changes into the reformulation and does not check if solutions found are still feasible.","category":"page"},{"location":"man/callbacks/#Pricing-callback","page":"Callbacks","title":"Pricing callback","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"The pricing callback let you define how to solve the subproblems of a Dantzig-Wolfe decomposition to generate a new entering column in the master program. This callback is useful when you know an efficient algorithm to solve the subproblems, i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"First, we load the packages and define aliases :","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"using Coluna, BlockDecomposition, JuMP, MathOptInterface, GLPK;\nconst BD = BlockDecomposition;\nconst MOI = MathOptInterface;\nnothing #hide","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Let us see an example with the following generalized assignment problem :","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"nb_machines = 4;\nnb_jobs = 30;\n\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5 15.2 14.3 12.6 9.2 20.8 11.7 17.3 9.2 20.3 11.4 6.2 13.8 10.0 20.9 20.6;  19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2 19.7 19.5 7.2 6.4 23.2 8.1 13.6 24.6 15.6 22.3 8.8 19.1 18.4 22.9 8.0;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7 16.6 8.3 15.9 24.3 18.6 21.1 7.5 16.8 20.9 8.9 15.2 15.7 12.7 20.8 10.4;  13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2 12.9 11.3 7.5 6.5 11.3 7.8 13.8 20.7 16.8 23.6 19.1 16.8 19.3 12.5 11.0];\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78 71 50 99 92 83 53 91 68 61 63 97 91 77 68 80; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91 75 66 100 69 60 87 98 78 62 90 89 67 87 65 100; 91 81 66 63 59 81 87 90 65 55 57 68 92 91 86 74 80 89 95 57 55 96 77 60 55 57 56 67 81 52;  62 79 73 60 75 66 68 99 69 60 56 100 67 68 54 66 50 56 70 56 72 62 85 70 100 57 96 69 65 50];\nQ = [1020 1460 1530 1190];\nnothing #hide","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"with the following Coluna configuration","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"for which the JuMP model takes the form:","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"model = BlockModel(coluna);\n\n@axis(M, 1:nb_machines);\nJ = 1:nb_jobs;\n\n@variable(model, x[m in M, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1);\n@objective(model, Min, sum(c[m,j]*x[m,j] for m in M, j in J));\n@dantzig_wolfe_decomposition(model, dwdec, M);\nnothing #hide","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"where, as you can see, we omitted the knapsack constraints. These constraints are implicitly defined by the algorithm called in the pricing callback.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Let's use the knapsack algorithms from the unregistered package KnapsackLib to solve the knapsack subproblems.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"using KnapsackLib;\nnothing #hide","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"The pricing callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with Coluna within the pricing callback.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"function my_pricing_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M)\n    cur_machine = BD.callback_spid(cbdata, model)\n\n    # Retrieve reduced costs of subproblem variables\n    red_costs = [BD.callback_reduced_cost(cbdata, x[cur_machine, j]) for j in J]\n\n    # Keep jobs with negative reduced costs\n    selected_jobs = Int[]\n    selected_costs = Int[]\n    for j in J\n        if red_costs[j] <= 0.0\n            push!(selected_jobs, j)\n            # scale reduced costs to int\n            push!(selected_costs, -round(Int, 10000 * red_costs[j]))\n        end\n    end\n\n    if sum(w[cur_machine, selected_jobs]) <= Q[cur_machine]\n        # Don't need to run the algorithm,\n        # all jobs with negative reduced cost are assigned to the machine\n        jobs_assigned_to_cur_machine = selected_jobs\n    else\n        # Run the algorithm\n        items = [KnapItem(w,c) for (w,c) in zip(w[cur_machine, selected_jobs], selected_costs)]\n        data = KnapData(Q[cur_machine], items)\n\n        # Solve the knapsack with the algorithm from KnapsackLib\n        _, jobs_assigned_to_cur_machine = solveKnapExpCore(data)\n    end\n\n    # Create the solution (send only variables with non-zero values)\n    sol_vars = [x[cur_machine, j] for j in jobs_assigned_to_cur_machine]\n    sol_vals = [1.0 for _ in jobs_assigned_to_cur_machine]\n    sol_cost = sum(red_costs[j] for j in jobs_assigned_to_cur_machine)\n\n    # Submit the solution to the subproblem to Coluna\n    MOI.submit(model, BD.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)\n    return\nend","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"The pricing callback is provided to Coluna using the keyword solver in the method specify!.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"subproblems = BD.getsubproblems(dwdec);\nBD.specify!.(subproblems, lower_multiplicity = 0, solver = my_pricing_callback);\nnothing #hide","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"You can then optimize :","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"optimize!(model);\nnothing #hide","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"and retrieve information you need as usual :","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"getobjectivevalue(model)","category":"page"},{"location":"man/callbacks/#Separation-callbacks","page":"Callbacks","title":"Separation callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Separation callbacks let you define how to separate cuts or constraints.","category":"page"},{"location":"man/callbacks/#Facultative-and-essential-cuts-(user-cut-and-lazy-constraint)","page":"Callbacks","title":"Facultative & essential cuts (user cut & lazy constraint)","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"This callback allows you to add cuts to the master problem. The cuts must be expressed in terms of the original variables. Then, Coluna expresses them over the master variables. You can find an example of essential cut separation and facultative cut separation in the JuMP documentation.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nSome features are undocumented because they are not yet considered stable.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a framework written in Julia to implement a decomposition approach to optimize  block-structured mixed-integer programs (MIP). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna relies on the tools of the JuMP-dev community at both ends of the problem treatment. It uses the JuMP modeling language upfront and MathOptInterface (MOI) to delegate master  and subproblems to MIP solvers. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The user introduces an original MIP that models his problem using the JuMP along our specific  extension BlockDecomposition that offers a syntax to specify the problem decomposition.  Coluna reformulates the original MIP using Dantzig-Wolfe and Benders decomposition  techniques.  Then, Coluna optimizes the reformulation using the algorithm chosen by the user.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna offers a \"black-box\" implementation of the branch-and-cut-and-price algorithm:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI). \nBlockDecomposition allows the user to provide to Coluna his decomposition of the model.   The BlockDecomposition syntax allows the user to implicilty define subsystems in the MIP on which the decomposition is based.   These subsystems are described by rows and/or columns indices.\nThe reformulation associated with the decomposition defined by the user is automatically generated by Coluna,  without requiring any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound.\nA default column (and cut) generation procedure is implemented.  It relies on underlying MOI optimizers to handle master and subproblems.   However, the user can use pricing callbacks to solve the subproblems.\nA branching scheme that preserves the pricing problem structure is offered by default;   it runs based on priorities and directives specified by the user on the original variables.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a package for Julia 1.0+","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It requires JuMP to model the problem, BlockDecomposition to define the decomposition, and a MIP solver supported by MathOptInterface to optimize the master and the subproblems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can install Coluna and its dependencies through the package manager of Julia by entering :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add Coluna","category":"page"},{"location":"#Contributions","page":"Introduction","title":"Contributions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We welcome all contributions that help us to improve Coluna. You can suggest ways to enhance the package by opening an issue via the GitHub issues tracker","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once the suggestion is approved, you can open a Pull Request (PR) with the implementation of your suggestion. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Before requesting the review, make sure that your code follows the style guide and passes tests.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Do not forget to update the docstrings and the tests when necessary.  It is very important to keep clear the goal of the PR to make the review fast.  So we might close a PR that fixes two unrelated issues or more. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna style follows the blue style guide for Julia amended by the following instruction on naming :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Names of variables and functions are treated equally. Use names that express what the variable/function does. > Either use : lowercasenospace when the name is composed of three words or less with no ambiguity on words separation.\nsnake_case otherwise","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that the application of the style guide is a work in progress.","category":"page"},{"location":"#Extra-dependances","page":"Introduction","title":"Extra dependances","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CPLEX.jl >= 0.7.0 (cf issue 446)","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Atoptima, Mathematical Optimization Society (MOS), Région Nouvelle-Aquitaine, University of Bordeaux, and Inria","category":"page"},{"location":"man/config/#Coluna-Configuration","page":"Configuration","title":"Coluna Configuration","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#Raw-Parameters","page":"Configuration","title":"Raw Parameters","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#params","page":"Configuration","title":"params","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = Coluna\nDocTestSetup = quote\n    using Coluna\nend","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"Params","category":"page"},{"location":"man/config/#Coluna.Params","page":"Configuration","title":"Coluna.Params","text":"Coluna.Params(\n    solver = Coluna.Algorithm.TreeSearchAlgorithm(),\n    global_art_var_cost = 10e6,\n    local_art_var_cost = 10e4\n)\n\nParameters of Coluna :\n\nsolver is the algorithm used to optimize the reformulation.\nglobal_art_var_cost is the cost of the global artificial variables in the master\nlocal_art_var_cost is the cost of the local artificial variables in the master\n\n\n\n\n\n","category":"type"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/config/#default_optimizer","page":"Configuration","title":"default_optimizer","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#Other-Supported-Parameters","page":"Configuration","title":"Other Supported Parameters","text":"","category":"section"},{"location":"man/config/#From-BlockDecomposition","page":"Configuration","title":"From BlockDecomposition","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = BlockDecomposition\nDocTestSetup = quote\n    using BlockDecomposition\nend","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"objectiveprimalbound!\nobjectivedualbound!","category":"page"},{"location":"man/config/#BlockDecomposition.objectiveprimalbound!","page":"Configuration","title":"BlockDecomposition.objectiveprimalbound!","text":"objectiveprimalbound!(model, pb)\n\nDefine a primal bound on the optimal objective value  (upper bound for a minimisation, lower bound for a maximisation).\n\n\n\n\n\n","category":"function"},{"location":"man/config/#BlockDecomposition.objectivedualbound!","page":"Configuration","title":"BlockDecomposition.objectivedualbound!","text":"objectivedualbound!(model, db)\n\nDefine a dual bound on the optimal objective value. (lower bound for a minimisation, upper bound for a maximisation)\n\n\n\n\n\n","category":"function"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/config/#From-MathOptInterface","page":"Configuration","title":"From MathOptInterface","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"}]
}
