<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in algorithms for Branch-and-Bound · Coluna.jl</title><meta name="title" content="Built-in algorithms for Branch-and-Bound · Coluna.jl"/><meta property="og:title" content="Built-in algorithms for Branch-and-Bound · Coluna.jl"/><meta property="twitter:title" content="Built-in algorithms for Branch-and-Bound · Coluna.jl"/><meta name="description" content="Documentation for Coluna.jl."/><meta property="og:description" content="Documentation for Coluna.jl."/><meta property="twitter:description" content="Documentation for Coluna.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.048/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/js/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs (Ctrl + /)"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting Started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/start/">Column generation</a></li><li><a class="tocitem" href="../../start/cuts/">Cut Generation</a></li><li><a class="tocitem" href="../../start/pricing/">Pricing callback</a></li><li><a class="tocitem" href="../../start/identical_sp/">Identical subproblems</a></li><li><a class="tocitem" href="../../start/custom_data/">Custom data</a></li><li><a class="tocitem" href="../../start/initial_columns/">Initial columns callback</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Advanced tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/advanced_demo/">Column Generation and Benders on Location Routing</a></li><li><a class="tocitem" href="../../start/other_pbs/">Other classic problems</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Decomposition</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../decomposition/">Decomposition paradigms</a></li><li><a class="tocitem" href="../blockdecomposition/">Setup decomposition using BlockDecomposition</a></li></ul></li><li><a class="tocitem" href="../config/">Configuration</a></li><li class="is-active"><a class="tocitem" href>Built-in algorithms for Branch-and-Bound</a><ul class="internal"><li><a class="tocitem" href="#Manage-the-branching-phase"><span>Manage the branching phase</span></a></li><li><a class="tocitem" href="#Optimize-each-node-by-Column-and/or-Cut-Generation"><span>Optimize each node by Column and/or Cut Generation</span></a></li><li><a class="tocitem" href="#Basic-algorithms"><span>Basic algorithms</span></a></li></ul></li><li><a class="tocitem" href="../callbacks/">User-defined Callbacks</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/benders/">Benders</a></li><li><a class="tocitem" href="../../api/branching/">Branching</a></li><li><a class="tocitem" href="../../api/colgen/">ColGen</a></li><li><a class="tocitem" href="../../api/treesearch/">TreeSearch</a></li><li><a class="tocitem" href="../../api/storage/">Storage</a></li></ul></li><li><a class="tocitem" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays</a></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><div class="docs-left"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Built-in algorithms for Branch-and-Bound</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Built-in algorithms for Branch-and-Bound</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/atoptima/Coluna.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/man/algorithm.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Built-in-algorithms-for-Branch-and-Bound"><a class="docs-heading-anchor" href="#Built-in-algorithms-for-Branch-and-Bound">Built-in algorithms for Branch-and-Bound</a><a id="Built-in-algorithms-for-Branch-and-Bound-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-algorithms-for-Branch-and-Bound" title="Permalink"></a></h1><p>Branch-and-Bound algorithm aims to find an optimal solution of a MIP by successive divisions of the search space. An introduction to the Branch-and-Bound algorithm can be found <a href="https://en.wikipedia.org/wiki/Branch_and_bound">here</a>. </p><p>Coluna provides a generic Branch-and-Bound algorithm whose three main elements can be easily modified:</p><ul><li>the branching strategy: how to create new branches i.e. how to divise the search space</li><li>the explore strategy: the evaluation order of your nodes </li><li>the conquer strategy: evaluation of the problem at a node of the Branch-and-Bound tree. Depending on the type of decomposition used ahead of the Branch-and-Bound, you can use either Column Generation (if your problem is decomposed following Dantzig-Wolfe transformation) and/or Cut Generation (for Dantzig-Wolfe and Benders decompositions). </li></ul><p>The main loop of the Branch-and-Bound tree is implemented by <code>Algorithm.TreeSearchAlgorithm</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.TreeSearchAlgorithm" href="#Coluna.Algorithm.TreeSearchAlgorithm"><code>Coluna.Algorithm.TreeSearchAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.TreeSearchAlgorithm(
    conqueralg::AbstractConquerAlgorithm = ColCutGenConquer(),
    dividealg::AbstractDivideAlgorithm = Branching(),
    explorestrategy::AbstractExploreStrategy = DepthFirstStrategy(),
    maxnumnodes = 100000,
    opennodeslimit = 100,
    timelimit = -1, # -1 means no time limit
    opt_atol::Float64 = DEF_OPTIMALITY_ATOL,
    opt_rtol::Float64 = DEF_OPTIMALITY_RTOL,
    branchingtreefile = &quot;&quot;
)</code></pre><p>This algorithm is a branch and bound that uses a search tree to optimize the reformulation. At each node in the tree, it applies <code>conqueralg</code> to evaluate the node and improve the bounds,  <code>dividealg</code> to generate branching constraints, and <code>explorestrategy</code> to select the next node to treat.</p><p>Parameters : </p><ul><li><code>maxnumnodes</code> : maximum number of nodes explored by the algorithm</li><li><code>opennodeslimit</code> : maximum number of nodes waiting to be explored</li><li><code>timelimit</code> : time limit in seconds of the algorithm</li><li><code>opt_atol</code> : optimality absolute tolerance (alpha)</li><li><code>opt_rtol</code> : optimality relative tolerance (alpha)</li></ul><p>Options :</p><ul><li><code>branchingtreefile</code> : name of the file in which the algorithm writes an overview of the branching tree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/treesearch.jl#L1-L28">source</a></section></article><p>In the following sections, we present the global setup of <code>Algorithm.TreeSearchAlgorithm</code>. First, we describe the construction and the exploration of the search tree. Then, we &quot;zoom&quot; on the tree to describe the setup of Cut and Column Generation at each node.</p><h2 id="Manage-the-branching-phase"><a class="docs-heading-anchor" href="#Manage-the-branching-phase">Manage the branching phase</a><a id="Manage-the-branching-phase-1"></a><a class="docs-heading-anchor-permalink" href="#Manage-the-branching-phase" title="Permalink"></a></h2><p>When generating branches in the Branch-and-Bound process, two questions arise:</p><ul><li>which fractional variable to branch on ?</li><li>which branch to explore first ? </li></ul><p>The two next sections describe the parameters that can be used to setup the branching phase. </p><h3 id="Select-the-variable-to-branch-on"><a class="docs-heading-anchor" href="#Select-the-variable-to-branch-on">Select the variable to branch on</a><a id="Select-the-variable-to-branch-on-1"></a><a class="docs-heading-anchor-permalink" href="#Select-the-variable-to-branch-on" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Algorithm.Branching.AbstractSelectionCriterion</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.FirstFoundCriterion" href="#Coluna.Algorithm.FirstFoundCriterion"><code>Coluna.Algorithm.FirstFoundCriterion</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Select the branching candidates that have been generated first (sort by <code>local_id</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/branching/selectioncriteria.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.MostFractionalCriterion" href="#Coluna.Algorithm.MostFractionalCriterion"><code>Coluna.Algorithm.MostFractionalCriterion</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Select the most fractional branching candidates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/branching/selectioncriteria.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.SingleVarBranchingRule" href="#Coluna.Algorithm.SingleVarBranchingRule"><code>Coluna.Algorithm.SingleVarBranchingRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleVarBranchingRule</code></pre><p>This branching rule allows the divide algorithm to branch on single integer variables. For instance, <code>SingleVarBranchingRule</code> can produce the branching <code>x &lt;= 2</code> and <code>x &gt;= 3</code>  where <code>x</code> is a scalar integer variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/branching/single_var_branching.jl#L87-L93">source</a></section></article><h3 id="Division-of-the-search-space"><a class="docs-heading-anchor" href="#Division-of-the-search-space">Division of the search space</a><a id="Division-of-the-search-space-1"></a><a class="docs-heading-anchor-permalink" href="#Division-of-the-search-space" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.NoBranching" href="#Coluna.Algorithm.NoBranching"><code>Coluna.Algorithm.NoBranching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoBranching</code></pre><p>Divide algorithm that does nothing. It does not generate any child.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/branching/branchingalgo.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ClassicBranching" href="#Coluna.Algorithm.ClassicBranching"><code>Coluna.Algorithm.ClassicBranching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClassicBranching(
    selection_criterion = MostFractionalCriterion()
    rules = [Branching.PrioritisedBranchingRule(SingleVarBranchingRule(), 1.0, 1.0)]
)</code></pre><p>Chooses the best candidate according to a selection criterion and generates the two children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/branching/branchingalgo.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.StrongBranching" href="#Coluna.Algorithm.StrongBranching"><code>Coluna.Algorithm.StrongBranching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StrongBranching</code></pre><p>The algorithm that performs a (multi-phase) (strong) branching in a tree search algorithm.</p><p>Strong branching is a procedure that heuristically selects a branching constraint that potentially gives the best progress of the dual bound. The procedure selects a collection  of branching candidates based on their branching rule and their score. Then, the procedure evaluates the progress of the dual bound in both branches of each branching candidate by solving both potential children using a conquer algorithm. The candidate that has the largest product of dual bound improvements in the branches  is chosen to be the branching constraint.</p><p>When the dual bound improvement produced by the branching constraint is difficult to compute (e.g. time-consuming in the context of column generation), one can let the branching algorithm quickly estimate the dual bound improvement of each candidate and retain the most promising branching candidates. This is called a <strong>phase</strong>. The goal is to first evaluate a large number of candidates with a very fast conquer algorithm and retain a certain number of promising ones.  Then, over the phases, it evaluates the improvement with a more precise conquer algorithm and restrict the number of retained candidates until only one is left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/branching/branchingalgo.jl#L143-L163">source</a></section></article><h2 id="Optimize-each-node-by-Column-and/or-Cut-Generation"><a class="docs-heading-anchor" href="#Optimize-each-node-by-Column-and/or-Cut-Generation">Optimize each node by Column and/or Cut Generation</a><a id="Optimize-each-node-by-Column-and/or-Cut-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Optimize-each-node-by-Column-and/or-Cut-Generation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColCutGenConquer" href="#Coluna.Algorithm.ColCutGenConquer"><code>Coluna.Algorithm.ColCutGenConquer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.ColCutGenConquer(
    colgen = ColumnGeneration(),
    primal_heuristics = ParameterizedHeuristic[ParamRestrictedMasterHeuristic()],
    cutgen = CutCallbacks(),
    max_nb_cut_rounds = 3
)</code></pre><p>Column-and-cut-generation based algorithm to find primal and dual bounds for a  problem decomposed using Dantzig-Wolfe paradigm.</p><p>This algorithm applies a set of column generation algorithms whose definitions are stored in <code>stages</code>. These algorithms are called in the reverse order of vector <code>stages</code>. So usually, the first stage is the one with exact pricing, and other stages use heuristic pricing (the higher is the position of the stage,  the faster is the heuristic).</p><p>This algorithm also applies <code>cutgen</code> for the cut generation phase. It can apply several primal heuristics stored in <code>primal_heuristics</code> to more efficiently find feasible solutions.</p><p>Parameters :</p><ul><li><code>stages</code>: column generation algorithms from the exact one to the most heuristic one</li><li><code>primal_heuristics</code>: heuristics to find a feasible solution</li><li><code>cutgen</code>: cut generation algorithm</li><li><code>max_nb_cut_rounds</code> : number of cut generation done by the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/conquer.jl#L71-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColumnGeneration" href="#Coluna.Algorithm.ColumnGeneration"><code>Coluna.Algorithm.ColumnGeneration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.ColumnGeneration(
    restr_master_solve_alg = SolveLpForm(get_dual_solution = true),
    pricing_prob_solve_alg = SolveIpForm(
        moi_params = MoiOptimize(
            deactivate_artificial_vars = false,
            enforce_integrality = false
        )
    ),
    essential_cut_gen_alg = CutCallbacks(call_robust_facultative = false),
    max_nb_iterations = 1000,
    log_print_frequency = 1,
    redcost_tol = 1e-4,
    show_column_already_inserted_warning = true,
    cleanup_threshold = 10000,
    cleanup_ratio = 0.66,
    smoothing_stabilization = 0.0 # should be in [0, 1],
)</code></pre><p>Column generation algorithm that can be applied to formulation reformulated using Dantzig-Wolfe decomposition. </p><p>This algorithm first solves the linear relaxation of the master (master LP) using <code>restr_master_solve_alg</code>. Then, it solves the subproblems by calling <code>pricing_prob_solve_alg</code> to get the columns that have the best reduced costs and that hence, may improve the master LP&#39;s objective the most.</p><p>In order for the algorithm to converge towards the optimal solution of the master LP, it suffices that the pricing oracle returns, at each iteration, a negative reduced cost solution if one exists.  The algorithm stops when all subproblems fail to generate a column with negative (positive) reduced cost in the case of a minimization (maximization) problem or when it reaches the maximum number of iterations.</p><p>Parameters : </p><ul><li><code>restr_master_solve_alg</code>: algorithm to optimize the master LP</li><li><code>pricing_prob_solve_alg</code>: algorithm to optimize the subproblems</li><li><code>essential_cut_gen_alg</code>: algorithm to generate essential cuts which is run when the solution of the master LP is integer.</li></ul><p>Options:</p><ul><li><code>max_nb_iterations</code>: maximum number of iterations</li><li><code>log_print_frequency</code>: display frequency of iterations statistics</li></ul><p>Undocumented parameters are in alpha version.</p><p><strong>About the ouput</strong></p><p>At each iteration (depending on <code>log_print_frequency</code>),  the column generation algorithm can display following statistics.</p><pre><code class="nohighlight hljs">&lt;it= 90&gt; &lt;et=15.62&gt; &lt;mst= 0.02&gt; &lt;sp= 0.05&gt; &lt;cols= 4&gt; &lt;al= 0.00&gt; &lt;DB=  300.2921&gt; &lt;mlp=  310.3000&gt; &lt;PB=310.3000&gt;</code></pre><p>Here are their meanings :</p><ul><li><code>it</code> stands for the current number of iterations of the algorithm</li><li><code>et</code> is the elapsed time in seconds since Coluna has started the optimisation</li><li><code>mst</code> is the time in seconds spent solving the master LP at the current iteration</li><li><code>sp</code> is the time in seconds spent solving the subproblems at the current iteration</li><li><code>cols</code> is the number of column generated by the subproblems at the current iteration</li><li><code>al</code> is the smoothing factor of the stabilisation at the current iteration (alpha version)</li><li><code>DB</code> is the dual bound of the master LP at the current iteration</li><li><code>mlp</code> is the objective value of the master LP at the current iteration</li><li><code>PB</code> is the objective value of the best primal solution found by Coluna at the current iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/colgen.jl#L1-L61">source</a></section></article><h2 id="Basic-algorithms"><a class="docs-heading-anchor" href="#Basic-algorithms">Basic algorithms</a><a id="Basic-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-algorithms" title="Permalink"></a></h2><h3 id="Optimize-a-linear-program"><a class="docs-heading-anchor" href="#Optimize-a-linear-program">Optimize a linear program</a><a id="Optimize-a-linear-program-1"></a><a class="docs-heading-anchor-permalink" href="#Optimize-a-linear-program" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.SolveLpForm" href="#Coluna.Algorithm.SolveLpForm"><code>Coluna.Algorithm.SolveLpForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.SolveLpForm(
    get_dual_solution = false,
    relax_integrality = false,
    get_dual_bound = false,
    silent = true
)</code></pre><p>Solve a linear program stored in a formulation using its first optimizer. This algorithm works only if the optimizer is interfaced with MathOptInterface.</p><p>You can define the optimizer using the <code>default_optimizer</code> attribute of Coluna or with the method <code>specify!</code> from BlockDecomposition</p><p>Parameters:</p><ul><li><code>get_dual_solution</code>: retrieve the dual solution and store it in the ouput if equals <code>true</code></li><li><code>relax_integrality</code>: relax integer variables of the formulation before optimization if equals <code>true</code></li><li><code>get_dual_bound</code>: store the dual objective value in the output if equals <code>true</code></li><li><code>silent</code>: set <code>MOI.Silent()</code> to its value</li></ul><p>Undocumented parameters are alpha.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/basic/solvelpform.jl#L1-L22">source</a></section></article><h3 id="Optimize-an-mixed-integer-program-/-solve-a-combinatorial-problem"><a class="docs-heading-anchor" href="#Optimize-an-mixed-integer-program-/-solve-a-combinatorial-problem">Optimize an mixed-integer program / solve a combinatorial problem</a><a id="Optimize-an-mixed-integer-program-/-solve-a-combinatorial-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Optimize-an-mixed-integer-program-/-solve-a-combinatorial-problem" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.SolveIpForm" href="#Coluna.Algorithm.SolveIpForm"><code>Coluna.Algorithm.SolveIpForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.SolveIpForm(
    optimizer_id = 1
    moi_params = MoiOptimize()
    user_params = UserOptimize()
    custom_params = CustomOptimize()
)</code></pre><p>Solve an optimization problem. This algorithm can call different type of optimizers :</p><ul><li>subsolver interfaced with MathOptInterface to optimize a mixed integer program</li><li>pricing callback defined by the user</li><li>custom optimizer to solve a custom model</li></ul><p>You can specify an optimizer using the <code>default_optimizer</code> attribute of Coluna or with the method <code>specify!</code> from BlockDecomposition. If you want to define several optimizers for a given subproblem, you must use <code>specify!</code>:</p><pre><code class="nohighlight hljs">specify!(subproblem, optimizers = [optimizer1, optimizer2, optimizer3])</code></pre><p>Value of <code>optimizer_id</code> is the position of the optimizer you want to use. For example, if <code>optimizer_id</code> is equal to 2, the algorithm will use <code>optimizer2</code>.</p><p>By default, the algorihm uses the first optimizer or the default optimizer if no optimizer has been specified through <code>specify!</code>.</p><p>Depending on the type of the optimizer chosen, the algorithm will use one the  three configurations : </p><ul><li><code>moi_params</code> for subsolver interfaced with MathOptInterface</li><li><code>user_params</code> for pricing callbacks</li><li><code>custom_params</code> for custom solvers</li></ul><p>Custom solver is undocumented because alpha.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/basic/solveipform.jl#L4-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.MoiOptimize" href="#Coluna.Algorithm.MoiOptimize"><code>Coluna.Algorithm.MoiOptimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MoiOptimize(
    time_limit = 600
    deactivate_artificial_vars = false
    enforce_integrality = false
    get_dual_bound = true
)</code></pre><p>Configuration for an optimizer that calls a subsolver through MathOptInterface.</p><p>Parameters:</p><ul><li><code>time_limit</code>: in seconds</li><li><code>deactivate_artificial_vars</code>: deactivate all artificial variables of the formulation if equals <code>true</code></li><li><code>enforce_integrality</code>: enforce integer variables that are relaxed if equals <code>true</code></li><li><code>get_dual_bound</code>: store the dual objective value in the output if equals <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/basic/subsolvers.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.UserOptimize" href="#Coluna.Algorithm.UserOptimize"><code>Coluna.Algorithm.UserOptimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UserOptimize(
    max_nb_ip_primal_sols = 50
)</code></pre><p>Configuration for an optimizer that calls a pricing callback to solve the problem.</p><p>Parameters:</p><ul><li><code>max_nb_ip_primal_sols</code>: maximum number of solutions returned by the callback kept</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/basic/subsolvers.jl#L107-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.CustomOptimize" href="#Coluna.Algorithm.CustomOptimize"><code>Coluna.Algorithm.CustomOptimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CustomOptimize()</code></pre><p>Configuration for an optimizer that calls a custom solver to solve a custom model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/fc59dab9655d5ef9550ec1a5fd78ad20bafc75dc/src/Algorithm/basic/subsolvers.jl#L121-L125">source</a></section></article><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../config/">« Configuration</a><a class="docs-footer-nextpage" href="../callbacks/">User-defined Callbacks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Tuesday 4 July 2023 09:34">Tuesday 4 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
