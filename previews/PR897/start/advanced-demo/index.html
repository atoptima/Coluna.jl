<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced demo · Coluna User Guide</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/js/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna User Guide</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../start/">Column generation</a></li><li><a class="tocitem" href="../cuts/">Valid inequalities</a></li><li><a class="tocitem" href="../pricing/">Pricing callback</a></li><li><a class="tocitem" href="../custom_data/">Custom data</a></li><li><a class="tocitem" href="../initial_columns/">Initial columns callback</a></li><li class="is-active"><a class="tocitem" href>Advanced demo</a><ul class="internal"><li><a class="tocitem" href="#Direct-model"><span>Direct model</span></a></li><li><a class="tocitem" href="#Dantzig-Wolfe-decomposition-and-Branch-and-Price"><span>Dantzig-Wolfe decomposition and Branch-and-Price</span></a></li><li><a class="tocitem" href="#Benders-decomposition"><span>Benders decomposition</span></a></li><li><a class="tocitem" href="#Example-of-comparison-of-the-dual-bounds-obtained-on-a-larger-instance."><span>Example of comparison of the dual bounds obtained on a larger instance.</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/decomposition/">Decomposition</a></li><li><a class="tocitem" href="../../man/config/">Configuration</a></li><li><a class="tocitem" href="../../man/algorithm/">Algorithms</a></li><li><a class="tocitem" href="../../man/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/branching/">Branching</a></li><li><a class="tocitem" href="../../api/colgen/">ColGen</a></li><li><a class="tocitem" href="../../api/treesearch/">TreeSearch</a></li><li><a class="tocitem" href="../../api/storage/">Storage</a></li></ul></li><li><a class="tocitem" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays</a></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting started</a></li><li class="is-active"><a href>Advanced demo</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced demo</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/advanced-demo.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-tutorial-Location-Routing"><a class="docs-heading-anchor" href="#Advanced-tutorial-Location-Routing">Advanced tutorial - Location Routing</a><a id="Advanced-tutorial-Location-Routing-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-tutorial-Location-Routing" title="Permalink"></a></h1><p>We demonstrate the main features of Coluna on a variant of the Location Routing problem. In the Location Routing Problem, we are given a set of facilities and a set of customers. Each customers must be delivered by a route starting from one facility. Each facility has a setup cost and the cost of a route is the distance traveled.</p><p>A route is defined as a vector of locations that satisfies the following rules:</p><ul><li>any route must start from a open facility location</li><li>every route has a maximum length, i.e. the number of visited locations cannot exceed a fixed constant <code>nb_positions</code></li><li>the routes are said to be open, i.e. finish at last visited customer.</li></ul><p>Our objective is to minimize the fixed costs of opened facilities and the distance traveled by the routes while ensuring that each customer is at least visited once by a route.</p><p>In this tutorial, we will show you how to optimize this problem using:</p><ul><li>a direct approach with JuMP and a MILP solver (without Coluna)</li><li>a classic branch-and-price provided by Coluna and a pricing callback that calls a custom code to optimize pricing subproblems</li><li>robust valid inequalities (branch-cut-and-price algorithm)</li><li>non-robust valid inequalities (branch-cut-and-price algorithm)</li><li>multi-stage column generation using two different pricing solvers</li><li>Benders cut generation algorithm</li></ul><p>We work on a small instance with 2 facilities and 7 customers. The maximum length of a route is fixed to 4.</p><pre><code class="language-julia hljs">nb_positions = 4
facilities_fixed_costs = [120, 150]
facilities = [1, 2]
customers = [3, 4, 5, 6, 7, 8, 9]
arc_costs =
[
    0.0  25.3  25.4  25.4  35.4  37.4  31.9  24.6  34.2;
    25.3   0.0  21.2  16.2  27.1  26.8  17.8  16.7  23.2;
    25.4  21.2   0.0  14.2  23.4  23.8  18.3  17.0  21.6;
    25.4  16.2  14.2   0.0  28.6  28.8  22.6  15.6  29.5;
    35.4  27.1  23.4  28.6   0.0  42.1  30.4  24.9  39.1;
    37.4  26.8  23.8  28.8  42.1   0.0  32.4  29.5  38.2;
    31.9  17.8  18.3  22.6  30.4  32.4   0.0  22.5  30.7;
    24.6  16.7  17.0  15.6  24.9  29.5  22.5   0.0  21.4;
    34.2  23.2  21.6  29.5  39.1  38.2  30.7  21.4   0.0;
]
locations  = vcat(facilities, customers)
nb_customers = length(customers)
nb_facilities = length(facilities)
positions = 1:nb_positions;</code></pre><p>In this tutorial, we will use the following packages:</p><pre><code class="language- hljs">using JuMP, HiGHS, GLPK, BlockDecomposition, Coluna;
nothing #hide</code></pre><p>We want to set an upper bound <code>nb_routes_per_facility</code> on the number of routes starting from a facility. This limit is calculated as follows:</p><pre><code class="language-julia hljs"># We compute the minimum number of routes needed to visit all customers:
nb_routes = Int(ceil(nb_customers / nb_positions))
# We define the upper bound `nb_routes_per_facility`:
nb_routes_per_facility = min(Int(ceil(nb_routes / nb_facilities)) * 2, nb_routes)
routes_per_facility = 1:nb_routes_per_facility;</code></pre><h2 id="Direct-model"><a class="docs-heading-anchor" href="#Direct-model">Direct model</a><a id="Direct-model-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-model" title="Permalink"></a></h2><p>First, we solve the problem by a direct approach, using the HiGHS solver. We start by creating a JuMP model:</p><pre><code class="language- hljs">model = JuMP.Model(HiGHS.Optimizer);
nothing #hide</code></pre><p>We declare 3 types of binary variables:</p><pre><code class="language- hljs"># y[j] equals 1 if facility j is open; 0 otherwise.
@variable(model, y[j in facilities], Bin)

# z[u,v] equals 1 if a vehicle travels from u to v; 0 otherwise
@variable(model, z[u in locations, v in locations], Bin)

# x[i,j,k,p] equals 1 if customer i is delivered from facility j at position p of route k; 0 otherwise
@variable(model, x[i in customers, j in facilities, k in routes_per_facility, p in positions], Bin);
nothing #hide</code></pre><p>We define the constraints:</p><pre><code class="language- hljs"># each customer visited once
@constraint(model, cov[i in customers],
    sum(x[i, j, k, p] for j in facilities, k in routes_per_facility, p in positions) == 1)

# each facility is open if there is a route starting from it
@constraint(model, setup[j in facilities, k in routes_per_facility],
    sum(x[i,j,k,1] for i in customers) &lt;= y[j])

# flow conservation
@constraint(model, flow_conservation[j in facilities, k in routes_per_facility, p in positions; p &gt; 1],
    sum(x[i, j, k, p] for i in customers) &lt;= sum(x[i, j, k, p-1] for i in customers))

# there is an arc between two customers whose demand is satisfied by the same route at consecutive positions
@constraint(model, route_arc[i in customers, l in customers, j in facilities, k in routes_per_facility, p in positions; p &gt; 1 &amp;&amp; i != l],
    z[i,l] &gt;= x[l, j, k, p] + x[i, j, k, p-1] - 1)

# there is an arc between the facility `j` and the first customer visited by the route `k` from facility `j`
@constraint(model, start_arc[i in customers, j in facilities, k in routes_per_facility],
        z[j,i] &gt;= x[i, j, k, 1]);
nothing #hide</code></pre><p>We set the objective function:</p><pre><code class="language- hljs">@objective(model, Min,
    sum(arc_costs[u, v] * z[u, v] for u in locations, v in locations)
    +
    sum(facilities_fixed_costs[j] * y[j] for j in facilities));
nothing #hide</code></pre><p>and we optimize the model:</p><pre><code class="language- hljs">optimize!(model)
objective_value(model)</code></pre><p>We find an optimal solution involving two routes starting from facility 1:</p><ul><li><code>1</code> -&gt; <code>8</code> -&gt; <code>9</code> -&gt; <code>3</code> -&gt; <code>6</code></li><li><code>1</code> -&gt; <code>4</code> -&gt; <code>5</code> -&gt; <code>7</code></li></ul><h2 id="Dantzig-Wolfe-decomposition-and-Branch-and-Price"><a class="docs-heading-anchor" href="#Dantzig-Wolfe-decomposition-and-Branch-and-Price">Dantzig-Wolfe decomposition and Branch-and-Price</a><a id="Dantzig-Wolfe-decomposition-and-Branch-and-Price-1"></a><a class="docs-heading-anchor-permalink" href="#Dantzig-Wolfe-decomposition-and-Branch-and-Price" title="Permalink"></a></h2><p>We can exploit the structure of the problem by generating routes starting from each facility. The most immediate decomposition is to consider each route traveled by a vehicle as a subproblem. However, at a given facility, vehicles are identical and therefore any vehicle can travel on any route. So we have several identical subproblems at each facility.</p><p>The following method creates the model according to the decomposition described:</p><pre><code class="language- hljs">function create_model(optimizer, pricing_algorithms)
    # We declare an axis over the facilities.
    # We must use `facilities_axis` instead of `facilities` in the declaration of the
    # variables and constraints that belong to pricing subproblems.
    @axis(facilities_axis, collect(facilities))

    # We declare a `BlockModel` instead of `Model`.
    model = BlockModel(optimizer)

    # `y[j]` is a master variable equal to 1 if the facility j is open; 0 otherwise
    @variable(model, y[j in facilities], Bin)

    # `x[i,j]` is a subproblem variable equal to 1 if customer i is delivered from facility j; 0 otherwise.
    @variable(model, x[i in customers, j in facilities_axis], Bin)
    # `z[u,v]` is a subproblem variable equal to 1 if a vehicle travels from u to v; 0 otherwise.
    # we don&#39;t use the `facilities_axis` axis here because the `z` variables are defined as
    # representatives of the subproblems later.
    @variable(model, z[u in locations, v in locations], Bin)

    # `cov` constraints are master constraints ensuring that each customer is visited once.
    @constraint(model, cov[i in customers],
        sum(x[i, j] for j in facilities) &gt;= 1)

    # `open_facilities` are master constraints ensuring that the depot is open if one vehicle.
    # leaves it.
    @constraint(model, open_facility[j in facilities],
            sum(z[j, i] for i in customers) &lt;= y[j] * nb_routes_per_facility)

    # We don&#39;t need to describe the subproblem constraints because we use a pricing callback.

    # We set the objective function:
    @objective(model, Min,
        sum(arc_costs[u, v] * z[u, v] for u in locations, v in locations) +
        sum(facilities_fixed_costs[j] * y[j] for j in facilities)
    )

    # We perform decomposition over the facilities.
    @dantzig_wolfe_decomposition(model, dec, facilities_axis)

    # Subproblems generated routes starting from each facility.
    # The number of routes from each facilities is at most `nb_routes_per_facility`.
    subproblems = BlockDecomposition.getsubproblems(dec)
    specify!.(subproblems, lower_multiplicity=0, upper_multiplicity=nb_routes_per_facility, solver=pricing_algorithms)

    # We define `z` are a subproblem variable common to all subproblems.
    subproblemrepresentative.(z, Ref(subproblems))

    return model, x, y, z, cov
end</code></pre><p>Note that contrary to the direct model, we don&#39;t have to add constraints to ensure the consistency of the routes because we solve our subproblems using a pricing callback. The pricing callback will therefore have the responsibility to create consistent routes.</p><p>We setup Coluna:</p><pre><code class="language- hljs">coluna = optimizer_with_attributes(
    Coluna.Optimizer,
    &quot;params&quot; =&gt; Coluna.Params(
        solver = Coluna.Algorithm.TreeSearchAlgorithm( ## default branch-and-bound of Coluna
            maxnumnodes = 100,
            conqueralg = Coluna.ColCutGenConquer() ## default column and cut generation of Coluna
        ) ## default branch-cut-and-price
    ),
    &quot;default_optimizer&quot; =&gt; GLPK.Optimizer # GLPK for the master &amp; the subproblems
);
nothing #hide</code></pre><h3 id="Pricing-callback"><a class="docs-heading-anchor" href="#Pricing-callback">Pricing callback</a><a id="Pricing-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Pricing-callback" title="Permalink"></a></h3><p>Each subproblem could be solved by a MIP, provided the right sub-problem constraints are added. Here, we propose a resolution by enumeration within a pricing callback. Enumerating all possible routes for each facility is time-consuming. We thus perform this task before starting the branch-cut-and-price. The pricing callback will then have to update the cost of each route and select the route with best cost for each facility.</p><p>We first define a structure to store the routes:</p><pre><code class="language-julia hljs">mutable struct Route
    length::Int
    path::Vector{Int}
end</code></pre><p>A method that computes the cost of a route:</p><pre><code class="language-julia hljs">function route_original_cost(costs, route::Route)
    route_cost = 0.0
    path = route.path
    path_length = route.length
    for i in 1:(path_length-1)
        route_cost += costs[path[i], path[i+1]]
    end
    return route_cost
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">route_original_cost (generic function with 1 method)</code></pre><p>Since the cost of the route depends only on the arcs and there is no resource consumption constraints on the route or master constraints that may have an effect of the customer visit order, we know that for a subset of customers, a sequence of visits is better then the others. We therefore keep on route for each subset of customers and facilities.</p><pre><code class="language-julia hljs">function best_visit_order(costs, cust_subset, facility_id)
    # generate all the possible visit orders
    set_size = size(cust_subset)[1]
    all_paths = collect(multiset_permutations(cust_subset, set_size))
    all_routes = Vector{Route}()
    for path in all_paths
        # add the first index i.e. the facility id
        enpath = vcat([facility_id], path)
        # length of the route = 1 + number of visited customers
        route = Route(set_size + 1, enpath)
        push!(all_routes, route)
    end
    # compute each route original cost
    routes_costs = map(r -&gt;
                         (r, route_original_cost(costs, r)), all_routes )
    # keep the best visit order
    tmp = argmin([c for (_, c) in routes_costs])
    (best_order, _) = routes_costs[tmp]
    return best_order
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">best_visit_order (generic function with 1 method)</code></pre><p>We are now able to compute the best route for all the possible customers subsets, given a facility id:</p><pre><code class="language- hljs">using Combinatorics

function best_route_forall_cust_subsets(costs, customers, facility_id, max_size)
    best_routes = Vector{Route}()
    all_subsets = Vector{Vector{Int}}()
    for subset_size in 1:max_size
        subsets = collect(combinations(customers, subset_size))
        for s in subsets
            push!(all_subsets, s)
        end
    end
    for s in all_subsets
        route_s = best_visit_order(costs, s, facility_id)
        push!(best_routes, route_s)
    end
    return best_routes
end</code></pre><p>We store all the information given by this pre-processing phase in a dictionary. To each facility id we match a vector of routes that are the best visiting orders for each possible subset of customers.</p><pre><code class="language- hljs">routes_per_facility = Dict(
    j =&gt; best_route_forall_cust_subsets(arc_costs, customers, j, nb_positions) for j in facilities
)</code></pre><p>Our pricing callback will calculate the cost of each route given the reduced cost of the subproblem variables <code>x</code> and <code>z</code>.</p><p>We therefore need methods to calculate the contribution to the reduced cost of <code>x</code> and <code>z</code>:</p><pre><code class="language-julia hljs">function x_contribution(route::Route, j::Int, x_red_costs)
    x = 0.0
    visited_customers = route.path[2:route.length]
    for i in visited_customers
        x += x_red_costs[&quot;x_$(i)_$(j)&quot;]
    end
    return x
end

function z_contribution(route::Route, z_red_costs)
    z = 0.0
    for i in 1:(route.length-1)
        current_position = route.path[i]
        next_position = route.path[i+1]
        z += z_red_costs[&quot;z_$(current_position)_$(next_position)&quot;]
    end
    return z
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">z_contribution (generic function with 1 method)</code></pre><p>We are now able to write our pricing callback:</p><pre><code class="language-julia hljs">function pricing_callback(cbdata)
    # Get the id of the facility.
    j = BlockDecomposition.indice(BlockDecomposition.callback_spid(cbdata, model))

    # Retrieve variables reduced costs.
    z_red_costs = Dict(
        &quot;z_$(u)_$(v)&quot; =&gt; BlockDecomposition.callback_reduced_cost(cbdata, z[u, v]) for u in locations, v in locations

    )
    x_red_costs = Dict(
        &quot;x_$(i)_$(j)&quot; =&gt; BlockDecomposition.callback_reduced_cost(cbdata, x[i, j]) for i in customers
    )

    # Keep route with minimum reduced cost.
    red_costs_j = map(r -&gt; (
            r,
            x_contribution(r, j, x_red_costs) + z_contribution(r, z_red_costs) # the reduced cost of a route is the sum of the contribution of the variables
        ), routes_per_facility[j]
    )
    min_index = argmin([x for (_,x) in red_costs_j])
    (best_route, min_reduced_cost) = red_costs_j[min_index]

    # Retrieve the route&#39;s arcs
    best_route_arcs = Vector{Tuple{Int, Int}}()
    for i in 1:(best_route.length - 1)
        push!(best_route_arcs, (best_route.path[i], best_route.path[i+1]))
    end
    best_route_customers = best_route.path[2:best_route.length]

    # Create the solution (send only variables with non-zero values).
    z_vars = [z[u, v] for (u,v) in best_route_arcs]
    x_vars = [x[i, j] for i in best_route_customers]
    sol_vars = vcat(z_vars, x_vars)
    sol_vals = ones(Float64, length(z_vars) + length(x_vars))
    sol_cost = min_reduced_cost

    # Submit the solution of the subproblem to Coluna.
    MOI.submit(model, BlockDecomposition.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)

    # Submit the dual bound to the solution of the subproblem.
    # This bound is used to compute the contribution of the subproblem to the lagrangian
    # bound in column generation.
    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), sol_cost) ## optimal solution

end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">pricing_callback (generic function with 1 method)</code></pre><p>Create the model:</p><pre><code class="language- hljs">model, x, y, z, _ = create_model(coluna, pricing_callback);
nothing #hide</code></pre><p>Solve:</p><pre><code class="language- hljs">JuMP.optimize!(model)</code></pre><p>TODO: display &quot;raw&quot; decomp model output and comment, transition to next section</p><h3 id="Strengthen-with-robust-cuts-(valid-inequalities)"><a class="docs-heading-anchor" href="#Strengthen-with-robust-cuts-(valid-inequalities)">Strengthen with robust cuts (valid inequalities)</a><a id="Strengthen-with-robust-cuts-(valid-inequalities)-1"></a><a class="docs-heading-anchor-permalink" href="#Strengthen-with-robust-cuts-(valid-inequalities)" title="Permalink"></a></h3><p>We introduce of first type of classic valid inequalities that tries to improve the integrality of the <code>y</code> variables.</p><p class="math-container">\[x_{ij} \leq y_j\; \forall i \in I, \forall j \in J\]</p><p>where <span>$I$</span> is the set of customers and J the set of facilities.</p><p>We declare a structure representing an instance of this inequality:</p><pre><code class="language-julia hljs">struct OpenFacilityInequality
    facility_id::Int
    customer_id::Int
end</code></pre><p>We are going to separate these inequalities by enumeration (i.e. iterating over all pairs of customer and facility). Let&#39;s write our valid inequalities callback:</p><pre><code class="language-julia hljs">function valid_inequalities_callback(cbdata)
    # Get variables valuations, store them into dictionaries.
    x_vals = Dict(
        &quot;x_$(i)_$(j)&quot; =&gt; BlockDecomposition.callback_value(cbdata, x[i, j]) for i in customers, j in facilities
    )
    y_vals = Dict(
        &quot;y_$(j)&quot; =&gt; BlockDecomposition.callback_value(cbdata, y[j]) for j in facilities
    )

    # Separate the valid inequalities (i.e. retrieve the inequalities that are violated by
    # the current solution) by enumeration.
    inequalities = OpenFacilityInequality[]

    for j in facilities
        for i in customers
            x_i_j = x_vals[&quot;x_$(i)_$(j)&quot;]
            y_j = y_vals[&quot;y_$(j)&quot;]
            if x_i_j &gt; y_j
                push!(inequalities, OpenFacilityInequality(j, i))
            end
        end
    end

    # Add the valid inequalities to the model.
    for ineq in inequalities
        constr = JuMP.@build_constraint(x[ineq.customer_id, ineq.facility_id] &lt;= y[ineq.facility_id])
        MOI.submit(model, MOI.UserCut(cbdata), constr)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">valid_inequalities_callback (generic function with 1 method)</code></pre><p>We re-declare the model and optimize it with these valid inequalites:</p><pre><code class="language- hljs">model, x, y, z, _ = create_model(coluna, pricing_callback);
MOI.set(model, MOI.UserCutCallback(), valid_inequalities_callback);
JuMP.optimize!(model)</code></pre><p>TODO: comment on the improvement of the dual bound</p><h3 id="Strengthen-with-non-robust-cuts-(rank-one-cuts)"><a class="docs-heading-anchor" href="#Strengthen-with-non-robust-cuts-(rank-one-cuts)">Strengthen with non-robust cuts (rank-one cuts)</a><a id="Strengthen-with-non-robust-cuts-(rank-one-cuts)-1"></a><a class="docs-heading-anchor-permalink" href="#Strengthen-with-non-robust-cuts-(rank-one-cuts)" title="Permalink"></a></h3><p>Here, we implement special types of cuts called &quot;rank-one cuts&quot; (R1C). These cuts are non-robust in the sense that they cannot be expressed only with the original variables of the model. In particular, they have to be expressed with the master columns variables <span>$λ_k, k \in K$</span> where <span>$K$</span> is the set of generated columns.</p><p>R1Cs are obtained by applying the Chvátal-Gomory procedure once, hence their name, on cover constraints. R1Cs have the following form:</p><p class="math-container">\[\sum_{k \in K} \lfloor \sum_{i \in C} \alpha_c \tilde{x}^k_{i,j} \lambda_k \rfloor \leq \lfloor \sum_{i \in C} \alpha_c \rfloor, \;  C \subseteq I\]</p><p>where <span>$C$</span> is a subset of customers, <span>$\alpha_c$</span> is a multiplier, <span>$\tilde{x}^k_{ij}$</span> is the value of the variable <span>$x_{ij}$</span> in column <span>$k$</span>.</p><p>Since we obtain R1C by applying a procedure on cover constraints, we must be able to differentiate them from the other constraints of the model. To do this, we exploit an advantage of Coluna that allows us to attach custom data to the constraints and variables of our model.</p><p>First, we create a special custom data with the only information we need to characterize our cover constraints: the customer id that corresponds to this constraint.</p><pre><code class="language- hljs">struct CoverConstrData &lt;: BlockDecomposition.AbstractCustomData
    customer::Int
end</code></pre><p>We re-create the model:</p><pre><code class="language- hljs">(model, x, y, z, cov) = create_model(coluna, pricing_callback);
nothing #hide</code></pre><p>We declare our custom data to Coluna and we attach one custom data to each cover constraint</p><pre><code class="language- hljs">BlockDecomposition.customconstrs!(model, CoverConstrData);

for i in customers
    customdata!(cov[i], CoverConstrData(i))
end</code></pre><p>In this example, we separate R1Cs for subset of customers of size 3 (<span>$|C|$</span> = 3) and we use the vector of multipliers <span>$\alpha = (0.5, 0.5, 0.5)$</span>. We perform the separation by enumeration (i.e. iterating over all subsets of customers of size 3).</p><p>Therefore our R1Cs will have the following form:</p><p class="math-container">\[\sum_{k \in K} \tilde{\alpha}(C, k) \lambda_k \leq 1; C \subseteq I, |C| = 3\]</p><p>where coefficient <span>$\tilde{\alpha}(C, k)$</span> equals <span>$1$</span> if route <span>$k$</span> visits at least two customers of <span>$C$</span>; <span>$0$</span> otherwise.</p><p>For instance, if we consider separate a cut over constraints <code>cov[3]</code>, <code>cov[6]</code> and <code>cov[8]</code>, then the route <code>1</code>-&gt;<code>4</code>-&gt;<code>6</code>-&gt;<code>7</code> has a zero coefficient while the route <code>1</code>-&gt;<code>4</code>-&gt;<code>6</code>-&gt;<code>3</code> has a coefficient equal to one.</p><p>But a problem arises: how to efficiently get the customers visited by a given route <code>k</code>? We are going to attach a custom data structure that contains the visited customers to each generated column.</p><p>Each <code>λ_k</code> is associated to a <code>R1cVarData</code> structure that carries the locations it visits.</p><pre><code class="language- hljs">struct R1cVarData &lt;: BlockDecomposition.AbstractCustomData
    visited_locations::Vector{Int}
end</code></pre><p>The rank-one cuts are associated with <code>R1cCutData</code> structures indicating which cover constraints are taken into account in the cut.</p><pre><code class="language- hljs">struct R1cCutData &lt;: BlockDecomposition.AbstractCustomData
    cov_constrs::Vector{Int}
end</code></pre><p>We declare our custom data to Coluna:</p><pre><code class="language- hljs">BlockDecomposition.customvars!(model, R1cVarData)
BlockDecomposition.customconstrs!(model, [CoverConstrData, R1cCutData]);
nothing #hide</code></pre><p>You saw from the R1C formula that it&#39;s impossible to compute the coefficient of the columns as a linear expression of the subproblem variables. This is here that custom data structures come into play. When adding new constraints or variables in the model, Coluna will call the <code>computecoeff</code> method each time it finds a pair of variable and constraint that carry custom data. This method must return the coefficient of the variable in the constraint.</p><p>Basically, Coluna calculates the coefficient of a column as the addition of the robust contribution (i.e. linear expression of subproblem variable valuations) and the non-robust contribution retuned by the <code>computecoeff</code> method.</p><p>So we define this first method that Coluna call sget the coefficients of the columns in the R1C:</p><pre><code class="language- hljs">function Coluna.MathProg.computecoeff(
    ::Coluna.MathProg.Variable, var_custom_data::R1cVarData,
    ::Coluna.MathProg.Constraint, constr_custom_data::R1cCutData
)
    return floor(1/2 * length(var_custom_data.visited_locations ∩ constr_custom_data.cov_constrs))
end</code></pre><p>and we also define this method because we needed to attach custom data to cover constraints. Since there is no contribution of the non-robust part of the coefficient of the <code>λ_k</code> in a cover constraint, the method returns 0.</p><pre><code class="language- hljs">function Coluna.MathProg.computecoeff(
    ::Coluna.MathProg.Variable, ::R1cVarData,
    ::Coluna.MathProg.Constraint, ::CoverConstrData)
    return 0
end</code></pre><p>We are now able to write our rank-one cut callback:</p><pre><code class="language-julia hljs">function r1c_callback(cbdata)
    original_sol = cbdata.orig_sol
    master = Coluna.MathProg.getmodel(original_sol)
    # retrieve the cover constraints
    cov_constrs = Int[]
    for constr in values(Coluna.MathProg.getconstrs(master))
        if typeof(constr.custom_data) &lt;: CoverConstrData
            push!(cov_constrs, constr.custom_data.customer)
        end
    end

    # retrieve the master columns λ
    lambdas = Tuple{Float64, Coluna.MathProg.Variable}[]
    for (var_id, val) in original_sol
        if Coluna.MathProg.getduty(var_id) &lt;= Coluna.MathProg.MasterCol
            push!(lambdas, (val, Coluna.MathProg.getvar(cbdata.form, var_id)))
        end
    end

    # separate the valid R1Cs (i.e. those violated by the current solution)
    # for a fixed subset of cover constraints of size 3, iterate on the master columns
    # and check violation:
    for cov_constr_subset in collect(combinations(cov_constrs, 3))
        violation = 0
        for lambda in lambdas
            (val, var) = lambda
            if !isnothing(var.custom_data)
                coeff = floor(1/2 * length(var.custom_data.visited_locations ∩ cov_constr_subset))
                violation += coeff * val
            end
        end
        if violation &gt; 1
            # Create the constraint and add it to the model.
            MOI.submit(model,
                MOI.UserCut(cbdata),
                JuMP.ScalarConstraint(JuMP.AffExpr(0.0), MOI.LessThan(1.0)),
                R1cCutData(cov_constr_subset)
            )
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">r1c_callback (generic function with 1 method)</code></pre><p>You should find disturbing the way we add the non-robust valid inequalities because we literally add the constraint <code>0 &lt;= 1</code> to the model. This is because you don&#39;t have access to the columns from the seperation callbacl and how Coluna computes the coefficient of the columns in the constraints. You can only express the robust-part of the inequality. The non-robust part is calculated in the <code>compute_coeff</code> method.</p><p>The last thing we need to do to complete the implementation of R1Cs is to update our pricing callback. Unlike valid inequalities, R1Cs are not expressed directly with the subproblem variables. Thus, their contribution to the redcued cost of a column is not captured by the reduced cost of subproblem variables. We must therefore take this contribution into account &quot;manually&quot;.</p><p>The contribution of R1Cs to the reduced cost of a route is managed by the following method:</p><pre><code class="language-julia hljs">function r1c_contrib(route::Route, custduals)
    cost=0
    if !isempty(custduals)
        for (r1c_cov_constrs, dual) in custduals
            coeff = floor(1/2 * length(route.path ∩ r1c_cov_constrs))
            cost += coeff*dual
        end
    end
    return cost
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">r1c_contrib (generic function with 1 method)</code></pre><p>We re-write our pricing callback to:</p><ul><li>retrieve the dual cost of the R1Cs</li><li>take into account the contribution of the R1C in the reduced cost of the route</li><li>attach custom data to the route to know which customers are visited by the route and compute its coefficient in the R1Cs</li></ul><pre><code class="language- hljs">function pricing_callback(cbdata)
    j = BlockDecomposition.indice(BlockDecomposition.callback_spid(cbdata, model))
    z_red_costs = Dict(
        &quot;z_$(u)_$(v)&quot; =&gt; BlockDecomposition.callback_reduced_cost(cbdata, z[u, v]) for u in locations, v in locations
    )
    x_red_costs = Dict(
        &quot;x_$(i)_$(j)&quot; =&gt; BlockDecomposition.callback_reduced_cost(cbdata, x[i, j]) for i in customers
    )

    # FIRST CHANGE HERE:
    # Get the dual values of the custom cuts to calculate contributions of
    # non-robust cuts to the cost of the solution:
    custduals = Tuple{Vector{Int}, Float64}[]
    for (_, constr) in Coluna.MathProg.getconstrs(cbdata.form.parent_formulation)
        if typeof(constr.custom_data) == R1cCutData
            push!(custduals, (
                constr.custom_data.cov_constrs,
                Coluna.MathProg.getcurincval(cbdata.form.parent_formulation, constr)
            ))
        end
    end
    # END OF FIRST CHANGE

    # SECOND CHANGE HERE:
    # Keep route with minimum reduced cost: contribution of the subproblem variables and
    # the R1C.
    red_costs_j = map(r -&gt; (
            r,
            x_contribution(r, j, x_red_costs) + z_contribution(r, z_red_costs) - r1c_contrib(r, custduals)
        ), routes_per_facility[j]
    )
    # END OF SECOND CHANGE
    min_index = argmin([x for (_,x) in red_costs_j])
    best_route, min_reduced_cost = red_costs_j[min_index]


    best_route_arcs = Vector{Tuple{Int, Int}}()
    for i in 1:(best_route.length - 1)
        push!(best_route_arcs, (best_route.path[i], best_route.path[i+1]))
    end
    best_route_customers = best_route.path[2:best_route.length]
    z_vars = [z[u, v] for (u,v) in best_route_arcs]
    x_vars = [x[i, j] for i in best_route_customers]
    sol_vars = vcat(z_vars, x_vars)
    sol_vals = ones(Float64, length(z_vars) + length(x_vars))
    sol_cost = min_reduced_cost

    # Submit the solution of the subproblem to Coluna
    # THIRD CHANGE HERE:
    # You must attach the visited customers `R1cVarData` to the solution of the subproblem
    MOI.submit(
        model, BlockDecomposition.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals,
        R1cVarData(best_route.path)
    )
    # END OF THIRD CHANGE
    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), sol_cost)
end

MOI.set(model, MOI.UserCutCallback(), r1c_callback);
JuMP.optimize!(model)</code></pre><h3 id="Multi-stages-pricing-callback"><a class="docs-heading-anchor" href="#Multi-stages-pricing-callback">Multi-stages pricing callback</a><a id="Multi-stages-pricing-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-stages-pricing-callback" title="Permalink"></a></h3><p>In this section, we implement a pricing heuristic that can be used together with the exact pricing callback to generate sub-problems solutions.</p><p>The idea of the heuristic is very simple:</p><ul><li>Given <code>j</code> the idea of the facility, compute the closest customer to j, add it to the route.</li><li>While the reduced cost keeps improving, compute and add to the route its last customer&#39;s nearest neighbor. Stop if the maximum length of the route is reached.</li></ul><p>We first define an auxiliary function used to compute the route tail&#39;s nearest neighbor at each step:</p><pre><code class="language-julia hljs">function add_nearest_neighbor(route::Route, customers, costs)
    # get the last customer of the route
    loc = last(route.path)
    # initialize its nearest neighbor to zero and mincost to infinity
    (nearest, mincost) = (0, Inf)
    # compute nearest and mincost
    for i in customers
        if (i != loc) &amp;&amp; !(i in route.path)
            if (costs[loc, i] &lt; mincost)
                nearest = i
                mincost = costs[loc, i]
            end
        end
    end
    # add the last customer&#39;s nearest neighbor to the route
    if nearest != 0
        push!(route.path, nearest)
        route.length += 1
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">add_nearest_neighbor (generic function with 1 method)</code></pre><p>Then we define our inexact pricing callback:</p><pre><code class="language-julia hljs">function approx_pricing(cbdata)

    j = BlockDecomposition.indice(BlockDecomposition.callback_spid(cbdata, model))
    z_red_costs = Dict(
        &quot;z_$(u)_$(v)&quot; =&gt; BlockDecomposition.callback_reduced_cost(cbdata, z[u, v]) for u in locations, v in locations
        )
    x_red_costs = Dict(
            &quot;x_$(i)_$(j)&quot; =&gt; BlockDecomposition.callback_reduced_cost(cbdata, x[i, j]) for i in customers
        )


    # initialize our &quot;greedy best route&quot;
    best_route = Route(1, [j])
    # initialize the route&#39;s cost to zero
    current_redcost = 0.0
    old_redcost = Inf

    # main loop
    while (current_redcost &lt; old_redcost)
        add_nearest_neighbor(best_route, customers, arc_costs)
        old_redcost = current_redcost
        current_redcost = x_contribution(best_route, j, x_red_costs) +
                          z_contribution(best_route, z_red_costs)
        # max length is reached
        if best_route.length == nb_positions
            break
        end
    end

    best_route_arcs = Vector{Tuple{Int, Int}}()
    for i in 1:(best_route.length - 1)
        push!(best_route_arcs, (best_route.path[i], best_route.path[i+1]))
    end
    best_route_customers = best_route.path[2:length(best_route.path)]

    z_vars = [z[u, v] for (u,v) in best_route_arcs]
    x_vars = [x[i, j] for i in best_route_customers]
    sol_vars = vcat(z_vars, x_vars)
    sol_vals = ones(Float64, length(z_vars) + length(x_vars))
    # take the eventual rank-one cuts contribution into account
    sol_cost = current_redcost

    MOI.submit(model, BlockDecomposition.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)
    # as the procedure is inexact, no dual bound can be computed, we set it to -Inf
    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), -Inf)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">approx_pricing (generic function with 1 method)</code></pre><p>We set the solver, <code>colgen_stages_pricing_solvers</code> indicates which solver to use first (here it is <code>approx_pricing</code>)</p><pre><code class="language- hljs">coluna = JuMP.optimizer_with_attributes(
        Coluna.Optimizer,
        &quot;default_optimizer&quot; =&gt; GLPK.Optimizer,
        &quot;params&quot; =&gt; Coluna.Params(
            solver = Coluna.Algorithm.BranchCutAndPriceAlgorithm(
                maxnumnodes = 100,
            colgen_stages_pricing_solvers = [2, 1]
        )
    )
)</code></pre><p>We add the two pricing algorithms to our model:</p><pre><code class="language- hljs">model, x, y, z, cov = create_model(coluna, [approx_pricing, pricing_callback])</code></pre><p>We declare our custom data to Coluna:</p><pre><code class="language- hljs">BlockDecomposition.customvars!(model, R1cVarData)
BlockDecomposition.customconstrs!(model, [CoverConstrData, R1cCutData]);
for i in customers
    customdata!(cov[i], CoverConstrData(i))
end</code></pre><p>Optimize:</p><pre><code class="language- hljs">JuMP.optimize!(model)</code></pre><h2 id="Benders-decomposition"><a class="docs-heading-anchor" href="#Benders-decomposition">Benders decomposition</a><a id="Benders-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Benders-decomposition" title="Permalink"></a></h2><pre><code class="language- hljs">fake = 1
@axis(axis, collect(fake:fake))

coluna = JuMP.optimizer_with_attributes(
    Coluna.Optimizer,
    &quot;params&quot; =&gt; Coluna.Params(

        solver = Coluna.Algorithm.BendersCutGeneration()
    ),
    &quot;default_optimizer&quot; =&gt; GLPK.Optimizer
)

model = BlockModel(coluna)
# model = Model(GLPK.Optimizer)

covering_routes = Dict(
    (j, i) =&gt; findall(r -&gt; (i in r.path), routes_per_facility[j]) for i in customers, j in facilities
)
routes_costs = Dict(
    j =&gt; [route_original_cost(arc_costs, r) for r in routes_per_facility[j]] for j in facilities
)


# master variables

@variable(model, 0 &lt;= y[j in facilities] &lt;= 1)


# sp variables
@variable(model, 0 &lt;= λ[f in axis, j in facilities, k in 1:length(routes_per_facility[j])] &lt;= 1) # λj,q = 1 -&gt; route (j,q) is opened

@constraint(model, open[fake in axis, j in facilities, k in 1:length(routes_per_facility[j])],
    y[j] &gt;= λ[fake, j, k])

@constraint(model, cover[fake in axis, i in customers],
    sum(λ[fake, j, k] for j in facilities, k in covering_routes[(j,i)]) &gt;= 1)

@constraint(model, limit_nb_routes[fake in axis, j in facilities],
    sum(λ[fake, j, q] for q in 1:length(routes_per_facility[j])) &lt;= nb_routes_per_facility
)


@constraint(model, min_opening,
    sum(y[j] for j in facilities) &gt;= 1)

@objective(model, Min,
    sum(facilities_fixed_costs[j] * y[j] for j in facilities) +
    sum(routes_costs[j][k] * λ[fake, j, k] for j in facilities, k in 1:length(routes_per_facility[j])))

@benders_decomposition(model, dec, axis)
JuMP.optimize!(model)
@show objective_value(model)</code></pre><h2 id="Example-of-comparison-of-the-dual-bounds-obtained-on-a-larger-instance."><a class="docs-heading-anchor" href="#Example-of-comparison-of-the-dual-bounds-obtained-on-a-larger-instance.">Example of comparison of the dual bounds obtained on a larger instance.</a><a id="Example-of-comparison-of-the-dual-bounds-obtained-on-a-larger-instance.-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-comparison-of-the-dual-bounds-obtained-on-a-larger-instance." title="Permalink"></a></h2><p>In this section, we propose to create an instance with 3 facilities and 20 customers. We will solve only the root node and look at the dual bound:</p><ul><li>with the &quot;raw&quot; decomposition model</li><li>by adding robust cuts</li><li>by adding non-robust cuts</li><li>by adding both robust and non-robust cuts</li></ul><pre><code class="language- hljs">nb_positions = 6
facilities_fixed_costs = [120, 150, 110]
facilities = [1, 2, 3]
customers = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
arc_costs = [
    0.0    125.6  148.9  182.2  174.9  126.2  158.6  172.9  127.4  133.1  152.6  183.8  182.4  176.9  120.7  129.5;
    123.6    0.0  175.0  146.7  191.0  130.4  142.5  139.3  130.1  133.3  163.8  127.8  139.3  128.4  186.4  115.6;
    101.5  189.6    0.0  198.2  150.5  159.6  128.3  133.0  195.1  167.3  187.3  178.1  171.7  161.5  142.9  142.1;
    159.4  188.4  124.7    0.0  174.5  174.0  142.6  102.5  135.5  184.4  121.6  112.1  139.9  105.5  190.9  140.7;
    157.7  160.3  184.2  196.1    0.0  115.5  175.2  153.5  137.7  141.3  109.5  107.7  125.3  151.0  133.1  140.6;
    145.2  120.4  106.7  138.8  157.3    0.0  153.6  192.2  153.2  184.4  133.6  164.9  163.6  126.3  121.3  161.4;
    182.6  152.1  178.8  184.1  150.8  163.5    0.0  164.1  104.0  100.5  117.3  156.1  115.1  168.6  186.5  100.2;
    144.9  193.8  146.1  191.4  136.8  172.7  108.1    0.0  131.0  166.3  116.4  187.0  161.3  148.2  162.1  116.0;
    173.4  199.1  132.9  133.2  139.8  112.7  138.1  118.8    0.0  173.4  131.8  180.6  191.0  133.9  178.7  108.7;
    150.5  171.0  163.8  171.5  116.3  149.1  124.0  192.5  188.8    0.0  112.2  188.7  197.3  144.9  110.7  186.6;
    153.6  104.4  141.1  124.7  121.1  137.5  190.3  177.1  194.4  135.3    0.0  146.4  132.7  103.2  150.3  118.4;
    112.5  133.7  187.1  170.0  130.2  177.7  159.2  169.9  183.8  101.6  156.2    0.0  114.7  169.3  149.9  125.3;
    151.5  165.6  162.1  133.4  159.4  200.5  132.7  199.9  136.8  121.3  118.1  123.4    0.0  104.8  197.1  134.4;
    195.0  101.1  194.1  160.1  147.1  164.6  137.2  138.6  166.7  191.2  169.2  186.0  171.2    0.0  106.8  150.9;
    158.2  152.7  104.0  136.0  168.9  175.7  139.2  163.2  102.7  153.3  185.9  164.0  113.2  200.7    0.0  127.4;
    136.6  174.3  103.2  131.4  107.8  191.6  115.1  127.6  163.2  123.2  173.3  133.0  120.5  176.9  173.8    0.0
]

locations  = vcat(facilities, customers)
nb_customers = length(customers)
nb_facilities = length(facilities)
positions = 1:nb_positions;

routes_per_facility = Dict(
    j =&gt; best_route_forall_cust_subsets(arc_costs, customers, j, nb_positions) for j in facilities
);
nothing #hide</code></pre><p>We set <code>maxnumnodes</code> to zero to optimize only the root node:</p><pre><code class="language- hljs">coluna = optimizer_with_attributes(
    Coluna.Optimizer,
    &quot;params&quot; =&gt; Coluna.Params(
        solver = Coluna.Algorithm.TreeSearchAlgorithm(
        maxnumnodes = 0,
        conqueralg = Coluna.ColCutGenConquer()
        )
        ),
        &quot;default_optimizer&quot; =&gt; GLPK.Optimizer
);
nothing #hide</code></pre><p>We define a method to call both <code>valid_inequalities_callback</code> and <code>r1c_callback</code>:</p><pre><code class="language-julia hljs">function cuts_callback(cbdata)
    valid_inequalities_callback(cbdata)
    r1c_callback(cbdata)
end

function attach_data(model, cov)
    BlockDecomposition.customvars!(model, R1cVarData)
    BlockDecomposition.customconstrs!(model, [CoverConstrData, R1cCutData]);
    for i in customers
        customdata!(cov[i], CoverConstrData(i))
    end
end;</code></pre><p>First, we solve the root node with the &quot;raw&quot; decomposition model:</p><pre><code class="language- hljs">model, x, y, z, cov = create_model(coluna, pricing_callback)
attach_data(model, cov)</code></pre><p>dual bound found after optimization = 1588.00</p><p>Then, we re-solve it with the robust cuts:</p><pre><code class="language- hljs">model, x, y, z, cov = create_model(coluna, pricing_callback)
attach_data(model, cov)
MOI.set(model, MOI.UserCutCallback(), valid_inequalities_callback);
nothing #hide</code></pre><p>dual bound found after optimization = 1591.55</p><p>And with non-robust cuts:</p><pre><code class="language- hljs">model, x, y, z, cov = create_model(coluna, pricing_callback)
attach_data(model, cov)
MOI.set(model, MOI.UserCutCallback(), r1c_callback);
nothing #hide</code></pre><p>dual bound found after optimization = 1598.26</p><p>Finally we add both robust and non-robust cuts:</p><pre><code class="language- hljs">model, x, y, z, cov = create_model(coluna, pricing_callback)
attach_data(model, cov)
MOI.set(model, MOI.UserCutCallback(), cuts_callback);
nothing #hide</code></pre><p>dual bound found after optimization =  1600.63</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../initial_columns/">« Initial columns callback</a><a class="docs-footer-nextpage" href="../../man/decomposition/">Decomposition »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 12 May 2023 12:33">Friday 12 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
