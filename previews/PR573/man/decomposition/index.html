<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Decomposition · Coluna User Guide</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna User Guide</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../start/start/">Getting started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Decomposition</a><ul class="internal"><li><a class="tocitem" href="#Dantzig-Wolfe"><span>Dantzig-Wolfe</span></a></li><li><a class="tocitem" href="#Benders"><span>Benders</span></a></li><li><a class="tocitem" href="#Identical-subproblems-(alpha)"><span>Identical subproblems (alpha)</span></a></li><li class="toplevel"><a class="tocitem" href="#BlockDecomposition"><span>BlockDecomposition</span></a></li><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../algorithm/">Algorithms</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Decomposition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Decomposition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/man/decomposition.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Decomposition-and-reformulation"><a class="docs-heading-anchor" href="#Decomposition-and-reformulation">Decomposition &amp; reformulation</a><a id="Decomposition-and-reformulation-1"></a><a class="docs-heading-anchor-permalink" href="#Decomposition-and-reformulation" title="Permalink"></a></h1><p>Coluna is a framework to optimizate mixed-integer programs that you can decompose. In other words, if you remove the linking constraints or linking variables from you program, you&#39;ll get sets of constraints (blocks) that you can solve independently.</p><h2 id="Dantzig-Wolfe"><a class="docs-heading-anchor" href="#Dantzig-Wolfe">Dantzig-Wolfe</a><a id="Dantzig-Wolfe-1"></a><a class="docs-heading-anchor-permalink" href="#Dantzig-Wolfe" title="Permalink"></a></h2><p>Let&#39;s consider the following coefficient matrix that has a block diagonal structure in gray and some linking constraints in blue :</p><p><img src="../../static/dwdec.png" alt="Dantzig-Wolfe decomposition"/></p><p>You penalize the violation of the linking constraints in the objective function. You can then solve the blocks independently.</p><p>The Dantzig-Wolfe reformulation gives raise to a master problem with an exponential number of variables. Coluna dynamically generates these variables by solving the subproblems. It&#39;s the column generation algorithm.</p><p>Let&#39;s consider the following original formulation in which we partition variables into two vectors <span>$x_1$</span> and <span>$x_2$</span> :</p><p><img src="../../static/dw_origform.svg" alt="Original formulation"/></p><p>Coluna reformulates the formulation into the following master problem :</p><p><img src="../../static/dw_master.svg" alt="Master formulation"/></p><p>where <span>$Q_1$</span> is the index-set of the solutions to the first subproblem and  <span>$Q_2$</span> is the index-set of the solutions to the second subproblem. The set of the solutions to the first and the second subproblems are <span>$\{\tilde{x}^q_1\}_{q \in Q_1}$</span> and <span>$\{\tilde{x}^q_2\}_{q \in Q_2}$</span> respectively. These solutions are expressed in terms of the original variables. The multiplicity of the subproblems is defined in the convexity constraints. Lower and upper multiplicity are <span>$1$</span> by default.</p><p>Subproblems take the following form (here, it&#39;s the first subproblem) :</p><p><img src="../../static/dw_sp.svg" alt="Subproblem n°1 formulation"/></p><p>where the <span>$\bar{c}$</span> is the reduced cost of the original variables computed by the column generation algorihm.</p><h2 id="Benders"><a class="docs-heading-anchor" href="#Benders">Benders</a><a id="Benders-1"></a><a class="docs-heading-anchor-permalink" href="#Benders" title="Permalink"></a></h2><p>Let&#39;s consider the following coefficient matrix that has a block diagonal structure in gray and some linking variables in blue :</p><p><img src="../../static/bdec.png" alt="Benders decomposition"/></p><p>You fix the complicated variables, then you can solve the blocks independently.</p><p>This decomposition is an alpha feature.</p><h2 id="Identical-subproblems-(alpha)"><a class="docs-heading-anchor" href="#Identical-subproblems-(alpha)">Identical subproblems (alpha)</a><a id="Identical-subproblems-(alpha)-1"></a><a class="docs-heading-anchor-permalink" href="#Identical-subproblems-(alpha)" title="Permalink"></a></h2><p>When some subproblems are identical (same coefficient matrix and rhs),  you can avoid solving all of them at each iteration by defining only one subproblem and setting its multiplicity to the number of time it appears.</p><p>Let us see an example with Dantzig-Wolfe and a variant of the Generalized Assignment Problem.</p><p>Consider a set of machine type <code>T = 1:nb_machine_types</code> and a set of jobs <code>J = 1:nb_jobs</code>. A machine type <code>t</code> has a resource capacity <code>Q[t]</code> and the factory contains <code>U[t]</code> machines of type <code>t</code>. A job <code>j</code> assigned to a machine of type <code>t</code> has a cost <code>c[t,j]</code> and consumes <code>w[t,j]</code> resource units of the machine of type <code>t</code>.</p><p>Consider the following instance :</p><pre><code class="language-julia hljs">nb_machine_types = 2;
nb_jobs = 10;
J = 1:nb_jobs;
Q = [10, 15];
U = [3, 2];  # 3 machines of type 1 &amp; 2 machines of type 2
c = [10 11 13 11 12 14 15 8 9 11; 20 21 23 21 22 24 25 18 19 21];
w = [4 4 5 4 4 3 4 5 6 5; 5 5 6 5 5 4 5 6 7 6];</code></pre><p>Here is the JuMP model to optimize this instance a classic solver : </p><pre><code class="language-julia hljs">using JuMP, GLPK;

T1 = [1, 2, 3]; # U[1] machines
T2 = [4, 5]; # U[2] machines
M = union(T1, T2);
m2t = [1, 1, 1, 2, 2]; # machine id -&gt; type id

model = Model(GLPK.Optimizer);
@variable(model, x[M, J], Bin); # 1 if job j assigned to machine m
@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1);
@constraint(model, knp[m in M], sum(w[m2t[m],j] * x[m,j] for j in J) &lt;= Q[m2t[m]]);
@objective(model, Min, sum(c[m2t[m],j] * x[m,j] for m in M, j in J));

optimize!(model);
objective_value(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">154.0</code></pre><p>You can decompose over the machines by defining an axis on <code>M</code>. However, if you want to take advantage of the identical subproblems, you must  define the formulation as follows : </p><pre><code class="language-julia hljs">using BlockDecomposition, Coluna, JuMP, GLPK;
const BD = BlockDecomposition

coluna = optimizer_with_attributes(
    Coluna.Optimizer,
    &quot;params&quot; =&gt; Coluna.Params(
        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP
    ),
    &quot;default_optimizer&quot; =&gt; GLPK.Optimizer # GLPK for the master &amp; the subproblems
);

@axis(T, 1:nb_machine_types);

model = BlockModel(coluna);
@variable(model, x[T, J], Bin); # 1 if job j assigned to machine m
@constraint(model, cov[j in J], sum(x[t,j] for t in T) == 1);
@constraint(model, knp[t in T], sum(w[t] * x[t,j] for j in J) &lt;= Q[t]);
@objective(model, Min, sum(c[t,j] * x[t,j] for t in T, j in J));</code></pre><p>We assign jobs to a type of machine and we define one knapsack constraint for each type. This formulation cannot be solved as it stands with a commercial solver.</p><p>Then, we decompose and specify the multiplicity of each knapsack subproblem : </p><pre><code class="language-julia hljs">@dantzig_wolfe_decomposition(model, dec_on_types, T);
sps = getsubproblems(dec_on_types)
for t in T
    specify!(sps[t], lower_multiplicity = 0, upper_multiplicity = U[t]);
end
getsubproblems(dec_on_types)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{BlockDecomposition.SubproblemForm}:
 Subproblem formulation for T = 1 contains :	 0.0 &lt;= multiplicity &lt;= 3.0

 Subproblem formulation for T = 2 contains :	 0.0 &lt;= multiplicity &lt;= 2.0
</code></pre><p>We see that subproblem for machine type 1 has upper multiplicity equals to 3, and second subproblem for machine type 2 has upper multiplicity equals to 2. It means that we can use at most 3 machines of type 1 and at most 2 machines of type 2.</p><p>We can then optimize</p><pre><code class="language-julia hljs">optimize!(model);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Coluna
Version dev-0.4.0 | 2021-MM-DD | https://github.com/atoptima/Coluna.jl
┌ Warning: No initial primal bound and no cost for global artificial variables.
│ Cost of global artificial variables set to 100000.0
└ @ Coluna ~/work/Coluna.jl/Coluna.jl/src/optimize.jl:20
┌ Warning: No initial primal bound and no cost for local artificial variables.
│ Cost of local artificial variables set to 10000.0
└ @ Coluna ~/work/Coluna.jl/Coluna.jl/src/optimize.jl:33
***************************************************************************************
**** BaB tree root node
**** Local DB = -Inf, global bounds : [ -Inf , Inf ], time = 0.02 sec.
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 1.32&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=100000.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  2&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=70057.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  3&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=60117.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  4&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=55089.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  5&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=40090.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  6&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=10159.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  7&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=10159.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  8&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp= 2647.7500&gt; &lt;PB=Inf&gt;
  &lt;it=  9&gt; &lt;et= 1.34&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp= 1151.7000&gt; &lt;PB=Inf&gt;
  &lt;it= 10&gt; &lt;et= 1.49&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=Inf&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
┌ Warning: Solver has no result to show.
└ @ Coluna.Algorithm ~/work/Coluna.jl/Coluna.jl/src/Algorithm/basic/solvelpform.jl:73
***************************************************************************************
**** BaB tree node N° 2, parent N° 1, depth 1, 2 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , Inf ], time = 3.64 sec.
**** Branching constraint: PricingSetupVar_sp_4&gt;=2.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.71&gt; &lt;mst= 0.05&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  174.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  2&gt; &lt;et= 3.71&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=Inf&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
┌ Warning: Solver has no result to show.
└ @ Coluna.Algorithm ~/work/Coluna.jl/Coluna.jl/src/Algorithm/basic/solvelpform.jl:73
***************************************************************************************
**** BaB tree node N° 3, parent N° 2, depth 2, 3 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , Inf ], time = 3.72 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.72&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=Inf&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
┌ Warning: Solver has no result to show.
└ @ Coluna.Algorithm ~/work/Coluna.jl/Coluna.jl/src/Algorithm/basic/solvelpform.jl:73
***************************************************************************************
**** BaB tree node N° 4, parent N° 3, depth 3, 4 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , Inf ], time = 3.72 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.72&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 1820.6667&gt; &lt;PB=Inf&gt;
  &lt;it=  2&gt; &lt;et= 3.72&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 1820.6667&gt; &lt;PB=Inf&gt;
  &lt;it=  3&gt; &lt;et= 3.72&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=Inf&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
***************************************************************************************
**** BaB tree node N° 5, parent N° 4, depth 4, 5 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 174.0000 ], time = 3.89 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.89&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 3070.6667&gt; &lt;PB=174.0000&gt;
  &lt;it=  2&gt; &lt;et= 3.89&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=174.0000&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
┌ Warning: Solver has no result to show.
└ @ Coluna.Algorithm ~/work/Coluna.jl/Coluna.jl/src/Algorithm/basic/solvelpform.jl:73
***************************************************************************************
**** BaB tree node N° 6, parent N° 5, depth 5, 6 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 174.0000 ], time = 3.89 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.89&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 3487.3333&gt; &lt;PB=174.0000&gt;
  &lt;it=  2&gt; &lt;et= 3.89&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 3487.3333&gt; &lt;PB=174.0000&gt;
  &lt;it=  3&gt; &lt;et= 3.89&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 1820.6667&gt; &lt;PB=174.0000&gt;
  &lt;it=  4&gt; &lt;et= 3.89&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 1820.6667&gt; &lt;PB=174.0000&gt;
  &lt;it=  5&gt; &lt;et= 3.89&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=174.0000&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
***************************************************************************************
**** BaB tree node N° 7, parent N° 6, depth 6, 7 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 174.0000 ], time = 3.90 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.90&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 3487.3333&gt; &lt;PB=174.0000&gt;
  &lt;it=  2&gt; &lt;et= 3.90&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 3487.3333&gt; &lt;PB=174.0000&gt;
  &lt;it=  3&gt; &lt;et= 3.90&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=174.0000&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
┌ Warning: Solver has no result to show.
└ @ Coluna.Algorithm ~/work/Coluna.jl/Coluna.jl/src/Algorithm/basic/solvelpform.jl:73
***************************************************************************************
**** BaB tree node N° 8, parent N° 7, depth 7, 8 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 174.0000 ], time = 3.90 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.90&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=174.0000&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
┌ Warning: Solver has no result to show.
└ @ Coluna.Algorithm ~/work/Coluna.jl/Coluna.jl/src/Algorithm/basic/solvelpform.jl:73
***************************************************************************************
**** BaB tree node N° 9, parent N° 8, depth 8, 9 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 174.0000 ], time = 3.90 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.90&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=174.0000&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
┌ Warning: Solver has no result to show.
└ @ Coluna.Algorithm ~/work/Coluna.jl/Coluna.jl/src/Algorithm/basic/solvelpform.jl:73
***************************************************************************************
**** BaB tree node N° 10, parent N° 9, depth 9, 10 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 174.0000 ], time = 3.90 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.90&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 2659.0000&gt; &lt;PB=174.0000&gt;
  &lt;it=  2&gt; &lt;et= 3.90&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=174.0000&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
┌ Warning: Solver has no result to show.
└ @ Coluna.Algorithm ~/work/Coluna.jl/Coluna.jl/src/Algorithm/basic/solvelpform.jl:73
***************************************************************************************
**** BaB tree node N° 11, parent N° 10, depth 10, 11 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 174.0000 ], time = 3.91 sec.
**** Branching constraint: v&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et= 3.91&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  159.0000&gt; &lt;PB=174.0000&gt;
  &lt;it=  2&gt; &lt;et= 3.91&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=154.0000&gt;
[ Info: Dual bound reached primal bound.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 12, parent N° 10, depth 10, 10 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.92 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: -1.6425533372116214e-14. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 13, parent N° 9, depth 9, 9 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: -1.6425533372116214e-14. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 14, parent N° 8, depth 8, 8 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: -1.6425533372116214e-14. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 15, parent N° 7, depth 7, 7 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: -1.6425533372116214e-14. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 16, parent N° 6, depth 6, 6 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: 5.905809751772254e-15. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 17, parent N° 5, depth 5, 5 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: 5.905809751772254e-15. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 18, parent N° 4, depth 4, 4 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: 7.197705634972443e-15. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 19, parent N° 3, depth 3, 3 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: 7.197705634972443e-15. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 20, parent N° 2, depth 2, 2 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: v&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: 7.197705634972443e-15. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 21, parent N° 1, depth 1, 1 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 3.93 sec.
**** Branching constraint: PricingSetupVar_sp_4&lt;=1.0
***************************************************************************************
[ Info: IP Gap is closed: 7.197705634972443e-15. Abort treatment.
Node is already conquered. No children will be generated.
 ──────────────────────────────────────────────────────────────────────────────
                                       Time                   Allocations
                               ──────────────────────   ───────────────────────
       Tot / % measured:             116s / 21.8%           7.50GiB / 24.1%

 Section               ncalls     time   %tot     avg     alloc   %tot      avg
 ──────────────────────────────────────────────────────────────────────────────
 Coluna                     2    25.2s   100%   12.6s   1.81GiB  100%    925MiB
   SolveLpForm             34    2.79s  11.1%  82.0ms   71.9MiB  3.89%  2.11MiB
   Inserting columns       33    607ms  2.41%  18.4ms   21.2MiB  1.14%   657KiB
   Cleanup columns         34    304ms  1.21%  8.94ms   12.8MiB  0.69%   387KiB
   Getting primal s...     34    204ms  0.81%  6.01ms   3.05MiB  0.17%  92.0KiB
   Store records           22    155ms  0.61%  7.04ms   5.38MiB  0.29%   250KiB
   Update Lagrangia...     33    143ms  0.57%  4.33ms   3.07MiB  0.17%  95.1KiB
   Add branching co...     20    141ms  0.56%  7.04ms   4.54MiB  0.25%   233KiB
   Update reduced c...     34    117ms  0.46%  3.44ms   4.79MiB  0.26%   144KiB
   Smoothing update        34   26.8ms  0.11%   788μs   4.26MiB  0.23%   128KiB
   Restore/remove r...     21   88.3μs  0.00%  4.20μs     0.00B  0.00%    0.00B
 ──────────────────────────────────────────────────────────────────────────────
[ Info: Terminated
[ Info: Primal bound: 154.0000000000011
[ Info: Dual bound: 154.0</code></pre><p>and retrieve the disagreggated solution</p><pre><code class="language- hljs">for t in T
    assignment_patterns = BD.getsolutions(model, t);
    for pattern in assignment_patterns
        nb_times_pattern_used = BD.value(pattern);
        jobs_in_pattern = [];
        for j in J
            if BD.value(pattern, x[t, j]) ≈ 1
                push!(jobs_in_pattern, j);
            end
        end
        println(&quot;Pattern of machine type $t used $nb_times_pattern_used times : $jobs_in_pattern&quot;);
    end
end</code></pre><h1 id="BlockDecomposition"><a class="docs-heading-anchor" href="#BlockDecomposition">BlockDecomposition</a><a id="BlockDecomposition-1"></a><a class="docs-heading-anchor-permalink" href="#BlockDecomposition" title="Permalink"></a></h1><p>The index-set of the subproblems is declared through an <a href="#BlockDecomposition.@axis"><code>BlockDecomposition.@axis</code></a>.  It returns an array. Each value of the array is a subproblem index wrapped into a <code>BlockDecomposition.AxisId</code>. Each time BlockDecomposition finds an <code>AxisId</code> in the indices of a variable and a constraint, it knows to which subproblem the variable or the constraint belongs.</p><p>BlockDecomposition allows the user to perform two types of decomposition using <a href="#BlockDecomposition.@dantzig_wolfe_decomposition"><code>BlockDecomposition.@dantzig_wolfe_decomposition</code></a> and <a href="#BlockDecomposition.@benders_decomposition"><code>BlockDecomposition.@benders_decomposition</code></a>.</p><p>The macro creates a decomposition tree where the root is the master and the depth is the number of nested decomposition. A classic Dantzig-Wolfe or Benders decomposition produces a decomposition tree of depth 1. At the moment, nested decomposition is not supported.</p><p>You can get the subproblem membership of all variables and constraints using the method <a href="#BlockDecomposition.annotation"><code>BlockDecomposition.annotation</code></a>.</p><p>BlockDecomposition does not change the JuMP model. It decorates the model with additional information. All these information are stored in the <code>ext</code> field of the JuMP model.</p><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>BlockModel</code>. Check Documenter&#39;s build log for details.</p></div></div><p>These are the methods to decompose a JuMP model :</p><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.@axis" href="#BlockDecomposition.@axis"><code>BlockDecomposition.@axis</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@axis(name, collection)</code></pre><p>Declare <code>collection</code> as an index-set of subproblems.  You can access the axis using the variable <code>name</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @axis(K, 1:5)
BlockDecomposition.Axis{:K, Int64}(:K, BlockDecomposition.AxisId{:K, Int64}[1, 2, 3, 4, 5])</code></pre><p>In this example, we declare an axis named <code>K</code> that contains 5 entries.  The index-set of the subproblems is <code>[1, 2, 3, 4, 5]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; K[1]
1

julia&gt; typeof(K[1])
BlockDecomposition.AxisId{:K, Int64}</code></pre><p>The elements of the axis are <code>AxisId</code>. The user must use <code>AxisId</code> in the indices of the variables and the constraints because BlockDecomposition use them to  decompose the MIP.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.@benders_decomposition" href="#BlockDecomposition.@benders_decomposition"><code>BlockDecomposition.@benders_decomposition</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@benders_decomposition(model, name, axis)</code></pre><p>Register a Benders decomposition on the JuMP model <code>model</code> where the index-set of the subproblems are <code>axis</code>.</p><p>Create a variable <code>name</code> from which the user can access the node of the Decomposition tree where the master of this decomposition is stored.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.@dantzig_wolfe_decomposition" href="#BlockDecomposition.@dantzig_wolfe_decomposition"><code>BlockDecomposition.@dantzig_wolfe_decomposition</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@dantzig_wolfe_decomposition(model, name, axis)</code></pre><p>Register a Dantzig-Wolfe decomposition on the JuMP model <code>model</code> where the index-set of the subproblems are <code>axis</code>.</p><p>Create a variable <code>name</code> from which the user can access the node of the decomposition tree where the master of this decomposition is stored.</p></div></section></article><p>These are the methods to set additional information to the decomposition (multiplcity and optimizers) :</p><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.getmaster" href="#BlockDecomposition.getmaster"><code>BlockDecomposition.getmaster</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getmaster(node) -&gt; MasterForm</code></pre><p>Return an object that wraps the annotation that describes the master formulation of a decomposition stored at the <code>node</code> of the decomposition tree.</p><p>This method is not defined if the node is a leaf of the decomposition tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.getsubproblems" href="#BlockDecomposition.getsubproblems"><code>BlockDecomposition.getsubproblems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getsubproblems(node) -&gt; Vector{SubproblemForm}</code></pre><p>Return a vector of objects that wrap the annotations that describe subproblem formulations of a decomposition stored at <code>node</code> of the decomposition tree.</p><p>This method is not defined if the node is a leaf of the decomposition tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.specify!" href="#BlockDecomposition.specify!"><code>BlockDecomposition.specify!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">specify!(
    subproblem, 
    lower_multiplicity = 1,
    upper_multiplicity = 1,
    solver = nothing
)</code></pre><p>Method that allows the user to specify additional property of the subproblems.</p><p>The multiplicity of <code>subproblem</code> is the number of times that the same independant block shaped by the subproblem in the coefficient matrix appears in the model. It is equivalent to the number of solutions to the subproblem that can appear in the solution  of the original problem.</p><p>The solver of the subproblem is the way the subproblem will be optimized. It can be either a function (pricing callback), an optimizer of MathOptInterface  (e.g. <code>Gurobi.Optimizer</code>, <code>CPLEX.Optimizer</code>, <code>Glpk.Optimizer</code>... with attributes),  or <code>nothing</code>. In the latter case, the solver will use a default optimizer that  should be defined in the parameters of the main solver.</p><p><strong>Advanced usage</strong> :  The user can use several solvers to optimize a subproblem : </p><pre><code class="nohighlight hljs">specify!(subproblem, solver = [Gurobi.Optimizer, my_callback, my_second_callback])</code></pre><p>Coluna always uses the first solver by default. Be cautious because changes are always buffered to all solvers. So you may degrade performances if you use a lot of solvers.</p></div></section></article><p>This method help you to check your decomposition :</p><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.annotation" href="#BlockDecomposition.annotation"><code>BlockDecomposition.annotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">annotation(node)</code></pre><p>Return the annotation that describes the master/subproblem of a given node of the decomposition tree.</p><pre><code class="nohighlight hljs">annotation(model, variable)
annotation(model, constraint)</code></pre><p>Return the subproblem to which a variable or a constraint belongs.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../start/start/">« Getting started</a><a class="docs-footer-nextpage" href="../algorithm/">Algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Sunday 8 August 2021 17:54">Sunday 8 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
