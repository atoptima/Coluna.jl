var documenterSearchIndex = {"docs":
[{"location":"man/decomposition/#Decomposition-and-reformulation","page":"Decomposition","title":"Decomposition & reformulation","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Coluna is a framework to optimizate mixed-integer programs that you can decompose. In other words, if you remove the linking constraints or linking variables from you program, you'll get sets of constraints (blocks) that you can solve independently.","category":"page"},{"location":"man/decomposition/#Dantzig-Wolfe","page":"Decomposition","title":"Dantzig-Wolfe","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following coefficient matrix that has a block diagonal structure in gray and some linking constraints in blue :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Dantzig-Wolfe decomposition)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You penalize the violation of the linking constraints in the objective function. You can then solve the blocks independently.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The Dantzig-Wolfe reformulation gives raise to a master problem with an exponential number of variables. Coluna dynamically generates these variables by solving the subproblems. It's the column generation algorithm.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following original formulation in which we partition variables into two vectors x_1 and x_2 :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Original formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"When you apply a Dantzig-Wofe decomposition to this formulation,  Coluna reformulates it into the following master problem :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Master formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"where Q_1 is the index-set of the solutions to the first subproblem and  Q_2 is the index-set of the solutions to the second subproblem. The set of the solutions to the first and the second subproblems are tildex^q_1_q in Q_1 and tildex^q_2_q in Q_2 respectively. These solutions are expressed in terms of the original variables. The multiplicity of the subproblems is defined in the convexity constraints. Lower and upper multiplicity are 1 by default.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"At the beginning of the column generation algorithm, the master formulation does not have any master columns. Therefore, the master may be infeasible.  To prevent this, Coluna adds a local artifical variable specific to each constraint of the master and a global artificial variable. Costs of articial and global artificial variables can be defined in Coluna.Params.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Subproblems take the following form (here, it's the first subproblem) :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Subproblem n°1 formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"where barc is the reduced cost of the original variables computed by the column generation algorithm.","category":"page"},{"location":"man/decomposition/#Dantzig-Wolfe-with-identical-subproblems-(alpha)","page":"Decomposition","title":"Dantzig-Wolfe with identical subproblems (alpha)","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"When some subproblems are identical (same coefficient matrix and rhs),  you can avoid solving all of them at each iteration by defining only one subproblem and setting its multiplicity to the number of time it appears.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let us see an example with Dantzig-Wolfe and a variant of the Generalized Assignment Problem.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Consider a set of machine type T = 1:nb_machine_types and a set of jobs J = 1:nb_jobs. A machine type t has a resource capacity Q[t] and the factory contains U[t] machines of type t. A job j assigned to a machine of type t has a cost c[t,j] and consumes w[t,j] resource units of the machine of type t.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Consider the following instance :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"nb_machine_types = 2;\nnb_jobs = 10;\nJ = 1:nb_jobs;\nQ = [10, 15];\nU = [3, 2];  # 3 machines of type 1 & 2 machines of type 2\nc = [10 11 13 11 12 14 15 8 9 11; 20 21 23 21 22 24 25 18 19 21];\nw = [4 4 5 4 4 3 4 5 6 5; 5 5 6 5 5 4 5 6 7 6];\nnothing #hide","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Here is the JuMP model to optimize this instance a classic solver : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"using JuMP, GLPK;\n\nT1 = [1, 2, 3]; # U[1] machines\nT2 = [4, 5]; # U[2] machines\nM = union(T1, T2);\nm2t = [1, 1, 1, 2, 2]; # machine id -> type id\n\nmodel = Model(GLPK.Optimizer);\n@variable(model, x[M, J], Bin); # 1 if job j assigned to machine m\n@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1);\n@constraint(model, knp[m in M], sum(w[m2t[m],j] * x[m,j] for j in J) <= Q[m2t[m]]);\n@objective(model, Min, sum(c[m2t[m],j] * x[m,j] for m in M, j in J));\n\noptimize!(model);\nobjective_value(model)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You can decompose over the machines by defining an axis on M. However, if you want to take advantage of the identical subproblems, you must  define the formulation as follows : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"using BlockDecomposition, Coluna, JuMP, GLPK;\nconst BD = BlockDecomposition\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\n\n@axis(T, 1:nb_machine_types);\n\nmodel = BlockModel(coluna);\n@variable(model, x[T, J], Bin); # 1 if job j assigned to machine m\n@constraint(model, cov[j in J], sum(x[t,j] for t in T) == 1);\n@constraint(model, knp[t in T], sum(w[t] * x[t,j] for j in J) <= Q[t]);\n@objective(model, Min, sum(c[t,j] * x[t,j] for t in T, j in J));\nnothing #hide","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We assign jobs to a type of machine and we define one knapsack constraint for each type. This formulation cannot be solved as it stands with a commercial solver.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Then, we decompose and specify the multiplicity of each knapsack subproblem : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"@dantzig_wolfe_decomposition(model, dec_on_types, T);\nsps = getsubproblems(dec_on_types)\nfor t in T\n    specify!(sps[t], lower_multiplicity = 0, upper_multiplicity = U[t]);\nend\ngetsubproblems(dec_on_types)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We see that subproblem for machine type 1 has upper multiplicity equals to 3, and second subproblem for machine type 2 has upper multiplicity equals to 2. It means that we can use at most 3 machines of type 1 and at most 2 machines of type 2.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We can then optimize","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"optimize!(model);","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"and retrieve the disagreggated solution","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"for t in T\n    assignment_patterns = BD.getsolutions(model, t);\n    for pattern in assignment_patterns\n        nb_times_pattern_used = BD.value(pattern);\n        jobs_in_pattern = [];\n        for j in J\n            if BD.value(pattern, x[t, j]) ≈ 1\n                push!(jobs_in_pattern, j);\n            end\n        end\n        println(\"Pattern of machine type $t used $nb_times_pattern_used times : $jobs_in_pattern\");\n    end\nend","category":"page"},{"location":"man/decomposition/#Benders-(alpha)","page":"Decomposition","title":"Benders (alpha)","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following coefficient matrix that has a block diagonal structure in gray and some linking variables in blue :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Benders decomposition)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You fix the complicated variables, then you can solve the blocks independently.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"This decomposition is an alpha feature.","category":"page"},{"location":"man/decomposition/#BlockDecomposition","page":"Decomposition","title":"BlockDecomposition","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The index-set of the subproblems is declared through an BlockDecomposition.@axis.  It returns an array. Each value of the array is a subproblem index wrapped into a BlockDecomposition.AxisId. Each time BlockDecomposition finds an AxisId in the indices of a variable and a constraint, it knows to which subproblem the variable or the constraint belongs.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockDecomposition allows the user to perform two types of decomposition using BlockDecomposition.@dantzig_wolfe_decomposition and BlockDecomposition.@benders_decomposition.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The macro creates a decomposition tree where the root is the master and the depth is the number of nested decomposition. A classic Dantzig-Wolfe or Benders decomposition produces a decomposition tree of depth 1. At the moment, nested decomposition is not supported.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You can get the subproblem membership of all variables and constraints using the method BlockDecomposition.annotation.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockDecomposition does not change the JuMP model. It decorates the model with additional information. All these information are stored in the ext field of the JuMP model.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"CurrentModule = BlockDecomposition\nDocTestSetup = quote\n    using BlockDecomposition\nend","category":"page"},{"location":"man/decomposition/#Errors-and-warnings","page":"Decomposition","title":"Errors and warnings","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"MasterVarInDwSp\nVarsOfSameDwSpInMaster","category":"page"},{"location":"man/decomposition/#BlockDecomposition.MasterVarInDwSp","page":"Decomposition","title":"BlockDecomposition.MasterVarInDwSp","text":"Error thrown when a master variable is in a constraint that belongs to a Dantzig-Wolfe subproblem.\n\nYou can retrieve the JuMP variable and the JuMP constraint where the error occurs:\n\nerror.variable\nerror.constraint\n\n\n\n\n\n","category":"type"},{"location":"man/decomposition/#BlockDecomposition.VarsOfSameDwSpInMaster","page":"Decomposition","title":"BlockDecomposition.VarsOfSameDwSpInMaster","text":"Warning when a master constraint involves variables that belong to the same Dantzig-Wolfe subproblem. It means you can move the constraint in a subproblem.\n\n\n\n\n\n","category":"type"},{"location":"man/decomposition/#References","page":"Decomposition","title":"References","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockModel","category":"page"},{"location":"man/decomposition/#BlockDecomposition.BlockModel","page":"Decomposition","title":"BlockDecomposition.BlockModel","text":"BlockModel(optimizer [, direct_model = false])\n\nReturn a JuMP model which BlockDecomposition will decompose using instructions given by the user.\n\nIf you define direct_model = true, the method creates the model with JuMP.direct_model, otherwise it uses JuMP.Model.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"These are the methods to decompose a JuMP model :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"@axis\n@benders_decomposition\n@dantzig_wolfe_decomposition","category":"page"},{"location":"man/decomposition/#BlockDecomposition.@axis","page":"Decomposition","title":"BlockDecomposition.@axis","text":"@axis(name, collection)\n\nDeclare collection as an index-set of subproblems.  You can access the axis using the variable name.\n\nExamples\n\nConsider a formulation that has a decomposition which gives raise to 5 subproblems. Let {1,2,3,4,5} be the index-set of the subproblems.\n\nTo perform this decomposition with BlockDecomposition, we must declare an axis that contains the index-set of the subproblems :\n\njulia> L = 1:5\n1:5\n\njulia> @axis(K, L)\nBlockDecomposition.Axis{:K, Int64}(:K, BlockDecomposition.AxisId{:K, Int64}[1, 2, 3, 4, 5])\n\njulia> K[1]\n1\n\njulia> typeof(K[1])\nBlockDecomposition.AxisId{:K, Int64}\n\nThe elements of the axis are AxisId. You must use AxisId in the indices of the variables and the constraints that you declare otherwise BlockDecomposition assign them to the master problem.\n\n@variable(model, x[l in L]) # x[l] belongs to the master for any l ∈ L\n@variable(model, y[k in K]) # y[k], k ∈ K, belongs to subproblem k (because K is an axis)\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/#BlockDecomposition.@benders_decomposition","page":"Decomposition","title":"BlockDecomposition.@benders_decomposition","text":"@benders_decomposition(model, name, axis)\n\nRegister a Benders decomposition on the JuMP model model where the index-set of the subproblems is defined by the axis axis.\n\nCreate a variable name from which the user can access decomposition tree.\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/#BlockDecomposition.@dantzig_wolfe_decomposition","page":"Decomposition","title":"BlockDecomposition.@dantzig_wolfe_decomposition","text":"@dantzig_wolfe_decomposition(model, name, axis)\n\nRegister a Dantzig-Wolfe decomposition on the JuMP model model where the index-set of the subproblems is defined by the axis axis.\n\nCreate a variable name from which the user can access the decomposition tree.\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"These are the methods to set additional information to the decomposition (multiplcity and optimizers) :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"getmaster\ngetsubproblems\nspecify!","category":"page"},{"location":"man/decomposition/#BlockDecomposition.getmaster","page":"Decomposition","title":"BlockDecomposition.getmaster","text":"getmaster(node) -> MasterForm\n\nReturn an object that wraps the annotation that describes the master formulation of a decomposition stored at the node of the decomposition tree.\n\nThis method is not defined if the node is a leaf of the decomposition tree.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/#BlockDecomposition.getsubproblems","page":"Decomposition","title":"BlockDecomposition.getsubproblems","text":"getsubproblems(node) -> Vector{SubproblemForm}\n\nReturn a vector of objects that wrap the annotations that describe subproblem formulations of a decomposition stored at node of the decomposition tree.\n\nThis method is not defined if the node is a leaf of the decomposition tree.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/#BlockDecomposition.specify!","page":"Decomposition","title":"BlockDecomposition.specify!","text":"specify!(\n    subproblem, \n    lower_multiplicity = 1,\n    upper_multiplicity = 1,\n    solver = nothing\n)\n\nMethod that allows the user to specify additional property of the subproblems.\n\nThe multiplicity of subproblem is the number of times that the same independant block shaped by the subproblem in the coefficient matrix appears in the model. It is equivalent to the number of solutions to the subproblem that can appear in the solution  of the original problem.\n\nThe solver of the subproblem is the way the subproblem will be optimized. It can be either a function (pricing callback), an optimizer of MathOptInterface  (e.g. Gurobi.Optimizer, CPLEX.Optimizer, Glpk.Optimizer... with attributes),  or nothing. In the latter case, the solver will use a default optimizer that  should be defined in the parameters of the main solver.\n\nAdvanced usage :  The user can use several solvers to optimize a subproblem : \n\nspecify!(subproblem, solver = [Gurobi.Optimizer, my_callback, my_second_callback])\n\nColuna always uses the first solver by default. Be cautious because changes are always buffered to all solvers. So you may degrade performances if you use a lot of solvers.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"This method help you to check your decomposition :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"annotation","category":"page"},{"location":"man/decomposition/#BlockDecomposition.annotation","page":"Decomposition","title":"BlockDecomposition.annotation","text":"annotation(node)\n\nReturn the annotation that describes the master/subproblem of a given node of the decomposition tree.\n\nannotation(model, variable)\nannotation(model, constraint)\n\nReturn the subproblem to which a variable or a constraint belongs.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/start.jl\"","category":"page"},{"location":"start/start/#Column-generation-with-the-Generalized-Assignment-Problem","page":"Column generation","title":"Column generation with the Generalized Assignment Problem","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This quick start guide introduces the main features of Coluna through the example of the Generalized Assignment Problem.","category":"page"},{"location":"start/start/#Classic-model-solved-with-MIP-solver","page":"Column generation","title":"Classic model solved with MIP solver","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Consider a set of machines M and a set of jobs J. A machine m has a resource capacity Q_m . A job j assigned to a machine m has a cost c_mj and consumes w_mj resource units of the machine m. The goal is to minimize the sum of job costs while assigning each job to a machine and not exceeding the capacity of each machine.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Let x_mj equal to one if job j is assigned to machine m; 0 otherwise. The problem has the original formulation:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"beginalignedat4\ntextGAP equiv min mathrlapsum_m in Msum_j in J c_mj x_mj  \ntextst  sum_m in M x_mj = 1  quad j in J \n sum_j in J w_mj x_mj leq Q_m  quad  quad m in M  \n x_mj  in 01  m in M j in J\nendalignedat","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Let us consider the following instance.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"M = 1:3;\nJ = 1:15;\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5; 19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7; 13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2];\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91;91 81 66 63 59 81 87 90 65 55 57 68 92 91 86; 62 79 73 60 75 66 68 99 69 60 56 100 67 68 54];\nQ = [1020 1460 1530];\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"We write the model with JuMP, a domain-specific modeling language for mathematical optimization embedded in Julia. We optimize with GLPK. If you are not familiar with the JuMP package, you may want to check its documentation.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"using JuMP, GLPK;\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"A JuMP model for the original formulation is:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[m in M, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M) >= 1);\n@constraint(model, knp[m in M], sum(w[m, j] * x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M, j in J));\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"We optimize the instance and retrieve the objective value.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"optimize!(model);\nobjective_value(model)","category":"page"},{"location":"start/start/#Try-column-generation-easily-with-Coluna-and-BlockDecomposition","page":"Column generation","title":"Try column generation easily with Coluna and BlockDecomposition","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This model has a block structure: each knapsack constraint defines an independent block and the set-partitioning constraints couple these independent blocks. By applying the Dantzig-Wolfe reformulation, each knapsack constraint forms a tractable subproblem and the set-partitioning constraints are handled in a master problem.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"To write the model, you need JuMP and BlockDecomposition. The latter is an extension built on top of JuMP to model Dantzig-Wolfe and Benders decompositions. You will find more documentation about BlockDecomposition in the Decomposition & reformulation To optimize the problem, you need Coluna and a Julia package that provides a MIP solver such as GLPK.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Since we have already loaded JuMP and GLPK, we just need:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"using BlockDecomposition, Coluna;\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Next, you instantiate the solver and define the algorithm that you use to optimize the problem. In this case, the algorithm is a classic branch-and-price provided by Coluna.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default branch-cut-and-price\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In BlockDecomposition, an axis is an index set of subproblems. Let M_axis be the index set of machines; it defines an axis along which we can implement the desired decomposition.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@axis(M_axis, M);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In this example, the axis M_axis defines one knapsack subproblem for each machine. For instance, the first machine index is 1 and is of type BlockDecomposition.AxisId:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"M_axis[1]\n\ntypeof(M_axis[1])","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Jobs are not involved in the decomposition, set J of jobs thus stays as a classic range.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The model takes the form:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"model = BlockModel(coluna);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You can write BlockModel(coluna; direct_model = true) to pass names of variables and constraints to Coluna.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M_axis) >= 1);\n@constraint(model, knp[m in M_axis], sum(w[m, j] * x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M_axis, j in J));\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This is the same model as above except that we use a BlockModel instead of a Model and M_axis as the set of machines instead of M. Therefore, BlockDecomposition will know which variables and constraints are involved in subproblems because one of their indices is a BlockDecomposition.AxisId.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You then apply a Dantzig-Wolfe decomposition along M_axis:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@dantzig_wolfe_decomposition(model, decomposition, M_axis)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"where decomposition is a variable that contains information about the decomposition.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"decomposition","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Once the decomposition is defined, you can retrieve the master and the subproblems to give additional information to the solver.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"master = getmaster(decomposition)\nsubproblems = getsubproblems(decomposition)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The multiplicity of a subproblem is the number of times that the same independent block shaped by the subproblem appears in the model. This multiplicy also specifies the number of solutions to the subproblem that can appear in the solution to the original problem.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In this GAP instance, the upper multiplicity is 1 because every subproblem is different, i.e., every machine is different and used at most once.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The lower multiplicity is 0 because a machine may stay unused. The multiplicity specifications take the form:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"specify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)\ngetsubproblems(decomposition)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The model is now fully defined. To solve it, you need to call:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"optimize!(model)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You can find more information about the output of the column generation algorithm ColumnGeneration.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Finally, you can retrieve the solution to the original formulation with JuMP methods. For example, if we want to know if the job 3 is assigned to machine 1:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"value(x[1,3])","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"qa/#Question-and-Answer","page":"Q&A","title":"Question & Answer","text":"","category":"section"},{"location":"qa/#Default-algorithms-of-Coluna-do-not-beat-the-commercial-solver-I-usually-use.-Is-it-normal-?","page":"Q&A","title":"Default algorithms of Coluna do not beat the commercial solver I usually use. Is it normal ?","text":"","category":"section"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Yes it is.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Solvers such as Gurobi, Cplex ... are handy powerful black-box tools.  They can run a very efficient presolve step to simplify the formulation, automatically apply lots of valid inequalities (such as MIR or cover cuts),  choose good branching strategies, or also run heuristics. However, when your formulation reaches a certain size, commercial solvers may run for hours without finding anything. This is the point where you may want to decompose your formulation.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Coluna is a framework not a solver. It provides algorithms to try column generation on your problem very easily. Then, you can devise your own branch-cut-and-price algorithm on top of Coluna's algorithms. to scale up and hopefully beats the commercial solver.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"To start customizing Coluna for your own problem,  you can separate valid inequalities  or call your own algorithm that optimizes subproblems.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/cuts.jl\"","category":"page"},{"location":"start/cuts/#Valid-inequalities","page":"Valid inequalities","title":"Valid inequalities","text":"","category":"section"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Now let us consider a variant of the Generalized Assignment Problem in which we have to pay f[m] to use machine m.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Consider the following instance:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"J = 1:10\nM = 1:5\nc = [10.13 15.6 15.54 13.41 17.08;19.58 16.83 10.75 15.8 14.89;14.23 17.36 16.05 14.49 18.96;16.47 16.38 18.14 15.46 11.64;17.87 18.25 13.12 19.16 16.33;11.09 16.76 15.5 12.08 13.06;15.19 13.86 16.08 19.47 15.79;10.79 18.96 16.11 19.78 15.55;12.03 19.03 16.01 14.46 12.77;14.48 11.75 16.97 19.95 18.32];\nw = [5, 4, 5, 6, 8, 9, 5, 8, 10, 7];\nQ = [25,  24,  31,  28,  24];\nf = [105, 103, 109, 112, 100];\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We define the dependencies:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"using JuMP, BlockDecomposition, Coluna, GLPK;\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We parametrize the solver. We solve only the root node of the branch-and-bound tree and we use a column and cut generation algorithm to conquer (optimize) this node.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"coluna = JuMP.optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm(\n            conqueralg = Coluna.Algorithm.ColCutGenConquer(\n                max_nb_cut_rounds = 20\n            ),\n            branchingtreefile = \"tree2.dot\",\n            maxnumnodes = 1\n        )\n    ),\n    \"default_optimizer\" => GLPK.Optimizer\n);\nnothing #hide","category":"page"},{"location":"start/cuts/#Column-generation","page":"Valid inequalities","title":"Column generation","text":"","category":"section"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We write the model:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"model = BlockModel(coluna; direct_model = true);\n@axis(M_axis, M)\n@variable(model, x[j in J, m in M_axis], Bin);\n@variable(model, y[m in M_axis], Bin);\n@constraint(model, setpartitioning[j in J], sum(x[j,m] for m in M_axis) == 1);\n@constraint(model, knp[m in M_axis], sum(w[j]*x[j,m] for j in J) <= Q[m] * y[m]);\n@objective(model, Min, sum(c[j,m] * x[j,m] for m in M_axis, j in J) + sum(f[m] * y[m] for m in M_axis));\n\n@dantzig_wolfe_decomposition(model, dec, M_axis);\nsp = getsubproblems(dec);\nspecify!.(sp, lower_multiplicity = 0);\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We optimize:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"optimize!(model)","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"The final dual bound is:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"db1 = objective_bound(model)","category":"page"},{"location":"start/cuts/#Strengthen-with-valid-inequalities","page":"Valid inequalities","title":"Strengthen with valid inequalities","text":"","category":"section"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Let H be the set of configurations of open machines (h[m] = 1 if machine m open; 0 otherwise) such that all jobs can be assigned : sum(h'Q) >= sum(w) i.e. the total capacity of the open machines must exceed the total weight of the jobs.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"H = Vector{Int}[]\nfor h in digits.(1:(2^length(M) - 1), base=2, pad=length(M))\n    if sum(h'Q) >= sum(w)\n        push!(H, h)\n    end\nend\nH","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Let ȳ be the solution to the linear relaxation of the problem. Let us try to express ȳ as a linear expression of the configurations. If ȳ ∈ conv H, we can derive a cut because the optimal integer solution to the problem use one of the configuration of H.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We need MathOptInterface to define the cut callback:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"using MathOptInterface","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"The separation algorithm looks for the non-negative coefficients χ[k], k = 1:length(H),  : max sum(χ[k] for k in 1:length(H)) such that sum(χ[k]* h for (k,h) in enumerate(H)) <= ̄ȳ. If the objective value is less than 1, we must add a cut.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Since the separation algorithm is a linear program, strong dualities applies. So we seperate these cuts with the dual.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"fc_sep_m = Model(GLPK.Optimizer)\n@variable(fc_sep_m, ψ[m in M] >= 0) # one variable for each constraint\n@constraint(fc_sep_m, config_dual[h in H], ψ'h >= 1) # one constraint for each χ[k]\nMathOptInterface.set(fc_sep_m, MathOptInterface.Silent(), true)","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"The objective is min ȳ'ψ = sum(χ[k] for k in 1:length(H)). Let ψ* be an optimal solution to the dual. If ȳ'ψ* < 1, then ψ*'y >= 1 is a valid inequality.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"function fenchel_cuts_separation(cbdata)\n    println(\"Fenchel cuts separation callback...\")\n    ȳ = [callback_value(cbdata, y[m]) for m in M_axis]\n    @objective(fc_sep_m, Min, ȳ'ψ) # update objective\n    optimize!(fc_sep_m)\n    if objective_value(fc_sep_m) < 1\n        con = @build_constraint(value.(ψ)'y >= 1) # valid inequality.\n        MathOptInterface.submit(model, MathOptInterface.UserCut(cbdata), con)\n    end\nend\n\nMathOptInterface.set(model, MathOptInterface.UserCutCallback(), fenchel_cuts_separation);\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We optimize:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"optimize!(model)","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Valid inequalities significantly improve the previous dual bound:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"db2 = objective_bound(model)\n\n\ndb1","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/config/#Coluna-Configuration","page":"Configuration","title":"Coluna Configuration","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#Raw-Parameters","page":"Configuration","title":"Raw Parameters","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#params","page":"Configuration","title":"params","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = Coluna\nDocTestSetup = quote\n    using Coluna\nend","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"Params","category":"page"},{"location":"man/config/#Coluna.Params","page":"Configuration","title":"Coluna.Params","text":"Coluna.Params(\n    solver = Coluna.Algorithm.TreeSearchAlgorithm(),\n    global_art_var_cost = 10e6,\n    local_art_var_cost = 10e4\n)\n\nParameters of Coluna :\n\nsolver is the algorithm used to optimize the reformulation.\nglobal_art_var_cost is the cost of the global artificial variables in the master\nlocal_art_var_cost is the cost of the local artificial variables in the master\n\n\n\n\n\n","category":"type"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/config/#default_optimizer","page":"Configuration","title":"default_optimizer","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#Other-Supported-Parameters","page":"Configuration","title":"Other Supported Parameters","text":"","category":"section"},{"location":"man/config/#From-BlockDecomposition","page":"Configuration","title":"From BlockDecomposition","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = BlockDecomposition\nDocTestSetup = quote\n    using BlockDecomposition\nend","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"objectiveprimalbound!\nobjectivedualbound!","category":"page"},{"location":"man/config/#BlockDecomposition.objectiveprimalbound!","page":"Configuration","title":"BlockDecomposition.objectiveprimalbound!","text":"objectiveprimalbound!(model, pb)\n\nDefine a primal bound on the optimal objective value  (upper bound for a minimisation, lower bound for a maximisation).\n\n\n\n\n\n","category":"function"},{"location":"man/config/#BlockDecomposition.objectivedualbound!","page":"Configuration","title":"BlockDecomposition.objectivedualbound!","text":"objectivedualbound!(model, db)\n\nDefine a dual bound on the optimal objective value. (lower bound for a minimisation, upper bound for a maximisation)\n\n\n\n\n\n","category":"function"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/config/#From-MathOptInterface","page":"Configuration","title":"From MathOptInterface","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/api/treesearch.jl\"","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"api/treesearch/#Tree-search-API","page":"Tree Search","title":"Tree search API","text":"","category":"section"},{"location":"api/treesearch/#Introduction","page":"Tree Search","title":"Introduction","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"This is a test (and also a tutorial) on how to use the tree search interface together with algorithms.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We define the dependencies:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"using Coluna, Parameters;\nnothing #hide","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"and some shortcuts for the sake of brievity:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"const ClA = Coluna.Algorithm;\nconst ClB = Coluna.ColunaBase;\nnothing #hide","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We consider a minimization problem with four binary variables. Costs of the variable are [-1, 1, 1, 1]. The problem has no additional constraints. Therefore, the optimal solution is [1, 0, 0, 0].","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Let's define a data structure that will maintain the formulation of the problem. Vector var_costs contains the costs of the variables. Vector var_domains contains the lower and upper bounds (in a tuple) of the variables.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"const NB_VARIABLES_ = 4\n\nstruct Formulation <: ClB.AbstractModel\n    var_costs::Vector{Int}\n    var_domains::Vector{Tuple{Int,Int}}\n    Formulation() = new([-1, 1, 1, 1], fill((0,1), NB_VARIABLES_))\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We are going to enumerate all possible values for the two first variables using a binary tree :","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"depth 0: branch on first variable\ndepth 1: branch on second variable","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"When the two first variables are fixed, we dive to fix the third and the fourth variables to zero.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"At the end, the tree will look like:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"<div class=\"mermaid\">\n graph TD\n   A0(root node) -->|x1 >= 1| A1\n \t A0 -->|x1 <= 0| B1\n\t A1 -->|x2 <= 0| A2\n\t A1 -->|x2 >= 1| B2\n\t B1 -->|x2 <= 0| C2\n\t B1 -->|x2 >= 1| D2\n\t A2 -->|x3 == 0| A3\n\t B2 -->|x3 == 0| B3\n\t C2 -->|x3 == 0| C3\n\t D2 -->|x3 == 0| D3\n\t A3 -->|x4 == 0| A4\n\t B3 -->|x4 == 0| B4\n\t C3 -->|x4 == 0| C4\n\t D3 -->|x4 == 0| D4\n\t style A3 stroke:red\n\t style A4 stroke:red\n\t style B3 stroke:red\n\t style B4 stroke:red\n\t style C3 stroke:red\n\t style C4 stroke:red\n\t style D3 stroke:red\n\t style D4 stroke:red\n</div>","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"The nodes in blue are explored by a binary tree algorithm. The nodes in red are explored by a diving algorithm.","category":"page"},{"location":"api/treesearch/#Implementing-tree-search-data-structures","page":"Tree Search","title":"Implementing tree search data structures","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Now, we define the two concepts we'll use in the tree search algorithms: the node and the search space. The third concept is the explore strategy and implemented in Coluna.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We start by defining the node. Take a look at the API section to see the list of methods you need to implement.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"struct Node <: ClA.AbstractNode\n    depth::Int\n    solution::Vector{Float64}\n    var_lbs::Vector{Int}\n    var_ubs::Vector{Int}\n    parent::Union{Nothing, Node}\n\n    # The constructor just build the solution.\n    function Node(\n        parent::Union{Nothing, Node} = nothing,\n        var_index::Union{Nothing,Int} = nothing,\n        var_value::Union{Nothing,Real} = 0\n    )\n        @assert isnothing(var_index) || 1 <= var_index <= NB_VARIABLES_\n        depth = isnothing(parent) ? 0 : parent.depth + 1\n        # Store the solution at this node.\n        solution = if isnothing(parent)\n            fill(0.5, NB_VARIABLES_)\n        else\n            sol = copy(parent.solution)\n            if !isnothing(var_index)\n                sol[var_index] = var_value\n            end\n            sol\n        end\n        # Store the state of the formulation.\n        var_lbs = map(var_val -> var_val == 0.5 ? 0 : var_val, solution)\n        var_ubs = map(var_val -> var_val == 0.5 ? 1 : var_val, solution)\n        return new(\n            depth,\n            solution,\n            var_lbs,\n            var_ubs,\n            parent\n        )\n    end\nend\n\nClA.root(node::Node) = isnothing(node.parent) ? node : ClA.root(node.parent)\nClA.parent(node::Node) = node.parent","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Then, we define the search spaces. Take a look at the API section to see the list of methods you need to implement.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"const LOG_ = true;\nnothing #hide","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Every tree search algorithm must be associated to a search space.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"So here, we'll implement two search spaces. One for the binary tree and another for the diving.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Let's start with the search space of the binary tree algorithm.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"mutable struct BtSearchSpace <: ClA.AbstractColunaSearchSpace\n    formulation::Formulation\n    cost_of_best_solution::Float64\n    conquer_alg\n    divide_alg\n    previous::Union{Node,Nothing}\n    BtSearchSpace(form, conquer, divide) = new(form, Inf, conquer, divide, nothing)\nend\n\nClA.get_reformulation(sp::BtSearchSpace) = sp.formulation\nClA.get_conquer(sp::BtSearchSpace) = sp.conquer_alg\nClA.get_divide(sp::BtSearchSpace) = sp.divide_alg\nClA.get_previous(sp::BtSearchSpace) = sp.previous\nClA.set_previous!(sp::BtSearchSpace, previous) = sp.previous = previous\nClA.stop(sp::BtSearchSpace) = false","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Then, we implement the search space of the diving.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"mutable struct DivingSearchSpace <: ClA.AbstractColunaSearchSpace\n    formulation::Formulation\n    starting_node_in_bt::ClA.AbstractNode # change node\n    cost_of_best_solution::Float64\n    conquer_alg\n    divide_alg\n    previous\n    DivingSearchSpace(form, node, conquer, divide) = new(form, node, Inf, conquer, divide, nothing)\nend\n\nClA.get_reformulation(sp::DivingSearchSpace) = sp.formulation\nClA.get_conquer(sp::DivingSearchSpace) = sp.conquer_alg\nClA.get_divide(sp::DivingSearchSpace) = sp.divide_alg\nClA.get_previous(sp::DivingSearchSpace) = sp.previous\nClA.set_previous!(sp::DivingSearchSpace, previous) = sp.previous = previous\nClA.stop(sp::DivingSearchSpace) = false","category":"page"},{"location":"api/treesearch/#Writing-algorithms","page":"Tree Search","title":"Writing algorithms","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Let's define the algorithm that we will use.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"At each node, we define an algorithm ComputeSolCost that compute the cost of the solution and returns its value.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct ComputeSolCost <: ClA.AbstractAlgorithm\n    log::String = \"compute solution cost\"\nend\n\nstruct ComputeSolCostInput\n    current_node::Node\nend\n\nfunction ClA.run!(algo::ComputeSolCost, env, model::Formulation, input::ComputeSolCostInput)\n    LOG_ && println(\"== $(algo.log) ==\")\n    LOG_ && @show model.var_domains\n    sol_cost = 0.0\n    for (cost, (ub, lb)) in Iterators.zip(model.var_costs, model.var_domains)\n        var_val = ub == lb ? ub : 0.5\n        sol_cost += var_val * cost\n    end\n    return sol_cost\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"To generate, the children, we create an algorithm named Divide that will create, for a given variable x, both branches x <= 0 & x >= 1 or only branch x = 0 depending on parameters chosen.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct Divide <: ClA.AbstractAlgorithm\n    log::String = \"classic divide\"\n    create_both_branches::Bool = true\nend\n\nstruct DivideInput\n    current_node::Node\nend\n\nfunction ClA.run!(algo::Divide, env, ::Formulation, input::DivideInput)\n    LOG_ && println(algo.log)\n    parent = input.current_node\n    if algo.create_both_branches && parent.depth < 2\n        var_pos_to_branch_in = parent.depth + 1\n        var_pos_to_branch_in > 4 && return []\n        LOG_ && println(\"** branch on x$(var_pos_to_branch_in) == 0 & x$(var_pos_to_branch_in) == 1\")\n        return [(var_pos_to_branch_in, 0), (var_pos_to_branch_in, 1)]\n    elseif !algo.create_both_branches\n        var_pos_to_branch_in = parent.depth\n        var_pos_to_branch_in > 4 && return []\n        LOG_ && println(\"** branch on x$(var_pos_to_branch_in) == 0\")\n        return [(var_pos_to_branch_in, 0)]\n    end\n    return []\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"The diving is a tree search algorithm that uses:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ComputeSolCost as conquer strategy\nDivide with parameter create_both_branches equals to false as divide strategy\nColuna.Algorithm.DepthFirstStrategy as explore strategy","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct Diving <: ClA.AbstractAlgorithm\n    conqueralg = ComputeSolCost(log=\"compute solution cost of Diving tree\")\n    dividealg = Divide(\n        log = \"divide for diving\",\n        create_both_branches = false\n    )\n    explore = ClA.DepthFirstStrategy()\nend\n\nstruct DivingInput\n    starting_node_in_parent_algorithm\nend\n\nfunction ClA.run!(algo::Diving, env, model::Formulation, input::DivingInput)\n    LOG_ && println(\"~~~~~~~~ Diving starts ~~~~~~~~\")\n    diving_space = ClA.new_space(ClA.search_space_type(algo), algo, model, input)\n    output = ClA.tree_search(algo.explore, diving_space, env, input)\n    LOG_ && println(\"~~~~~~~~ end of Diving ~~~~~~~~\")\n    return output\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We define the algorithm that will conquer each node of the binary tree algorithm. It runs the ComputeSolCost algorithm and then the diving algorithm if the two first variables have been fixed (i.e. if depth == 2).","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct BtConquer <: ClA.AbstractAlgorithm\n    compute = ComputeSolCost(log = \"compute solution cost for Binary tree\")\n    heuristic = Diving()\nend\n\nfunction ClA.run!(algo::BtConquer, env, model, input)\n    output = ClA.run!(algo.compute, env, model, input)\n    diving_output = Inf\n    if input.current_node.depth == 2\n        diving_input = DivingInput(input.current_node) # TODO: needs an interface or specific to the algorithm ?\n        diving_output = ClA.run!(algo.heuristic, env, model, diving_input)\n    end\n    return min(output, diving_output)\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"The binary tree algorithm is a tree search algorithm that uses:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"BtConquer as conquer strategy\nDivide with parameter create_both_branches equals to false as divide strategy\nColuna.Algorithm.DepthFirstStrategy as explore strategy","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct BinaryTree <: ClA.AbstractAlgorithm\n    conqueralg = BtConquer()\n    dividealg = Divide()\n    explore = ClA.DepthFirstStrategy()\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Look at how we call the generic tree search implementation.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"function ClA.run!(algo::BinaryTree, env, reform, input)\n    search_space = ClA.new_space(ClA.search_space_type(algo), algo, reform, input)\n    return ClA.tree_search(algo.explore, search_space, env, input)\nend","category":"page"},{"location":"api/treesearch/#Implementing-tree-search-interface","page":"Tree Search","title":"Implementing tree search interface","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"First, we indicate the type of search space used by our algorithms. Note that the type of the search space can depends on the configuration of the algorithm. So there is a 1-to-n relation between tree search algorithm configurations and search space. because one search space can be used by several tree search algorithms configuration.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.search_space_type(::BinaryTree) = BtSearchSpace\nClA.search_space_type(::Diving) = DivingSearchSpace","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Now, we implement the method that calls the constructor of a search space. The type of the search space is known from above method. A search space may receive information from the tree-search algorithm. The model, and input arguments are the same than those received by the tree search algorithm.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.new_space(::Type{BtSearchSpace}, alg, model, input) =\n    BtSearchSpace(model, alg.conqueralg, alg.dividealg)\nClA.new_space(::Type{DivingSearchSpace}, alg, model, input) =\n    DivingSearchSpace(model, input.starting_node_in_parent_algorithm, alg.conqueralg, alg.dividealg)","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We implement the method that returns the root node. The definition of the root node depends on the search space.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.new_root(::BtSearchSpace, input) = Node()\nClA.new_root(space::DivingSearchSpace, input) =\n    Node(space.starting_node_in_bt)","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Then, we implement the method that converts the branching rules into nodes for the tree search algorithm.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"function ClA.new_children(::ClA.AbstractColunaSearchSpace, branches, node::Node)\n    children = Node[]\n    for (var_pos, var_val_fixed) in branches\n        child = Node(node, var_pos, var_val_fixed)\n        push!(children, child)\n    end\n    return children\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We implement the node_change method to update the search space called by the tree search algorithm just after it finishes to evaluate a node and chooses the next one. Be careful, this method is not called after the evaluation of a node when there is no more unevaluated nodes (i.e. tree exploration is finished).","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"There are two ways to store the state of a formulation at a given node. We can distribute information across the nodes or store the whole state at each node. We follow the second way (so we don't need previous).","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"function ClA.node_change!(::Node, next::Node, space::ClA.AbstractColunaSearchSpace, _)\n    for (var_pos, bounds) in enumerate(Iterators.zip(next.var_lbs, next.var_ubs))\n       space.formulation.var_domains[var_pos] = bounds\n    end\n    return\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Method after_conquer is a callback to do some operations after the conquer of a node and before the divide. Here, we update the best solution found after the conquer algorithm. We implement one method for each search space.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"function ClA.after_conquer!(space::BtSearchSpace, current, output)\n    if output < space.cost_of_best_solution\n        space.cost_of_best_solution = output\n    end\n    return\nend\n\nfunction ClA.after_conquer!(space::DivingSearchSpace, current, output)\n    if output < space.cost_of_best_solution\n        space.cost_of_best_solution = output\n    end\n    return\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We implement getters to retrieve the input from the search space and the node. The input is passed to the conquer and the divide algorithms.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.get_input(::BtConquer, space::BtSearchSpace, node::Node) =\n    ComputeSolCostInput(node)\nClA.get_input(::Divide, space::BtSearchSpace, node::Node) =\n    DivideInput(node)\nClA.get_input(::ComputeSolCost, space::DivingSearchSpace, node::Node) =\n    ComputeSolCostInput(node)\nClA.get_input(::Divide, space::DivingSearchSpace, node::Node) =\n    DivideInput(node)","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"At last, we implement methods that will return the output of the tree search algorithms. We return the cost of the best solution found. We write one method for each search space.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.tree_search_output(space::BtSearchSpace, _) = space.cost_of_best_solution\nClA.tree_search_output(space::DivingSearchSpace, _) = space.cost_of_best_solution","category":"page"},{"location":"api/treesearch/#Run-the-example","page":"Tree Search","title":"Run the example","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We run our tree search algorithm:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"env = nothing\nmodel = Formulation()\ninput = nothing\n\noutput = ClA.run!(BinaryTree(), env, model, input)\n@show output","category":"page"},{"location":"api/treesearch/#API","page":"Tree Search","title":"API","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"api/treesearch/#Search-space","page":"Tree Search","title":"Search space","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"AbstractSearchSpace\nsearch_space_type\nnew_space","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractSearchSpace","page":"Tree Search","title":"Coluna.Algorithm.AbstractSearchSpace","text":"Contains the definition of the problem tackled by the tree search algorithm and how the nodes and transitions of the tree search space will be explored.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.Algorithm.search_space_type","page":"Tree Search","title":"Coluna.Algorithm.search_space_type","text":"Returns the type of search space depending on the tree-search algorithm and its parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.new_space","page":"Tree Search","title":"Coluna.Algorithm.new_space","text":"Creates and returns the search space of a tree search algorithm, its model, and its input.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Node","page":"Tree Search","title":"Node","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"AbstractNode\nnew_root\nroot\nparent\npriority","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractNode","page":"Tree Search","title":"Coluna.Algorithm.AbstractNode","text":"A subspace obtained by successive divisions of the search space.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.Algorithm.new_root","page":"Tree Search","title":"Coluna.Algorithm.new_root","text":"Creates and returns the root node of a search space.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.root","page":"Tree Search","title":"Coluna.Algorithm.root","text":"Returns the root node of the tree to which the node belongs.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.parent","page":"Tree Search","title":"Coluna.Algorithm.parent","text":"Returns the parent of a node; nothing if the node is the root.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.priority","page":"Tree Search","title":"Coluna.Algorithm.priority","text":"Returns the priority of the node depending on the explore strategy.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Tree-search-algorithm","page":"Tree Search","title":"Tree search algorithm","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"AbstractExploreStrategy\ntree_search\nchildren\nstop\ntree_search_output","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractExploreStrategy","page":"Tree Search","title":"Coluna.Algorithm.AbstractExploreStrategy","text":"Algorithm that chooses next node to evaluated in the tree search algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.Algorithm.tree_search","page":"Tree Search","title":"Coluna.Algorithm.tree_search","text":"Generic implementation of the tree search algorithm for a given explore strategy.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.children","page":"Tree Search","title":"Coluna.Algorithm.children","text":"Evaluate and generate children. This method has a specific implementation for Coluna.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.stop","page":"Tree Search","title":"Coluna.Algorithm.stop","text":"Returns true if stopping criteria are met; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.tree_search_output","page":"Tree Search","title":"Coluna.Algorithm.tree_search_output","text":"Returns the output of the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Tree-search-algorithm-for-Coluna","page":"Tree Search","title":"Tree search algorithm for Coluna","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"AbstractColunaSearchSpace","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractColunaSearchSpace","page":"Tree Search","title":"Coluna.Algorithm.AbstractColunaSearchSpace","text":"Search space for tree search algorithms in Coluna.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"The children method has a specific implementation for AbstractColunaSearchSpace` that involves following methods:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"get_previous\nset_previous!\nnode_change!\nget_divide\nget_reformulation\nget_input\nafter_conquer!\nnew_children","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.get_previous","page":"Tree Search","title":"Coluna.Algorithm.get_previous","text":"Returns the previous node explored by the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.set_previous!","page":"Tree Search","title":"Coluna.Algorithm.set_previous!","text":"Sets the previous node explored by the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.node_change!","page":"Tree Search","title":"Coluna.Algorithm.node_change!","text":"Methods to perform operations before the tree search algorithm evaluates a node (current). This is useful to restore the state of the formulation for instance.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_divide","page":"Tree Search","title":"Coluna.Algorithm.get_divide","text":"Returns the divide algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_reformulation","page":"Tree Search","title":"Coluna.Algorithm.get_reformulation","text":"Returns the reformulation that will be passed to an algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_input","page":"Tree Search","title":"Coluna.Algorithm.get_input","text":"Returns the input that will be passed to an algorithm. The input can be built from information contained in a search space and a node.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.after_conquer!","page":"Tree Search","title":"Coluna.Algorithm.after_conquer!","text":"Methods to perform operations after the conquer algorithms. It receives the output of the conquer algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.new_children","page":"Tree Search","title":"Coluna.Algorithm.new_children","text":"Creates and returns the children of a node associated to a search space.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/pricing.jl\"","category":"page"},{"location":"start/pricing/#Pricing-callback","page":"Pricing callback","title":"Pricing callback","text":"","category":"section"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback let you define how to solve the subproblems of a Dantzig-Wolfe decomposition to generate a new entering column in the master program. This callback is useful when you know an efficient algorithm to solve the subproblems, i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"First, we load the packages and define aliases :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"using Coluna, BlockDecomposition, JuMP, MathOptInterface, GLPK;\nconst BD = BlockDecomposition;\nconst MOI = MathOptInterface;\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"Let us see an example with the following generalized assignment problem :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"M = 1:3;\nJ = 1:15;\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5; 19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7; 13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2];\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91;91 81 66 63 59 81 87 90 65 55 57 68 92 91 86; 62 79 73 60 75 66 68 99 69 60 56 100 67 68 54];\nQ = [1020 1460 1530];\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"with the following Coluna configuration","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"for which the JuMP model takes the form:","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"model = BlockModel(coluna);\n\n@axis(M_axis, M);\n\n@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m,j] for m in M_axis) == 1);\n@objective(model, Min, sum(c[m,j]*x[m,j] for m in M_axis, j in J));\n@dantzig_wolfe_decomposition(model, dwdec, M_axis);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"where, as you can see, we omitted the knapsack constraints. These constraints are implicitly defined by the algorithm called in the pricing callback.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"Let's use a knapsack algorithm defined by the following function to solve the knapsack subproblems:","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"function solve_knapsack(cost, weight, capacity)\n    sp_model = Model(GLPK.Optimizer)\n    items = 1:length(weight)\n    @variable(sp_model, x[i in items], Bin)\n    @constraint(sp_model, weight' * x <= capacity)\n    @objective(sp_model, Min, cost' * x)\n    optimize!(sp_model)\n    x_val = value.(x)\n    return filter(i -> x_val[i] ≈ 1, collect(items))\nend","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"You can replace the content of the function by any algorithm that solves the knapsack problem (such as algorithms provided by the unregistered package Knapsacks).","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with Coluna within the pricing callback.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"function my_pricing_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M_axis)\n    cur_machine = BD.callback_spid(cbdata, model)\n\n    # Uncomment to see that the pricing callback is called.\n    # println(\"Pricing callback for machine $(cur_machine).\")\n\n    # Retrieve reduced costs of subproblem variables\n    red_costs = [BD.callback_reduced_cost(cbdata, x[cur_machine, j]) for j in J]\n\n    # Run the knapsack algorithm\n    jobs_assigned_to_cur_machine = solve_knapsack(red_costs, w[cur_machine, :], Q[cur_machine])\n\n    # Create the solution (send only variables with non-zero values)\n    sol_vars = [x[cur_machine, j] for j in jobs_assigned_to_cur_machine]\n    sol_vals = [1.0 for _ in jobs_assigned_to_cur_machine]\n    sol_cost = sum(red_costs[j] for j in jobs_assigned_to_cur_machine)\n\n    # Submit the solution to the subproblem to Coluna\n    MOI.submit(model, BD.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)\n\n    # Submit the dual bound to the solution of the subproblem\n    # This bound is used to compute the contribution of the subproblem to the lagrangian\n    # bound in column generation.\n    MOI.submit(model, BD.PricingDualBound(cbdata), sol_cost) # optimal solution\n    return\nend","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback is provided to Coluna using the keyword solver in the method specify!.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"subproblems = BD.getsubproblems(dwdec);\nBD.specify!.(subproblems, lower_multiplicity = 0, solver = my_pricing_callback);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"You can then optimize :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"optimize!(model);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"and retrieve information you need as usual :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"objective_value(model)","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/initial_columns.jl\"","category":"page"},{"location":"start/initial_columns/#Initial-columns","page":"Initial columns callback","title":"Initial columns","text":"","category":"section"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"The initial columns callback let you provide initial columns associated to each problem ahead the optimization. This callback is useful when you have an efficient heuristic that finds feasible solutions to the problem. You can then extract columns from the solutions and give them to Coluna through the callback. You have to make sure the columns you provide are feasible because Coluna won't check their feasibility. The cost of the columns will be computed using the perennial cost of subproblem variables.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"Let us see an example with the following generalized assignment problem :","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"M = 1:3;\nJ = 1:5;\nc = [1 1 1 1 1; 1.2 1.2 1.1 1.1 1; 1.3 1.3 1.1 1.2 1.4];\nQ = [3, 2, 3];\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"with the following Coluna configuration","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"using JuMP, GLPK, BlockDecomposition, Coluna;\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default branch-cut-and-price\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"for which the JuMP model takes the form:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"@axis(M_axis, M);\nmodel = BlockModel(coluna);\n\n@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M_axis) >= 1);\n@constraint(model, knp[m in M_axis], sum(x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M_axis, j in J));\n\n@dantzig_wolfe_decomposition(model, decomposition, M_axis)\n\nsubproblems = getsubproblems(decomposition)\nspecify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"Let's consider that the following assignement patterns are good candidates:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"machine1 = [[1,2,4], [1,3,4], [2,3,4], [2,3,5]];\nmachine2 = [[1,2], [1,5], [2,5], [3,4]];\nmachine3 = [[1,2,3], [1,3,4], [1,3,5], [2,3,4]];\n\ninitial_columns = [machine1, machine2, machine3];\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"We can write the initial columns callback:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"function initial_columns_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M_axis)\n    spid = BlockDecomposition.callback_spid(cbdata, model)\n    println(\"initial columns callback $spid\")\n\n    # Retrieve assignment patterns of a given machine\n    for col in initial_columns[spid]\n        # Create the column in the good representation\n        vars = [x[spid, j] for j in col]\n        vals = [1.0 for _ in col]\n\n        # Submit the column\n        MOI.submit(model, BlockDecomposition.InitialColumn(cbdata), vars, vals)\n    end\nend","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"The initial columns callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with Coluna within the callback.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"We provide the initial columns callback to Coluna through the following method:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"MOI.set(model, BlockDecomposition.InitialColumnsCallback(), initial_columns_callback)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"You can then optimize:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"optimize!(model)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callbacks are functions defined by the user that allow him to take over part of the default algorithm. The more classical callbacks in a branch-and-price solver are:","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Pricing callback that takes over the procedure to determine whether the current master LP   solution is optimum or produces an entering variable with negative reduced cost by solving subproblems\nSeparation callback that takes over the procedure to determine whether the current master   LP solution is feasible or produces a valid problem constraint that is violated\nBranching callback that takes over the procedure to determine whether the current master   LP solution is integer or produces a valid branching disjunctive constraint that rules out   the current fractional solution.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"note: Note\nYou can't change the original formulation in a callback because Coluna does not propagate the changes into the reformulation and does not check if solutions found are still feasible.","category":"page"},{"location":"man/callbacks/#Pricing-callback","page":"Callbacks","title":"Pricing callback","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"The pricing callback let you define how to solve the subproblems of a Dantzig-Wolfe decomposition to generate a new entering column in the master program. This callback is useful when you know an efficient algorithm to solve the subproblems, i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"See the example in the manual Pricing callback.","category":"page"},{"location":"man/callbacks/#Errors-and-Warnings","page":"Callbacks","title":"Errors and Warnings","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Algorithm.IncorrectPricingDualBound\nAlgorithm.MissingPricingDualBound\nAlgorithm.MultiplePricingDualBounds","category":"page"},{"location":"man/callbacks/#Coluna.Algorithm.IncorrectPricingDualBound","page":"Callbacks","title":"Coluna.Algorithm.IncorrectPricingDualBound","text":"IncorrectPricingDualBound\n\nError thrown when transmitting a dual bound larger than the primal bound of the  best solution to the pricing subproblem found in a run of the pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/#Coluna.Algorithm.MissingPricingDualBound","page":"Callbacks","title":"Coluna.Algorithm.MissingPricingDualBound","text":"MissingPricingDualBound\n\nError thrown when the pricing callback does not transmit any dual bound. Make sure you call MOI.submit(model, BD.PricingDualBound(cbdata), db) in your pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/#Coluna.Algorithm.MultiplePricingDualBounds","page":"Callbacks","title":"Coluna.Algorithm.MultiplePricingDualBounds","text":"MultiplePricingDualBounds\n\nError thrown when the pricing transmits multiple dual bound. Make sure you call MOI.submit(model, BD.PricingDualBound(cbdata), db) only once in your  pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/callbacks/#Separation-callbacks","page":"Callbacks","title":"Separation callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Separation callbacks let you define how to separate cuts or constraints.","category":"page"},{"location":"man/callbacks/#Facultative-and-essential-cuts-(user-cut-and-lazy-constraint)","page":"Callbacks","title":"Facultative & essential cuts (user cut & lazy constraint)","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"This callback allows you to add cuts to the master problem. The cuts must be expressed in terms of the original variables. Then, Coluna expresses them over the master variables. You can find an example of essential cut separation and facultative cut separation in the JuMP documentation.","category":"page"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"man/algorithm/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"TODO : Description of how algorithms work.","category":"page"},{"location":"man/algorithm/#Tree-search-algorithm-(branch-and-bound)","page":"Algorithms","title":"Tree search algorithm (branch-and-bound)","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"TreeSearchAlgorithm","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.TreeSearchAlgorithm","page":"Algorithms","title":"Coluna.Algorithm.TreeSearchAlgorithm","text":"Coluna.Algorithm.TreeSearchAlgorithm(\n    conqueralg::AbstractConquerAlgorithm = ColCutGenConquer(),\n    dividealg::AbstractDivideAlgorithm = SimpleBranching(),\n    explorestrategy::AbstractExploreStrategy = DepthFirstStrategy(),\n    maxnumnodes::Int = 100000,\n    opennodeslimit::Int = 100,\n    opt_atol::Float64 = DEF_OPTIMALITY_ATOL,\n    opt_rtol::Float64 = DEF_OPTIMALITY_RTOL,\n    branchingtreefile = nothing\n)\n\nThis algorithm is a branch and bound that uses a search tree to optimize the reformulation. At each node in the tree, it applies conqueralg to improve the bounds,  dividealg to generate child nodes, and explorestrategy to select the next node to treat.\n\nParameters : \n\nmaxnumnodes : maximum number of nodes explored by the algorithm\nopennodeslimit : maximum number of nodes waiting to be explored\nopt_atol : optimality absolute tolerance (alpha)\nopt_rtol : optimality relative tolerance (alpha)\n\nOptions :\n\nbranchingtreefile : name of the file in which the algorithm writes an overview of the branching tree\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Conquer-algorithm","page":"Algorithms","title":"Conquer algorithm","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"ColCutGenConquer","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.ColCutGenConquer","page":"Algorithms","title":"Coluna.Algorithm.ColCutGenConquer","text":"Coluna.Algorithm.ColCutGenConquer(\n    stages = ColumnGeneration[ColumnGeneration()],\n    primal_heuristics = ParameterisedHeuristic[ParamRestrictedMasterHeuristic()],\n    cutgen = CutCallbacks(),\n    max_nb_cut_rounds = 3\n)\n\nColumn-and-cut-generation based algorithm to find primal and dual bounds for a  problem decomposed using Dantzig-Wolfe paradigm.\n\nThis algorithm applies a set of column generation algorithms whose definitions are stored in stages. These algorithms are called in the reverse order of vector stages. So usually, the first stage is the one with exact pricing, and other stages use heuristic pricing (the higher is the position of the stage,  the faster is the heuristic). \n\nThis algorithm also applies cutgen for the cut generation phase. It can apply several primal heuristics stored in primal_heuristics to more efficiently find feasible solutions.\n\nParameters :\n\nstages: column generation algorithms from the exact one to the most heuristic one\nprimal_heuristics: heuristics to find a feasible solution\ncutgen: cut generation algorithm\nmax_nb_cut_rounds : number of cut generation done by the algorithm\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"ColumnGeneration","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.ColumnGeneration","page":"Algorithms","title":"Coluna.Algorithm.ColumnGeneration","text":"Coluna.Algorithm.ColumnGeneration(\n    restr_master_solve_alg = SolveLpForm(get_dual_solution = true),\n    pricing_prob_solve_alg = SolveIpForm(\n        moi_params = MoiOptimize(\n            deactivate_artificial_vars = false,\n            enforce_integrality = false\n        )\n    ),\n    essential_cut_gen_alg = CutCallbacks(call_robust_facultative = false),\n    max_nb_iterations = 1000,\n    log_print_frequency = 1,\n    redcost_tol = 1e-5,\n    cleanup_threshold = 10000,\n    cleanup_ratio = 0.66,\n    smoothing_stabilization = 0.0 # should be in [0, 1],\n)\n\nColumn generation algorithm that can be applied to formulation reformulated using Dantzig-Wolfe decomposition. \n\nThis algorithm first solves the linear relaxation of the master (master LP) using restr_master_solve_alg. Then, it solves the subproblems by calling pricing_prob_solve_alg to get the columns that have the best reduced costs and that hence, may improve the master LP's objective the most.\n\nIn order for the algorithm to converge towards the optimal solution of the master LP, it suffices that the pricing oracle returns, at each iteration, a negative reduced cost solution if one exists.  The algorithm stops when all subproblems fail to generate a column with negative (positive) reduced cost in the case of a minimization (maximization) problem or when it reaches the maximum number of iterations.\n\nParameters : \n\nrestr_master_solve_alg: algorithm to optimize the master LP\npricing_prob_solve_alg: algorithm to optimize the subproblems\nessential_cut_gen_alg: algorithm to generate essential cuts which is run when the solution of the master LP is integer.\n\nOptions:\n\nmax_nb_iterations: maximum number of iterations\nlog_print_frequency: display frequency of iterations statistics\n\nUndocumented parameters are in alpha version.\n\nAbout the ouput\n\nAt each iteration (depending on log_print_frequency),  the column generation algorithm can display following statistics.\n\n<it= 90> <et=15.62> <mst= 0.02> <sp= 0.05> <cols= 4> <al= 0.00> <DB=  300.2921> <mlp=  310.3000> <PB=310.3000>\n\nHere are their meanings :\n\nit stands for the current number of iterations of the algorithm\net is the elapsed time in seconds since Coluna has started the optimisation\nmst is the time in seconds spent solving the master LP at the current iteration\nsp is the time in seconds spent solving the subproblems at the current iteration\ncols is the number of column generated by the subproblems at the current iteration\nal is the smoothing factor of the stabilisation at the current iteration (alpha version)\nDB is the dual bound of the master LP at the current iteration\nmlp is the objective value of the master LP at the current iteration\nPB is the objective value of the best primal solution found by Coluna at the current iteration\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Basic-algorithms","page":"Algorithms","title":"Basic algorithms","text":"","category":"section"},{"location":"man/algorithm/#Optimize-a-linear-program","page":"Algorithms","title":"Optimize a linear program","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"SolveLpForm","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.SolveLpForm","page":"Algorithms","title":"Coluna.Algorithm.SolveLpForm","text":"Coluna.Algorithm.SolveLpForm(\n    get_dual_solution = false,\n    relax_integrality = false,\n    get_dual_bound = false,\n    silent = true\n)\n\nSolve a linear program stored in a formulation using its first optimizer. This algorithm works only if the optimizer is interfaced with MathOptInterface.\n\nYou can define the optimizer using the default_optimizer attribute of Coluna or with the method specify! from BlockDecomposition\n\nParameters:\n\nget_dual_solution: retrieve the dual solution and store it in the ouput if equals true\nrelax_integrality: relax integer variables of the formulation before optimization if equals true\nget_dual_bound: store the dual objective value in the output if equals true\nsilent: set MOI.Silent() to its value\n\nUndocumented parameters are alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Optimize-an-mixed-integer-program-/-solve-a-combinatorial-problem","page":"Algorithms","title":"Optimize an mixed-integer program / solve a combinatorial problem","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"SolveIpForm\nMoiOptimize\nUserOptimize\nCustomOptimize","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.SolveIpForm","page":"Algorithms","title":"Coluna.Algorithm.SolveIpForm","text":"Coluna.Algorithm.SolveIpForm(\n    optimizer_id = 1\n    moi_params = MoiOptimize()\n    user_params = UserOptimize()\n    custom_params = CustomOptimize()\n)\n\nSolve an optimization problem. This algorithm can call different type of optimizers :\n\nsubsolver interfaced with MathOptInterface to optimize a mixed integer program\npricing callback defined by the user\ncustom optimizer to solve a custom model\n\nYou can specify an optimizer using the default_optimizer attribute of Coluna or with the method specify! from BlockDecomposition. If you want to define several optimizers for a given subproblem, you must use specify!:\n\nspecify!(subproblem, optimizers = [optimizer1, optimizer2, optimizer3])\n\nValue of optimizer_id is the position of the optimizer you want to use. For example, if optimizer_id is equal to 2, the algorithm will use optimizer2.\n\nBy default, the algorihm uses the first optimizer or the default optimizer if no optimizer has been specified through specify!.\n\nDepending on the type of the optimizer chosen, the algorithm will use one the  three configurations : \n\nmoi_params for subsolver interfaced with MathOptInterface\nuser_params for pricing callbacks\ncustom_params for custom solvers\n\nCustom solver is undocumented because alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.MoiOptimize","page":"Algorithms","title":"Coluna.Algorithm.MoiOptimize","text":"MoiOptimize(\n    time_limit = 600\n    deactivate_artificial_vars = false\n    enforce_integrality = false\n    get_dual_bound = true\n)\n\nConfiguration for an optimizer that calls a subsolver through MathOptInterface.\n\nParameters:\n\ntime_limit: in seconds\ndeactivate_artificial_vars: deactivate all artificial variables of the formulation if equals true\nenforce_integrality: enforce integer variables that are relaxed if equals true\nget_dual_bound: store the dual objective value in the output if equals true\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.UserOptimize","page":"Algorithms","title":"Coluna.Algorithm.UserOptimize","text":"UserOptimize(\n    max_nb_ip_primal_sols = 50\n)\n\nConfiguration for an optimizer that calls a pricing callback to solve the problem.\n\nParameters:\n\nmax_nb_ip_primal_sols: maximum number of solutions returned by the callback kept\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.CustomOptimize","page":"Algorithms","title":"Coluna.Algorithm.CustomOptimize","text":"CustomOptimize()\n\nConfiguration for an optimizer that calls a custom solver to solve a custom model.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/algorithm/#Divide-algorithms","page":"Algorithms","title":"Divide algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"NoBranching\nSimpleBranching\nStrongBranching","category":"page"},{"location":"man/algorithm/#Selection-criteria","page":"Algorithms","title":"Selection criteria","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"AbstractSelectionCriterion\nFirstFoundCriterion\nMostFractionalCriterion","category":"page"},{"location":"man/algorithm/#Branching-rules","page":"Algorithms","title":"Branching rules","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"SingleVarBranchingRule","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"danger: Danger\nColuna is under active development. Some features are undocumented because they are very experimental. Current users are expected to read the source code.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nWe assume that readers are familiar with integer programming and exact optimization methods.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a framework written in Julia to implement a decomposition approach to optimize  block-structured mixed-integer programs (MIP). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna relies on the tools of the JuMP-dev community at both ends of the problem treatment. It uses the JuMP modeling language upfront and MathOptInterface (MOI) to delegate master  and subproblems to MIP solvers. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The user introduces an original MIP that models his problem using the JuMP along our specific  extension BlockDecomposition that offers a syntax to specify the problem decomposition.  Coluna reformulates the original MIP using Dantzig-Wolfe and Benders decomposition  techniques.  Then, Coluna optimizes the reformulation using the algorithm chosen by the user.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna offers a \"black-box\" implementation of the branch-and-cut-and-price algorithm:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI). \nBlockDecomposition allows the user to provide to Coluna his decomposition of the model.   The BlockDecomposition syntax allows the user to implicilty define subsystems in the MIP on which the decomposition is based.   These subsystems are described by rows and/or columns indices.\nThe reformulation associated with the decomposition defined by the user is automatically generated by Coluna,  without requiring any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound.\nA default column (and cut) generation procedure is implemented.  It relies on underlying MOI optimizers to handle master and subproblems.   However, the user can use pricing callbacks to solve the subproblems.\nA branching scheme that preserves the pricing problem structure is offered by default;   it runs based on priorities and directives specified by the user on the original variables.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a package for Julia 1.6+.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It requires JuMP to model the problem, BlockDecomposition to define the decomposition, and a MIP solver supported by MathOptInterface to optimize the master and the subproblems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can install Coluna and its dependencies through the package manager of Julia by entering :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add Coluna","category":"page"},{"location":"#Extra-dependances","page":"Introduction","title":"Extra dependances","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CPLEX.jl >= 0.7.0 (cf issue 446)","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Atoptima, Mathematical Optimization Society (MOS), Région Nouvelle-Aquitaine, University of Bordeaux, and Inria","category":"page"}]
}
