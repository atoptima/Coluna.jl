var documenterSearchIndex = {"docs":
[{"location":"man/decomposition/#Decomposition-and-reformulation","page":"Decomposition","title":"Decomposition & reformulation","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Coluna is a framework to optimizate mixed-integer programs that you can decompose. In other words, if you remove the linking constraints or linking variables from you program, you'll get sets of constraints (blocks) that you can solve independently.","category":"page"},{"location":"man/decomposition/#Dantzig-Wolfe","page":"Decomposition","title":"Dantzig-Wolfe","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following coefficient matrix that has a block diagonal structure in gray and some linking constraints in blue :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Dantzig-Wolfe decomposition)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You penalize the violation of the linking constraints in the objective function. You can then solve the blocks independently.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The Dantzig-Wolfe reformulation gives raise to a master problem with an exponential number of variables. Coluna dynamically generates these variables by solving the subproblems. It's the column generation algorithm.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following original formulation in which we partition variables into two vectors x_1 and x_2 :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Original formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"When you apply a Dantzig-Wofe decomposition to this formulation,  Coluna reformulates it into the following master problem :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Master formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"where Q_1 is the index-set of the solutions to the first subproblem and  Q_2 is the index-set of the solutions to the second subproblem. The set of the solutions to the first and the second subproblems are tildex^q_1_q in Q_1 and tildex^q_2_q in Q_2 respectively. These solutions are expressed in terms of the original variables. The multiplicity of the subproblems is defined in the convexity constraints. Lower and upper multiplicity are 1 by default.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"At the beginning of the column generation algorithm, the master formulation does not have any master columns. Therefore, the master may be infeasible.  To prevent this, Coluna adds a local artifical variable specific to each constraint of the master and a global artificial variable. Costs of articial and global artificial variables can be defined in Coluna.Params.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Subproblems take the following form (here, it's the first subproblem) :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Subproblem n°1 formulation)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"where barc is the reduced cost of the original variables computed by the column generation algorithm.","category":"page"},{"location":"man/decomposition/#Dantzig-Wolfe-with-identical-subproblems-(alpha)","page":"Decomposition","title":"Dantzig-Wolfe with identical subproblems (alpha)","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"When some subproblems are identical (same coefficient matrix and right-hand side),  you can avoid solving all of them at each iteration by defining only one subproblem and setting its multiplicity to the number of time it appears.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let us see an example with Dantzig-Wolfe and a variant of the Generalized Assignment Problem.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Consider a set of machine type T = 1:nb_machine_types and a set of jobs J = 1:nb_jobs. A machine type t has a resource capacity Q[t] and the factory contains U[t] machines of type t. A job j assigned to a machine of type t has a cost c[t,j] and consumes w[t,j] resource units of the machine of type t.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Consider the following instance :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"nb_machine_types = 2;\nnb_jobs = 10;\nJ = 1:nb_jobs;\nQ = [10, 15];\nU = [3, 2];  # 3 machines of type 1 & 2 machines of type 2\nc = [10 11 13 11 12 14 15 8 9 11; 20 21 23 21 22 24 25 18 19 21];\nw = [4 4 5 4 4 3 4 5 6 5; 5 5 6 5 5 4 5 6 7 6];\nnothing #hide","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Here is the JuMP model to optimize this instance a classic solver : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"using JuMP, GLPK;\n\nT1 = [1, 2, 3]; # U[1] machines\nT2 = [4, 5]; # U[2] machines\nM = union(T1, T2);\nm2t = [1, 1, 1, 2, 2]; # machine id -> type id\n\nmodel = Model(GLPK.Optimizer);\n@variable(model, x[M, J], Bin); # 1 if job j assigned to machine m\n@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1);\n@constraint(model, knp[m in M], sum(w[m2t[m],j] * x[m,j] for j in J) <= Q[m2t[m]]);\n@objective(model, Min, sum(c[m2t[m],j] * x[m,j] for m in M, j in J));\n\noptimize!(model);\nobjective_value(model)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You can decompose over the machines by defining an axis on M. However, if you want to take advantage of the identical subproblems, you must  define the formulation as follows : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"using BlockDecomposition, Coluna, JuMP, GLPK;\nconst BD = BlockDecomposition\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\n\n@axis(T, 1:nb_machine_types);\n\nmodel = BlockModel(coluna);\n@variable(model, x[T, J], Bin); # 1 if job j assigned to machine m\n@constraint(model, cov[j in J], sum(x[t,j] for t in T) == 1);\n@constraint(model, knp[t in T], sum(w[t] * x[t,j] for j in J) <= Q[t]);\n@objective(model, Min, sum(c[t,j] * x[t,j] for t in T, j in J));\nnothing #hide","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We assign jobs to a type of machine and we define one knapsack constraint for each type. This formulation cannot be solved as it stands with a commercial solver.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Then, we decompose and specify the multiplicity of each knapsack subproblem : ","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"@dantzig_wolfe_decomposition(model, dec_on_types, T);\nsps = getsubproblems(dec_on_types)\nfor t in T\n    specify!(sps[t], lower_multiplicity = 0, upper_multiplicity = U[t]);\nend\ngetsubproblems(dec_on_types)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We see that subproblem for machine type 1 has upper multiplicity equals to 3, and second subproblem for machine type 2 has upper multiplicity equals to 2. It means that we can use at most 3 machines of type 1 and at most 2 machines of type 2.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"We can then optimize","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"optimize!(model);","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"and retrieve the disagreggated solution","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"for t in T\n    assignment_patterns = BD.getsolutions(model, t);\n    for pattern in assignment_patterns\n        nb_times_pattern_used = BD.value(pattern);\n        jobs_in_pattern = [];\n        for j in J\n            if BD.value(pattern, x[t, j]) ≈ 1\n                push!(jobs_in_pattern, j);\n            end\n        end\n        println(\"Pattern of machine type $t used $nb_times_pattern_used times : $jobs_in_pattern\");\n    end\nend","category":"page"},{"location":"man/decomposition/#Benders-(alpha)","page":"Decomposition","title":"Benders (alpha)","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"Let's consider the following coefficient matrix that has a block diagonal structure in gray and some linking variables in blue :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"(Image: Benders decomposition)","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You fix the complicated variables, then you can solve the blocks independently.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"This decomposition is an alpha feature.","category":"page"},{"location":"man/decomposition/#BlockDecomposition","page":"Decomposition","title":"BlockDecomposition","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The index-set of the subproblems is declared through an BlockDecomposition.@axis.  It returns an array. Each value of the array is a subproblem index wrapped into a BlockDecomposition.AxisId. Each time BlockDecomposition finds an AxisId in the indices of a variable and a constraint, it knows to which subproblem the variable or the constraint belongs.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockDecomposition allows the user to perform two types of decomposition using BlockDecomposition.@dantzig_wolfe_decomposition and BlockDecomposition.@benders_decomposition.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"The macro creates a decomposition tree where the root is the master and the depth is the number of nested decomposition. A classic Dantzig-Wolfe or Benders decomposition produces a decomposition tree of depth 1. At the moment, nested decomposition is not supported.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"You can get the subproblem membership of all variables and constraints using the method BlockDecomposition.annotation.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockDecomposition does not change the JuMP model. It decorates the model with additional information. All these information are stored in the ext field of the JuMP model.","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"CurrentModule = BlockDecomposition\nDocTestSetup = quote\n    using BlockDecomposition\nend","category":"page"},{"location":"man/decomposition/#Errors-and-warnings","page":"Decomposition","title":"Errors and warnings","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"MasterVarInDwSp\nVarsOfSameDwSpInMaster","category":"page"},{"location":"man/decomposition/#BlockDecomposition.MasterVarInDwSp","page":"Decomposition","title":"BlockDecomposition.MasterVarInDwSp","text":"Error thrown when a master variable is in a constraint that belongs to a Dantzig-Wolfe subproblem.\n\nYou can retrieve the JuMP variable and the JuMP constraint where the error occurs:\n\nerror.variable\nerror.constraint\n\n\n\n\n\n","category":"type"},{"location":"man/decomposition/#BlockDecomposition.VarsOfSameDwSpInMaster","page":"Decomposition","title":"BlockDecomposition.VarsOfSameDwSpInMaster","text":"Warning when a master constraint involves variables that belong to the same Dantzig-Wolfe subproblem. It means you can move the constraint in a subproblem.\n\n\n\n\n\n","category":"type"},{"location":"man/decomposition/#References","page":"Decomposition","title":"References","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"BlockModel","category":"page"},{"location":"man/decomposition/#BlockDecomposition.BlockModel","page":"Decomposition","title":"BlockDecomposition.BlockModel","text":"BlockModel(optimizer [, direct_model = false])\n\nReturn a JuMP model which BlockDecomposition will decompose using instructions given by the user.\n\nIf you define direct_model = true, the method creates the model with JuMP.direct_model, otherwise it uses JuMP.Model.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"These are the methods to decompose a JuMP model :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"@axis\n@benders_decomposition\n@dantzig_wolfe_decomposition","category":"page"},{"location":"man/decomposition/#BlockDecomposition.@axis","page":"Decomposition","title":"BlockDecomposition.@axis","text":"@axis(name, collection)\n\nDeclare collection as an index-set of subproblems.  You can access the axis using the variable name.\n\nExamples\n\nConsider a formulation that has a decomposition which gives raise to 5 subproblems. Let {1,2,3,4,5} be the index-set of the subproblems.\n\nTo perform this decomposition with BlockDecomposition, we must declare an axis that contains the index-set of the subproblems :\n\njulia> L = 1:5\n1:5\n\njulia> @axis(K, L)\nBlockDecomposition.Axis{:K, Int64}(:K, BlockDecomposition.AxisId{:K, Int64}[1, 2, 3, 4, 5])\n\njulia> K[1]\n1\n\njulia> typeof(K[1])\nBlockDecomposition.AxisId{:K, Int64}\n\nThe elements of the axis are AxisId. You must use AxisId in the indices of the variables and the constraints that you declare otherwise BlockDecomposition assign them to the master problem.\n\n@variable(model, x[l in L]) # x[l] belongs to the master for any l ∈ L\n@variable(model, y[k in K]) # y[k], k ∈ K, belongs to subproblem k (because K is an axis)\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/#BlockDecomposition.@benders_decomposition","page":"Decomposition","title":"BlockDecomposition.@benders_decomposition","text":"@benders_decomposition(model, name, axis)\n\nRegister a Benders decomposition on the JuMP model model where the index-set of the subproblems is defined by the axis axis.\n\nCreate a variable name from which the user can access decomposition tree.\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/#BlockDecomposition.@dantzig_wolfe_decomposition","page":"Decomposition","title":"BlockDecomposition.@dantzig_wolfe_decomposition","text":"@dantzig_wolfe_decomposition(model, name, axis)\n\nRegister a Dantzig-Wolfe decomposition on the JuMP model model where the index-set of the subproblems is defined by the axis axis.\n\nCreate a variable name from which the user can access the decomposition tree.\n\n\n\n\n\n","category":"macro"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"These are the methods to set additional information to the decomposition (multiplcity and optimizers) :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"getmaster\ngetsubproblems\nspecify!","category":"page"},{"location":"man/decomposition/#BlockDecomposition.getmaster","page":"Decomposition","title":"BlockDecomposition.getmaster","text":"getmaster(node) -> MasterForm\n\nReturn an object that wraps the annotation that describes the master formulation of a decomposition stored at the node of the decomposition tree.\n\nThis method is not defined if the node is a leaf of the decomposition tree.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/#BlockDecomposition.getsubproblems","page":"Decomposition","title":"BlockDecomposition.getsubproblems","text":"getsubproblems(node) -> Vector{SubproblemForm}\n\nReturn a vector of objects that wrap the annotations that describe subproblem formulations of a decomposition stored at node of the decomposition tree.\n\nThis method is not defined if the node is a leaf of the decomposition tree.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/#BlockDecomposition.specify!","page":"Decomposition","title":"BlockDecomposition.specify!","text":"specify!(\n    subproblem, \n    lower_multiplicity = 1,\n    upper_multiplicity = 1,\n    solver = nothing\n)\n\nMethod that allows the user to specify additional property of the subproblems.\n\nThe multiplicity of subproblem is the number of times that the same independant block shaped by the subproblem in the coefficient matrix appears in the model. It is equivalent to the number of solutions to the subproblem that can appear in the solution  of the original problem.\n\nThe solver of the subproblem is the way the subproblem will be optimized. It can be either a function (pricing callback), an optimizer of MathOptInterface  (e.g. Gurobi.Optimizer, CPLEX.Optimizer, Glpk.Optimizer... with attributes),  or nothing. In the latter case, the solver will use a default optimizer that  should be defined in the parameters of the main solver.\n\nAdvanced usage :  The user can use several solvers to optimize a subproblem : \n\nspecify!(subproblem, solver = [Gurobi.Optimizer, my_callback, my_second_callback])\n\nColuna always uses the first solver by default. Be cautious because changes are always buffered to all solvers. So you may degrade performances if you use a lot of solvers.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"This method help you to check your decomposition :","category":"page"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"annotation","category":"page"},{"location":"man/decomposition/#BlockDecomposition.annotation","page":"Decomposition","title":"BlockDecomposition.annotation","text":"annotation(node)\n\nReturn the annotation that describes the master/subproblem of a given node of the decomposition tree.\n\nannotation(model, variable)\nannotation(model, constraint)\n\nReturn the subproblem to which a variable or a constraint belongs.\n\n\n\n\n\n","category":"function"},{"location":"man/decomposition/","page":"Decomposition","title":"Decomposition","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"dynamic_sparse_arrays/#Dynamic-Sparse-Arrays","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"","category":"section"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"This package aims to provide dynamic sparse vectors and matrices in Julia.  Unlike the sparse arrays provided in SparseArrays, arrays from this package have unfixed sizes.  It means that we can add or delete rows and columns after the instantiation of the array.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"DynamicSparseArrays is a registered package.","category":"page"},{"location":"dynamic_sparse_arrays/#Introduction","page":"Dynamic Sparse Arrays","title":"Introduction","text":"","category":"section"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"Coluna is a branch-cut-and-price framework. It means that Coluna's algorithms dynamically generate constraints and variables. Therefore, the coefficient matrix (which is usually sparse) must support the addition of new rows and columns.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"For this purpose, we implemented the packed-memory array data structure to handle the dynamic sparse vector introduced in the following papers:","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"BENDER, Michael A. et HU, Haodong. An adaptive packed-memory array. ACM Transactions on Database Systems (TODS), 2007, vol. 32, no 4, p. 26.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"BENDER, Michael A., DEMAINE, Erik D., et FARACH-COLTON, Martin. Cache-oblivious B-trees. SIAM Journal on Computing, 2005, vol. 35, no 2, p. 341-358.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"On top of the packed-memory array, we implemented the data structure introduced in the following paper to handle the dynamic sparse matrix.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"WHEATMAN, Brian et XU, Helen. Packed Compressed Sparse Row: A Dynamic Graph Representation. In : 2018 IEEE High Performance extreme Computing Conference (HPEC). IEEE, 2018. p. 1-7.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"The implementation may vary from the description in the papers. If you find some enhancements, please contact guimarqu.","category":"page"},{"location":"dynamic_sparse_arrays/#Overview","page":"Dynamic Sparse Arrays","title":"Overview","text":"","category":"section"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"The packed-memory array (PackedMemoryArray{K,T}) is a Vector{Union{Nothing,Tuple{K,T}}} where K is the type of the keys and T is the type of the values. We keep empty entries (i.e. Nothing) in the array to \"fastly\" add new values later. Non-empty entries are sorted by ascending key order. The array is virtually split into segments of equal size. The goal is to maintain the density (i.e. number of non-empty values/size of the segment) of each segment between pre-defined bounds. We also consider the density of certain unions of segments represented by nodes of the tree in gray. The root node of the tree is the union of all segments, thus the whole array. When one node of the tree has a density outside the allowed bounds, we need to rebalance the parent. It means that we redistribute the empty and non-empty entries to fit the density bounds. If the density bounds are not respected at the root node, we resize the array.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"On top of the packed-memory array, there is the (PackedCSC{K,T}).  This is a particular case of a matrix where values are of type T, row keys of type K, and column keys of type Int. Each column of the matrix (partition) is delimited by a semaphore which is a non-empty entry with a reserved key value defined by the semaphore_key function. In the example, the first partition has its semaphore at position 1, starts at position 2, and finishes at position 9.  At position 10, it's the semaphore that signals the beginning of the second partition. In each partition, non-empty entries are sorted by ascending key order.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"As you can see, the PackedCSC{K,T} is not well suited to the matrix. Indeed, each column is associated with a partition. If you have a column with only zero values, the array will contain a partition with only empty entries. Lastly, the type of column key is Int. Therefore, built on top of PackedCSC{K,T}, MappedCSC{K,L,T} corrects all these shortcomings. This data structure just associates a column key of type L to each partition of PackedCSC{K,T}.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"<div style=\"width:75%; margin-left:auto; margin-right:auto\">","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"(Image: Dynamic Sparse Arrays)","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"<p style=\"text-align: center;\">Architecture overview.</p>\n</div>","category":"page"},{"location":"dynamic_sparse_arrays/#References","page":"Dynamic Sparse Arrays","title":"References","text":"","category":"section"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"DocTestSetup = quote\n    using DynamicSparseArrays\nen","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"dynamicsparsevec\ndynamicsparse","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"api/branching/#Branching-API","page":"Branching","title":"Branching API","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Coluna provides default implementations for the branching algorithm and the strong branching algorithms. Both implementations are built on top of an API that we describe here.","category":"page"},{"location":"api/branching/#Candidates-selection","page":"Branching","title":"Candidates selection","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Candidates selection is the first step (and sometimes the only step) of any branching algorithm. It chooses what are the possible branching constraints that will generate the children of the current node of the branch-and-bound tree.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Coluna provides the following function for this step:","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"select!","category":"page"},{"location":"api/branching/#Coluna.Algorithm.select!","page":"Branching","title":"Coluna.Algorithm.select!","text":"Candidates selection for branching algorithms.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"It works as follows.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"The user chooses one or several branching rules that indicate the type of branching he want to perform. This may be on a single variable or on a linear expression of variables for instance. ","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"The branching rule must implement apply_branching_rule that generates the candidates.  The latter are the variables or expressions on which the branch-and-bound may branch with additional information that are requested by Coluna's branching implementation through the API.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Then, candidates are sorted according to a selection criterion (e.g. most fractional). The algorithm keeps a certain number of candidates (one for a classic branching, several for a strong branching). It generates the children of each candidate kept. At last, it returns the candidates kept.","category":"page"},{"location":"api/branching/#Branching-rule","page":"Branching","title":"Branching rule","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"AbstractBranchingRule\napply_branching_rule","category":"page"},{"location":"api/branching/#Coluna.Algorithm.AbstractBranchingRule","page":"Branching","title":"Coluna.Algorithm.AbstractBranchingRule","text":"Supertype of branching rules.\n\n\n\n\n\n","category":"type"},{"location":"api/branching/#Coluna.Algorithm.apply_branching_rule","page":"Branching","title":"Coluna.Algorithm.apply_branching_rule","text":"Returns all candidates that satisfy a given branching rule.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Candidate","page":"Branching","title":"Candidate","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"AbstractBranchingCandidate\ngetdescription\nget_lhs\nget_local_id\nget_children\nset_children!\nget_parent\ngenerate_children!","category":"page"},{"location":"api/branching/#Coluna.Algorithm.AbstractBranchingCandidate","page":"Branching","title":"Coluna.Algorithm.AbstractBranchingCandidate","text":"A branching candidate is a data structure that contain all information needed to generate children of a node.\n\n\n\n\n\n","category":"type"},{"location":"api/branching/#Coluna.Algorithm.getdescription","page":"Branching","title":"Coluna.Algorithm.getdescription","text":"Returns a string which serves to print the branching rule in the logs.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_lhs","page":"Branching","title":"Coluna.Algorithm.get_lhs","text":"Returns the left-hand side of the candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_local_id","page":"Branching","title":"Coluna.Algorithm.get_local_id","text":"Returns the generation id of the candidiate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_children","page":"Branching","title":"Coluna.Algorithm.get_children","text":"Returns the children of the candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.set_children!","page":"Branching","title":"Coluna.Algorithm.set_children!","text":"Set the children of the candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_parent","page":"Branching","title":"Coluna.Algorithm.get_parent","text":"Returns the parent of a node; nothing if the node is the root.\n\n\n\n\n\nReturns the parent node of the candidate's children.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.generate_children!","page":"Branching","title":"Coluna.Algorithm.generate_children!","text":"generate_children!(branching_candidate, lhs, env, reform, node)\n\nThis method generates the children of a node described by branching_candidate. Make sure that this method returns an object the same type as the second argument of set_children!(candiate, children).\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Selection-criterion","page":"Branching","title":"Selection criterion","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"AbstractSelectionCriterion\nselect_candidates!","category":"page"},{"location":"api/branching/#Coluna.Algorithm.AbstractSelectionCriterion","page":"Branching","title":"Coluna.Algorithm.AbstractSelectionCriterion","text":"Supertype of selection criteria of branching candidates.\n\nA selection criterion provides a way to keep only the most promising branching candidates. To create a new selection criterion, one needs to create a subtype of AbstractSelectionCriterion and implements the method select_candidates!.\n\n\n\n\n\n","category":"type"},{"location":"api/branching/#Coluna.Algorithm.select_candidates!","page":"Branching","title":"Coluna.Algorithm.select_candidates!","text":"Sort branching candidates according to the selection criterion and remove excess ones.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Branching-API-2","page":"Branching","title":"Branching API","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"get_selection_nb_candidates\nbranching_context_type\nnew_context\nget_int_tol\nget_rules\nget_selection_criterion","category":"page"},{"location":"api/branching/#Coluna.Algorithm.get_selection_nb_candidates","page":"Branching","title":"Coluna.Algorithm.get_selection_nb_candidates","text":"Returns the number of candidates that the candidates selection step must return.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.branching_context_type","page":"Branching","title":"Coluna.Algorithm.branching_context_type","text":"Returns the type of context required by the algorithm parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.new_context","page":"Branching","title":"Coluna.Algorithm.new_context","text":"Creates a context.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_int_tol","page":"Branching","title":"Coluna.Algorithm.get_int_tol","text":"Returns integer tolerance.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_rules","page":"Branching","title":"Coluna.Algorithm.get_rules","text":"Returns branching rules.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_selection_criterion","page":"Branching","title":"Coluna.Algorithm.get_selection_criterion","text":"Returns the selection criterion.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Method advanced_select! is part of the API but presented just below.","category":"page"},{"location":"api/branching/#Advanced-candidates-selection","page":"Branching","title":"Advanced candidates selection","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"If the candidates selection returns several candidates will all their children, advanced candidates selection must keep only one of them.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"The advanced candidates selection is the place to evaluate the children to get relevant additional kpis about each branching candidates.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Coluna provides the following function for this step.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"advanced_select!","category":"page"},{"location":"api/branching/#Coluna.Algorithm.advanced_select!","page":"Branching","title":"Coluna.Algorithm.advanced_select!","text":"Advanced candidates selection that selects candidates by evaluating their children.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Coluna has two default implementation for this method:","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"for the classic branching that does nothing because the candidates selection returns 1 candidate\nfor the strong branching that performs several evaluation of the candidates.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Let us focus on the strong branching.  Strong branching is a procedure that heuristically selects a branching constraint that potentially gives the best progress of the dual bound. The procedure selects a collection of branching candidates based on their branching rule (done in classic candidate selection)  and their score (done in advances candidate selection). Then, the procedure evaluates the progress of the dual bound in both branches of each branching candidate by solving both potential children using a conquer algorithm. The candidate that has the largest score is chosen to be the branching constraint.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"However, the score can be difficult to compute. For instance, when the score is based dual bound improvement produced by the branching constraint which is time-consuming to evaluate in the context of column generation Therefore, one can let the branching algorithm quickly estimate the score of each candidate  and retain the most promising branching candidates.  This is called a phase. The goal is to first evaluate a large number of candidates with a very fast conquer algorithm and retain a certain number of promising ones.  Then, over the phases, it evaluates the improvement with a more precise conquer algorithm and restrict the number of retained candidates until only one is left.","category":"page"},{"location":"api/branching/#Strong-Branching-API","page":"Branching","title":"Strong Branching API","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"get_units_to_restore_for_conquer\nget_phases\nget_score\nget_conquer\nget_max_nb_candidates","category":"page"},{"location":"api/branching/#Coluna.Algorithm.get_units_to_restore_for_conquer","page":"Branching","title":"Coluna.Algorithm.get_units_to_restore_for_conquer","text":"Returns the storage units that must be restored by the conquer algorithm called by the strong branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_phases","page":"Branching","title":"Coluna.Algorithm.get_phases","text":"Returns all phases context of the strong branching algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_score","page":"Branching","title":"Coluna.Algorithm.get_score","text":"Returns the type of score used to rank the candidates at a given strong branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_conquer","page":"Branching","title":"Coluna.Algorithm.get_conquer","text":"Returns the conquer algorithm.\n\n\n\n\n\nReturns the conquer algorithm used to evaluate the candidate's children at a given strong branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.get_max_nb_candidates","page":"Branching","title":"Coluna.Algorithm.get_max_nb_candidates","text":"Returns the maximum number of candidates kept at the end of a given strong branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Following methods are part of the API but have default implementation. We advise to not change them.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"perform_branching_phase!\neval_children_of_candidate!\neval_child_of_candidate!","category":"page"},{"location":"api/branching/#Coluna.Algorithm.perform_branching_phase!","page":"Branching","title":"Coluna.Algorithm.perform_branching_phase!","text":"Performs a branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.eval_children_of_candidate!","page":"Branching","title":"Coluna.Algorithm.eval_children_of_candidate!","text":"Evaluates a candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Algorithm.eval_child_of_candidate!","page":"Branching","title":"Coluna.Algorithm.eval_child_of_candidate!","text":"Evaluate children of a candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Score","page":"Branching","title":"Score","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"AbstractBranchingScore\ncompute_score","category":"page"},{"location":"api/branching/#Coluna.Algorithm.AbstractBranchingScore","page":"Branching","title":"Coluna.Algorithm.AbstractBranchingScore","text":"Supertype of branching scores.\n\n\n\n\n\n","category":"type"},{"location":"api/branching/#Coluna.Algorithm.compute_score","page":"Branching","title":"Coluna.Algorithm.compute_score","text":"Returns the score of a candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/api/storage.jl\"","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm, Coluna.ColunaBase\nend","category":"page"},{"location":"api/storage/#Storage-API","page":"Storage","title":"Storage API","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"warning: Warning\n","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"Missing intro, missing finding best solution.","category":"page"},{"location":"api/storage/#Introduction","page":"Storage","title":"Introduction","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"A storage is a collection of storage units attached to a model.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"A storage unit is a type that groups a set of entities for which we want to track the value over time. We can distinguish two kinds of storage units. First, storage units that track entities of the model (e.g. status of branching constraints, lower and upper bounds of variables). Second, storage units that track additional data (e.g. data of algorithms).","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"Since the values of the entities grouped in a storage unit vary over time, we want to save them at specific steps of the calculation flow to restore them later. The storage interface provides two methods to do both actions:","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"    create_record\n    restore_from_record!","category":"page"},{"location":"api/storage/#Coluna.ColunaBase.create_record","page":"Storage","title":"Coluna.ColunaBase.create_record","text":"create_record(storage, storage_unit_type)\n\nReturns a Record that contains a description of the state of the storage unit at the time  when the method is called.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Coluna.ColunaBase.restore_from_record!","page":"Storage","title":"Coluna.ColunaBase.restore_from_record!","text":"Restore information from the model or the storage unit that is recorded in a record.\n\n\n\n\n\nrestore_from_record!(storage, record)\n\nRestores the state of the storage unit using the record that was previously generated.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Example","page":"Storage","title":"Example","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"Let's see through a simple example how to implement this interface.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"In this example, we want to find the best solution by enumerating all the possible solutions using a tree search.","category":"page"},{"location":"api/storage/#Formulation","page":"Storage","title":"Formulation","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"First, we import the dependencies","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"using Coluna;\nnothing #hide","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"and we define some shortcuts for the sake of brievety.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"const ClB = Coluna.ColunaBase;\nconst ClA = Coluna.Algorithm;\nnothing #hide","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We consider a data structure that maintain a model.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"struct Formulation <: ClB.AbstractModel\n    var_names::Vector{String}\n    var_costs::Vector{Float64}\n    var_domains::Vector{Tuple{Float64,Float64}}\nend","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"The model has 3 integer variables. The following arrays contain theirs names, costs, and initial bounds.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"names = [\"x1\", \"x2\", \"x3\"];\ncosts = [-1, 1, -0.5];\ninitial_bounds = [(0,2), (0.9,2), (-1,0.5)];\nnothing #hide","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We instanciate the model.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"formulation = Formulation(names, costs, initial_bounds);\nnothing #hide","category":"page"},{"location":"api/storage/#Storage","page":"Storage","title":"Storage","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"The tree search algorithm will branch on all feasible integer values of x1 at depth 1, x2 at depth 2, and x3 at depth 3.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"Each time, the tree search algorithm will evaluate a node, it will need to know the state of the formulation (e.g. domains of variables) at this node. To this purpose, we will use the storage.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We create a storage unit for variable domains","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"struct VarDomainStorageUnit <: ClB.AbstractNewStorageUnit end","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"and its constructor.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"ClB.new_storage_unit(::Type{VarDomainStorageUnit}, _) = VarDomainStorageUnit()","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"The state of the variables' domains at a given node is called a record. The record is defined by the following data structure:","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"struct VarDomainRecord <: ClB.AbstractNewRecord\n    var_domains::Vector{Tuple{Float64,Float64}}\nend","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"There is a one-to-one correspondance between storage unit types and record types. This correspondance is implemented by the two following methods:","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"ClB.record_type(::Type{VarDomainStorageUnit}) = VarDomainRecord\nClB.storage_unit_type(::Type{VarDomainRecord}) = VarDomainStorageUnit","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We implement the method that creates a record of the variables' domains.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function ClB.new_record(::Type{VarDomainRecord}, id::Int, form::Formulation, ::VarDomainStorageUnit)\n    return VarDomainRecord(copy(form.var_domains))\nend","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We implement the method that restore the variables' domains of the formulation from a given record.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function ClB.restore_from_record!(form::Formulation, ::VarDomainStorageUnit, record::VarDomainRecord)\n    for (var_pos, (lb, ub)) in enumerate(record.var_domains)\n        form.var_domains[var_pos] = (lb, ub)\n    end\n    return\nend","category":"page"},{"location":"api/storage/#Tree-search-algorithm","page":"Storage","title":"Tree search algorithm","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"There is a tutorial about the tree search interface.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We define the node data structure.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"mutable struct Node <: ClA.AbstractNode\n    depth::Int\n    id::Int\n    branch_description::String\n    parent::Union{Nothing,Node}\n    record\n    function Node(parent, id, branch, record)\n        depth = isnothing(parent) ? 0 : parent.depth + 1\n        return new(depth, id, branch, parent, record)\n    end\nend\n\nClA.get_root(node::Node) = isnothing(node.parent) ? node : ClA.root(node.parent)\nClA.get_parent(node::Node) = node.parent","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We define the search space data structure. Note that we keep the storage in the search space because we have access to this data structure throughout the whole tree search execution.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"mutable struct FullExplSearchSpace <: ClA.AbstractSearchSpace\n    nb_nodes_generated::Int\n    formulation::Formulation\n    solution::Tuple{Vector{Float64},Float64}\n    storage::ClB.NewStorage{Formulation}\n    record_ids_per_node::Dict{Int, Any}\n    function FullExplSearchSpace(form::Formulation)\n        return new(0, form, ([],Inf), ClB.NewStorage(form), Dict{Int,Any}())\n    end\nend","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We implement the method that returns the root node.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function ClA.new_root(space::FullExplSearchSpace, _)\n    space.nb_nodes_generated += 1\n    return Node(nothing, 1, \"\", nothing)\nend","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We define a method that prints node information and the state of the formulation together.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function print_form(form, current)\n    t = repeat(\"   \", current.depth)\n    node = string(\"Node \", current.id, \" \")\n    branch = isempty(current.branch_description) ? \"\" : string(\"- Branch \", current.branch_description, \" \")\n    domains = mapreduce(*, enumerate(form.var_domains); init = \"|| \") do e\n        var_pos = first(e)\n        lb, ub = last(e)\n        rhs = lb == ub ? string(\" == \", lb) : string(\" ∈ [\", lb, \", \", ub, \"] \")\n        return string(\"x\", var_pos, rhs, \"  \")\n    end\n    println(t, node, branch, domains)\nend;\nnothing #hide","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We write a function to calculate the solution at the current formulation of a node.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function compute_sol(space::FullExplSearchSpace, current)\n    model = space.formulation\n    sol = Float64[]\n    sol_cost = 0.0\n    for (cost, (ub, lb)) in Iterators.zip(model.var_costs, model.var_domains)\n        var_val = (ub + lb) / 2.0\n        sol_cost += var_val * cost\n        push!(sol, var_val)\n    end\n    return sol, sol_cost\nend","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We write a method that updates the best-found solution when the node solution is better.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function update_best_sol!(space::FullExplSearchSpace, solution::Tuple{Vector{Float64},Float64})\n    if last(solution) < last(space.solution)\n        space.solution = solution\n    end\nend","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"Let's now talk about how we will store and restore the state of the formulation in our tree search algorithm.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"The algorithm starts by creating and evaluating the root node. At this node the formulation is at its initial state, so it is ready to be evaluated. After node evaluation, the tree search branches, thus changing the formulation. Consequently, before branching, we generate a record of the state of the formulation at the root node to be able to restore it later if needed. Otherwise, we will no longer know what the original formulation state was. Then, each time we generate a child, we restore the state of the formulation at the parent node, we create the branching constraint, we generate a record of the state of the modified formulation in the child node, and we restore the state of the formulation at the current node.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We could optimize the number of record/restore operations for this specific example but that is beyond the scope of this tutorial.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We group operations that evaluate the current node in the following method.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function evaluate_current_node(space::FullExplSearchSpace, current)\n    # The root node does not have any record when its evaluation begins.\n    if !isnothing(current.record)\n         # We restore the state of the formulation using the record stored in the current node.\n        ClB.restore_from_record!(space.storage, current.record)\n    end\n\n    # Print the current formulation\n    print_form(space.formulation, current)\n\n    # Compute solution\n    sol = compute_sol(space, current)\n\n    # Update best solution\n    update_best_sol!(space, sol)\n\n    # Record current state of the formulation and keep the record in the current node.\n    # This is not necessary here but the formulation often changes during evaluation.\n    current.record = ClB.create_record(space.storage, VarDomainStorageUnit)\nend;\nnothing #hide","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We group operations that generate the children of the current node in the following method.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function create_children(space::FullExplSearchSpace, current)\n    # Variable on which we branch.\n    var_pos = current.depth + 1\n    var_domain = get(space.formulation.var_domains, var_pos, (0,-1))\n\n    return map(range(ceil(first(var_domain)), floor(last(var_domain)))) do rhs\n        space.nb_nodes_generated += 1\n        node_id = space.nb_nodes_generated\n\n        # Add branching constraint - change formulation.\n        space.formulation.var_domains[var_pos] = (rhs, rhs)\n\n        # Record the state of the formulation with the branching constraint\n        # and keep it in the child node.\n        rec = ClB.create_record(space.storage, VarDomainStorageUnit)\n        space.record_ids_per_node[node_id] = rec\n\n        # Restore the state of the formulation at the current node.\n        ClB.restore_from_record!(space.storage, current.record)\n\n        branch = string(\"x\", var_pos, \" == \", rhs)\n        return Node(current, node_id, branch, rec)\n    end\nend;\nnothing #hide","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We define the method children of the tree search API. It evaluates the current node and then generates its children.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"function ClA.children(space::FullExplSearchSpace, current, _, _)\n    evaluate_current_node(space, current)\n    return create_children(space, current)\nend","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We don't define specific stopping criterion.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"ClA.stop(::FullExplSearchSpace, _) = false","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We return the best solution and the record at each node to make sure the example worked.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"ClA.tree_search_output(space::FullExplSearchSpace, _) = space.record_ids_per_node, space.solution","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"We run the example.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"search_space = FullExplSearchSpace(formulation)\nClA.tree_search(ClA.DepthFirstStrategy(), search_space, nothing, nothing)","category":"page"},{"location":"api/storage/#API","page":"Storage","title":"API","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"To summarize from a developer point of view, there is a one-to-one correspondance between storage unit types and record types. this correspondance is implemented by methods record_type(StorageUnitType) and storage_unit_type(RecordType).","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"The developer must also implement methods new_storage_unit(StorageUnitType) and new_record(RecordType, id, model, storage_unit) that must call constructors of the custom storage unit and the one of its associated records. Arguments of new_record allow the developer to record the state of entities from both the storage unit and the model.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"At last, he must implement restore_from_record!(storage_unit, model, record) to restore the state of the entities represented by the storage unit. Entities can be in the storage unit, the model, or in both of them.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"    record_type\n    storage_unit_type\n    new_storage_unit\n    new_record\n    restore_from_record!","category":"page"},{"location":"api/storage/#Coluna.ColunaBase.record_type","page":"Storage","title":"Coluna.ColunaBase.record_type","text":"Returns the type of record stored in a type of storage unit.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Coluna.ColunaBase.storage_unit_type","page":"Storage","title":"Coluna.ColunaBase.storage_unit_type","text":"Returns the type of storage unit that stores a type of record.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Coluna.ColunaBase.new_storage_unit","page":"Storage","title":"Coluna.ColunaBase.new_storage_unit","text":"Returns a storage unit from a given type.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Coluna.ColunaBase.new_record","page":"Storage","title":"Coluna.ColunaBase.new_record","text":"Creates a record of information from the model or a storage unit.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/start.jl\"","category":"page"},{"location":"start/start/#Column-generation-with-the-Generalized-Assignment-Problem","page":"Column generation","title":"Column generation with the Generalized Assignment Problem","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This quick start guide introduces the main features of Coluna through the example of the Generalized Assignment Problem.","category":"page"},{"location":"start/start/#Classic-model-solved-with-MIP-solver","page":"Column generation","title":"Classic model solved with MIP solver","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Consider a set of machines M and a set of jobs J. A machine m has a resource capacity Q_m . A job j assigned to a machine m has a cost c_mj and consumes w_mj resource units of the machine m. The goal is to minimize the sum of job costs while assigning each job to a machine and not exceeding the capacity of each machine.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Let x_mj equal to one if job j is assigned to machine m; 0 otherwise. The problem has the original formulation:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"beginalignedat4\ntextGAP equiv min mathrlapsum_m in Msum_j in J c_mj x_mj  \ntextst  sum_m in M x_mj = 1  quad j in J \n sum_j in J w_mj x_mj leq Q_m  quad  quad m in M  \n x_mj  in 01  m in M j in J\nendalignedat","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Let us consider the following instance.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"M = 1:3;\nJ = 1:15;\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5; 19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7; 13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2];\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91;91 81 66 63 59 81 87 90 65 55 57 68 92 91 86; 62 79 73 60 75 66 68 99 69 60 56 100 67 68 54];\nQ = [1020 1460 1530];\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"We write the model with JuMP, a domain-specific modeling language for mathematical optimization embedded in Julia. We optimize with GLPK. If you are not familiar with the JuMP package, you may want to check its documentation.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"using JuMP, GLPK;\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"A JuMP model for the original formulation is:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[m in M, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M) >= 1);\n@constraint(model, knp[m in M], sum(w[m, j] * x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M, j in J));\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"We optimize the instance and retrieve the objective value.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"optimize!(model);\nobjective_value(model)","category":"page"},{"location":"start/start/#Try-column-generation-easily-with-Coluna-and-BlockDecomposition","page":"Column generation","title":"Try column generation easily with Coluna and BlockDecomposition","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This model has a block structure: each knapsack constraint defines an independent block and the set-partitioning constraints couple these independent blocks. By applying the Dantzig-Wolfe reformulation, each knapsack constraint forms a tractable subproblem and the set-partitioning constraints are handled in a master problem.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"To write the model, you need JuMP and BlockDecomposition. The latter is an extension built on top of JuMP to model Dantzig-Wolfe and Benders decompositions. You will find more documentation about BlockDecomposition in the Decomposition & reformulation To optimize the problem, you need Coluna and a Julia package that provides a MIP solver such as GLPK.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Since we have already loaded JuMP and GLPK, we just need:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"using BlockDecomposition, Coluna;\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Next, you instantiate the solver and define the algorithm that you use to optimize the problem. In this case, the algorithm is a classic branch-and-price provided by Coluna.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default branch-cut-and-price\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In BlockDecomposition, an axis is an index set of subproblems. Let M_axis be the index set of machines; it defines an axis along which we can implement the desired decomposition.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@axis(M_axis, M);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In this example, the axis M_axis defines one knapsack subproblem for each machine. For instance, the first machine index is 1 and is of type BlockDecomposition.AxisId:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"M_axis[1]\n\ntypeof(M_axis[1])","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Jobs are not involved in the decomposition, set J of jobs thus stays as a classic range.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The model takes the form:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"model = BlockModel(coluna);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You can write BlockModel(coluna; direct_model = true) to pass names of variables and constraints to Coluna.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M_axis) >= 1);\n@constraint(model, knp[m in M_axis], sum(w[m, j] * x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M_axis, j in J));\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This is the same model as above except that we use a BlockModel instead of a Model and M_axis as the set of machines instead of M. Therefore, BlockDecomposition will know which variables and constraints are involved in subproblems because one of their indices is a BlockDecomposition.AxisId.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You then apply a Dantzig-Wolfe decomposition along M_axis:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@dantzig_wolfe_decomposition(model, decomposition, M_axis)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"where decomposition is a variable that contains information about the decomposition.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"decomposition","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Once the decomposition is defined, you can retrieve the master and the subproblems to give additional information to the solver.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"master = getmaster(decomposition)\nsubproblems = getsubproblems(decomposition)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The multiplicity of a subproblem is the number of times that the same independent block shaped by the subproblem appears in the model. This multiplicy also specifies the number of solutions to the subproblem that can appear in the solution to the original problem.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In this GAP instance, the upper multiplicity is 1 because every subproblem is different, i.e., every machine is different and used at most once.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The lower multiplicity is 0 because a machine may stay unused. The multiplicity specifications take the form:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"specify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)\ngetsubproblems(decomposition)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The model is now fully defined. To solve it, you need to call:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"optimize!(model)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You can find more information about the output of the column generation algorithm ColumnGeneration.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Finally, you can retrieve the solution to the original formulation with JuMP methods. For example, if we want to know if the job 3 is assigned to machine 1:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"value(x[1,3])","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"qa/#Question-and-Answer","page":"Q&A","title":"Question & Answer","text":"","category":"section"},{"location":"qa/#Default-algorithms-of-Coluna-do-not-beat-the-commercial-solver-I-usually-use.-Is-it-normal-?","page":"Q&A","title":"Default algorithms of Coluna do not beat the commercial solver I usually use. Is it normal ?","text":"","category":"section"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Yes it is.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Solvers such as Gurobi, Cplex ... are handy powerful black-box tools.  They can run a very efficient presolve step to simplify the formulation, automatically apply lots of valid inequalities (such as MIR or cover cuts),  choose good branching strategies, or also run heuristics. However, when your formulation reaches a certain size, commercial solvers may run for hours without finding anything. This is the point where you may want to decompose your formulation.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Coluna is a framework not a solver. It provides algorithms to try column generation on your problem very easily. Then, you can devise your own branch-cut-and-price algorithm on top of Coluna's algorithms. to scale up and hopefully beats the commercial solver.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"To start customizing Coluna for your own problem,  you can separate valid inequalities  or call your own algorithm that optimizes subproblems.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/cuts.jl\"","category":"page"},{"location":"start/cuts/#Valid-inequalities","page":"Valid inequalities","title":"Valid inequalities","text":"","category":"section"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Now let us consider a variant of the Generalized Assignment Problem in which we have to pay f[m] to use machine m.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Consider the following instance:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"J = 1:10\nM = 1:5\nc = [10.13 15.6 15.54 13.41 17.08;19.58 16.83 10.75 15.8 14.89;14.23 17.36 16.05 14.49 18.96;16.47 16.38 18.14 15.46 11.64;17.87 18.25 13.12 19.16 16.33;11.09 16.76 15.5 12.08 13.06;15.19 13.86 16.08 19.47 15.79;10.79 18.96 16.11 19.78 15.55;12.03 19.03 16.01 14.46 12.77;14.48 11.75 16.97 19.95 18.32];\nw = [5, 4, 5, 6, 8, 9, 5, 8, 10, 7];\nQ = [25,  24,  31,  28,  24];\nf = [105, 103, 109, 112, 100];\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We define the dependencies:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"using JuMP, BlockDecomposition, Coluna, GLPK;\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We parametrize the solver. We solve only the root node of the branch-and-bound tree and we use a column and cut generation algorithm to conquer (optimize) this node.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"coluna = JuMP.optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm(\n            conqueralg = Coluna.Algorithm.ColCutGenConquer(\n                max_nb_cut_rounds = 20\n            ),\n            branchingtreefile = \"tree2.dot\",\n            maxnumnodes = 1\n        )\n    ),\n    \"default_optimizer\" => GLPK.Optimizer\n);\nnothing #hide","category":"page"},{"location":"start/cuts/#Column-generation","page":"Valid inequalities","title":"Column generation","text":"","category":"section"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We write the model:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"model = BlockModel(coluna; direct_model = true);\n@axis(M_axis, M)\n@variable(model, x[j in J, m in M_axis], Bin);\n@variable(model, y[m in M_axis], Bin);\n@constraint(model, setpartitioning[j in J], sum(x[j,m] for m in M_axis) == 1);\n@constraint(model, knp[m in M_axis], sum(w[j]*x[j,m] for j in J) <= Q[m] * y[m]);\n@objective(model, Min, sum(c[j,m] * x[j,m] for m in M_axis, j in J) + sum(f[m] * y[m] for m in M_axis));\n\n@dantzig_wolfe_decomposition(model, dec, M_axis);\nsp = getsubproblems(dec);\nspecify!.(sp, lower_multiplicity = 0);\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We optimize:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"optimize!(model)","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"The final dual bound is:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"db1 = objective_bound(model)","category":"page"},{"location":"start/cuts/#Strengthen-with-valid-inequalities","page":"Valid inequalities","title":"Strengthen with valid inequalities","text":"","category":"section"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Let H be the set of configurations of open machines (h[m] = 1 if machine m open; 0 otherwise) such that all jobs can be assigned : sum(h'Q) >= sum(w) i.e. the total capacity of the open machines must exceed the total weight of the jobs.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"H = Vector{Int}[]\nfor h in digits.(1:(2^length(M) - 1), base=2, pad=length(M))\n    if sum(h'Q) >= sum(w)\n        push!(H, h)\n    end\nend\nH","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Let ȳ be the solution to the linear relaxation of the problem. Let us try to express ȳ as a linear expression of the configurations. If ȳ ∈ conv H, we can derive a cut because the optimal integer solution to the problem use one of the configuration of H.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We need MathOptInterface to define the cut callback:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"using MathOptInterface","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"The separation algorithm looks for the non-negative coefficients χ[k], k = 1:length(H),  : max sum(χ[k] for k in 1:length(H)) such that sum(χ[k]* h for (k,h) in enumerate(H)) <= ̄ȳ. If the objective value is less than 1, we must add a cut.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Since the separation algorithm is a linear program, strong dualities applies. So we seperate these cuts with the dual.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"fc_sep_m = Model(GLPK.Optimizer)\n@variable(fc_sep_m, ψ[m in M] >= 0) # one variable for each constraint\n@constraint(fc_sep_m, config_dual[h in H], ψ'h >= 1) # one constraint for each χ[k]\nMathOptInterface.set(fc_sep_m, MathOptInterface.Silent(), true)","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"The objective is min ȳ'ψ = sum(χ[k] for k in 1:length(H)). Let ψ* be an optimal solution to the dual. If ȳ'ψ* < 1, then ψ*'y >= 1 is a valid inequality.","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"function fenchel_cuts_separation(cbdata)\n    println(\"Fenchel cuts separation callback...\")\n    ȳ = [callback_value(cbdata, y[m]) for m in M_axis]\n    @objective(fc_sep_m, Min, ȳ'ψ) # update objective\n    optimize!(fc_sep_m)\n    if objective_value(fc_sep_m) < 1\n        con = @build_constraint(value.(ψ)'y >= 1) # valid inequality.\n        MathOptInterface.submit(model, MathOptInterface.UserCut(cbdata), con)\n    end\nend\n\nMathOptInterface.set(model, MathOptInterface.UserCutCallback(), fenchel_cuts_separation);\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"We optimize:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"optimize!(model)","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"Valid inequalities significantly improve the previous dual bound:","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"db2 = objective_bound(model)\n\n\ndb2","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"","category":"page"},{"location":"start/cuts/","page":"Valid inequalities","title":"Valid inequalities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/config/#Coluna-Configuration","page":"Configuration","title":"Coluna Configuration","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#Raw-Parameters","page":"Configuration","title":"Raw Parameters","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#params","page":"Configuration","title":"params","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = Coluna\nDocTestSetup = quote\n    using Coluna\nend","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"Params","category":"page"},{"location":"man/config/#Coluna.Params","page":"Configuration","title":"Coluna.Params","text":"Coluna.Params(\n    solver = Coluna.Algorithm.TreeSearchAlgorithm(),\n    global_art_var_cost = 10e6,\n    local_art_var_cost = 10e4\n)\n\nParameters of Coluna :\n\nsolver is the algorithm used to optimize the reformulation.\nglobal_art_var_cost is the cost of the global artificial variables in the master\nlocal_art_var_cost is the cost of the local artificial variables in the master\n\n\n\n\n\n","category":"type"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/config/#default_optimizer","page":"Configuration","title":"default_optimizer","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#Other-Supported-Parameters","page":"Configuration","title":"Other Supported Parameters","text":"","category":"section"},{"location":"man/config/#From-BlockDecomposition","page":"Configuration","title":"From BlockDecomposition","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = BlockDecomposition\nDocTestSetup = quote\n    using BlockDecomposition\nend","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"objectiveprimalbound!\nobjectivedualbound!","category":"page"},{"location":"man/config/#BlockDecomposition.objectiveprimalbound!","page":"Configuration","title":"BlockDecomposition.objectiveprimalbound!","text":"objectiveprimalbound!(model, pb)\n\nDefine a primal bound on the optimal objective value  (upper bound for a minimisation, lower bound for a maximisation).\n\n\n\n\n\n","category":"function"},{"location":"man/config/#BlockDecomposition.objectivedualbound!","page":"Configuration","title":"BlockDecomposition.objectivedualbound!","text":"objectivedualbound!(model, db)\n\nDefine a dual bound on the optimal objective value. (lower bound for a minimisation, upper bound for a maximisation)\n\n\n\n\n\n","category":"function"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/config/#From-MathOptInterface","page":"Configuration","title":"From MathOptInterface","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"    CurrentModule = Coluna.Algorithm\n    DocTestSetup = quote\n        using Coluna.Algorithm\n    end","category":"page"},{"location":"api/algorithm/#Algorithm-API","page":"Algorithm API","title":"Algorithm API","text":"","category":"section"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"danger: Danger\nThis is WIP. The API will change in future releases.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"An algorithm is a procedure that given a model and and input performs some operations and  returns an output.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"run!","category":"page"},{"location":"api/algorithm/#Coluna.Algorithm.run!","page":"Algorithm API","title":"Coluna.Algorithm.run!","text":"run!(algo::AbstractAlgorithm, env, model, input)\n\nRuns an algorithm. \n\n\n\n\n\n","category":"function"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"Parameters of an algorithm may contain its child algorithms which used by it. Therefore,  the algoirthm tree is formed, in which the root is the algorithm called to solver the model  (root algorithm should be an optimization algorithm, see below). ","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"TODO: explain why the parent algorithm must manage the records/storages of child algorithm.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"Algorithms are divided into two types : \"manager algorithms\" and \"worker algorithms\".  Worker algorithms just continue the calculation. They do not store and restore units  as they suppose it is done by their master algorithms. Manager algorithms may divide  the calculation flow into parts. Therefore, they store and restore units to make sure  that their child worker algorithms have units prepared.  A worker algorithm cannot have child manager algorithms. ","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"Examples of manager algorithms : TreeSearchAlgorithm (which covers both BCP algorithm and  diving algorithm), conquer algorithms, strong branching, branching rule algorithms  (which create child nodes). Examples of worker algorithms : column generation, SolveIpForm,  SolveLpForm, cut separation, pricing algorithms, etc.","category":"page"},{"location":"api/algorithm/#Optimization-algorithms","page":"Algorithm API","title":"Optimization algorithms","text":"","category":"section"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"Optimization algorithms return an OptimizationState.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"OptimizationState","category":"page"},{"location":"api/algorithm/#Coluna.Algorithm.OptimizationState","page":"Algorithm API","title":"Coluna.Algorithm.OptimizationState","text":"OptimizationState(\n    form; \n    termination_status = OPTIMIZE_NOT_CALLED,\n    ip_primal_bound = nothing, \n    ip_dual_bound = nothing, \n    lp_primal_bound = nothing, \n    lp_dual_bound = nothing,\n    max_length_ip_primal_sols = 1, \n    max_length_lp_primal_sols = 1, \n    max_length_lp_dual_sols = 1,\n    insert_function_ip_primal_sols = bestbound!, \n    insert_function_lp_primal_sols = bestbound!, \n    insert_function_lp_dual_sols = bestbound!\n)\n\nA convenient structure to maintain and return solutions and bounds of a formulation form during an optimization process. The termination status is OPTIMIZE_NOT_CALLED by default. You can define the initial incumbent bounds using ip_primal_bound, ip_dual_bound, lp_primal_bound, and lp_primal_bound keyword arguments. Incumbent bounds are set to infinite (according to formulation objective sense) by default. You can store three types of solutions ip_primal_sols, lp_primal_sols, and lp_dual_sols. These solutions are stored in three lists. Keywords max_length_ip_primal_sols, max_length_lp_primal_sols, and max_length_lp_dual_sols let you define the maximum size of the lists. Keywords insert_function_ip_primal_sols, insert_function_lp_primal_sols, and insert_function_lp_dual_sols let you provide a function to define the way you want to insert a new solution in each list. By default, lists are sorted by best bound.\n\nYou can also create an OptimizationState from another one : \n\nOptimizationState(\n    form, source_state, copy_ip_primal_sol, copy_lp_primal_sol\n)\n\nIt copies the termination status, all the bounds of source_state. If copies the best IP primal solution when copy_ip_primal_sol equals true and the best LP primal solution when copy_lp_primal_sol equals true.\n\n\n\n\n\n","category":"type"},{"location":"api/algorithm/#Conventions","page":"Algorithm API","title":"Conventions","text":"","category":"section"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"TODO: WIP","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"infeasible: infinite bounds, no solution, infeasible termination status.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/api/treesearch.jl\"","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"api/treesearch/#Tree-search-API","page":"Tree Search","title":"Tree search API","text":"","category":"section"},{"location":"api/treesearch/#Introduction","page":"Tree Search","title":"Introduction","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"This is a test (and also a tutorial) on how to use the tree search interface together with algorithms.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We define the dependencies:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"using Coluna, Parameters;\nnothing #hide","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"and some shortcuts for the sake of brievity:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"const ClA = Coluna.Algorithm;\nconst ClB = Coluna.ColunaBase;\nnothing #hide","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We consider a minimization problem with four binary variables. Costs of the variable are [-1, 1, 1, 1]. The problem has no additional constraints. Therefore, the optimal solution is [1, 0, 0, 0].","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Let's define a data structure that will maintain the formulation of the problem. Vector var_costs contains the costs of the variables. Vector var_domains contains the lower and upper bounds (in a tuple) of the variables.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"const NB_VARIABLES_ = 4\n\nstruct Formulation <: ClB.AbstractModel\n    var_costs::Vector{Int}\n    var_domains::Vector{Tuple{Int,Int}}\n    Formulation() = new([-1, 1, 1, 1], fill((0,1), NB_VARIABLES_))\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We are going to enumerate all possible values for the two first variables using a binary tree :","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"depth 0: branch on first variable\ndepth 1: branch on second variable","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"When the two first variables are fixed, we dive to fix the third and the fourth variables to zero.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"At the end, the tree will look like:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"<div class=\"mermaid\">\n graph TD\n   A0(root node) -->|x1 >= 1| A1\n \t A0 -->|x1 <= 0| B1\n\t A1 -->|x2 <= 0| A2\n\t A1 -->|x2 >= 1| B2\n\t B1 -->|x2 <= 0| C2\n\t B1 -->|x2 >= 1| D2\n\t A2 -->|x3 == 0| A3\n\t B2 -->|x3 == 0| B3\n\t C2 -->|x3 == 0| C3\n\t D2 -->|x3 == 0| D3\n\t A3 -->|x4 == 0| A4\n\t B3 -->|x4 == 0| B4\n\t C3 -->|x4 == 0| C4\n\t D3 -->|x4 == 0| D4\n\t style A3 stroke:red\n\t style A4 stroke:red\n\t style B3 stroke:red\n\t style B4 stroke:red\n\t style C3 stroke:red\n\t style C4 stroke:red\n\t style D3 stroke:red\n\t style D4 stroke:red\n</div>","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"The nodes in blue are explored by a binary tree algorithm. The nodes in red are explored by a diving algorithm.","category":"page"},{"location":"api/treesearch/#Implementing-tree-search-data-structures","page":"Tree Search","title":"Implementing tree search data structures","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Now, we define the two concepts we'll use in the tree search algorithms: the node and the search space. The third concept is the explore strategy and implemented in Coluna.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We start by defining the node. Take a look at the API section to see the list of methods you need to implement.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"struct Node <: ClA.AbstractNode\n    depth::Int\n    solution::Vector{Float64}\n    var_lbs::Vector{Int}\n    var_ubs::Vector{Int}\n    parent::Union{Nothing, Node}\n\n    # The constructor just build the solution.\n    function Node(\n        parent::Union{Nothing, Node} = nothing,\n        var_index::Union{Nothing,Int} = nothing,\n        var_value::Union{Nothing,Real} = 0\n    )\n        @assert isnothing(var_index) || 1 <= var_index <= NB_VARIABLES_\n        depth = isnothing(parent) ? 0 : parent.depth + 1\n        # Store the solution at this node.\n        solution = if isnothing(parent)\n            fill(0.5, NB_VARIABLES_)\n        else\n            sol = copy(parent.solution)\n            if !isnothing(var_index)\n                sol[var_index] = var_value\n            end\n            sol\n        end\n        # Store the state of the formulation.\n        var_lbs = map(var_val -> var_val == 0.5 ? 0 : var_val, solution)\n        var_ubs = map(var_val -> var_val == 0.5 ? 1 : var_val, solution)\n        return new(\n            depth,\n            solution,\n            var_lbs,\n            var_ubs,\n            parent\n        )\n    end\nend\n\nClA.get_root(node::Node) = isnothing(node.parent) ? node : ClA.root(node.parent)\nClA.get_parent(node::Node) = node.parent","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Then, we define the search spaces. Take a look at the API section to see the list of methods you need to implement.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"const LOG_ = true;\nnothing #hide","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Every tree search algorithm must be associated to a search space.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"So here, we'll implement two search spaces. One for the binary tree and another for the diving.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Let's start with the search space of the binary tree algorithm.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"mutable struct BtSearchSpace <: ClA.AbstractColunaSearchSpace\n    formulation::Formulation\n    cost_of_best_solution::Float64\n    conquer_alg\n    divide_alg\n    previous::Union{Node,Nothing}\n    BtSearchSpace(form, conquer, divide) = new(form, Inf, conquer, divide, nothing)\nend\n\nClA.get_reformulation(sp::BtSearchSpace) = sp.formulation\nClA.get_conquer(sp::BtSearchSpace) = sp.conquer_alg\nClA.get_divide(sp::BtSearchSpace) = sp.divide_alg\nClA.get_previous(sp::BtSearchSpace) = sp.previous\nClA.set_previous!(sp::BtSearchSpace, previous) = sp.previous = previous\nClA.stop(sp::BtSearchSpace, _) = false","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Then, we implement the search space of the diving.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"mutable struct DivingSearchSpace <: ClA.AbstractColunaSearchSpace\n    formulation::Formulation\n    starting_node_in_bt::ClA.AbstractNode # change node\n    cost_of_best_solution::Float64\n    conquer_alg\n    divide_alg\n    previous\n    DivingSearchSpace(form, node, conquer, divide) = new(form, node, Inf, conquer, divide, nothing)\nend\n\nClA.get_reformulation(sp::DivingSearchSpace) = sp.formulation\nClA.get_conquer(sp::DivingSearchSpace) = sp.conquer_alg\nClA.get_divide(sp::DivingSearchSpace) = sp.divide_alg\nClA.get_previous(sp::DivingSearchSpace) = sp.previous\nClA.set_previous!(sp::DivingSearchSpace, previous) = sp.previous = previous\nClA.stop(sp::DivingSearchSpace, _) = false","category":"page"},{"location":"api/treesearch/#Writing-algorithms","page":"Tree Search","title":"Writing algorithms","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Let's define the algorithm that we will use.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"At each node, we define an algorithm ComputeSolCost that compute the cost of the solution and returns its value.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct ComputeSolCost <: ClA.AbstractAlgorithm\n    log::String = \"compute solution cost\"\nend\n\nstruct ComputeSolCostInput\n    current_node::Node\nend\n\nfunction ClA.run!(algo::ComputeSolCost, env, model::Formulation, input::ComputeSolCostInput)\n    LOG_ && println(\"== $(algo.log) ==\")\n    LOG_ && @show model.var_domains\n    sol_cost = 0.0\n    for (cost, (ub, lb)) in Iterators.zip(model.var_costs, model.var_domains)\n        var_val = ub == lb ? ub : 0.5\n        sol_cost += var_val * cost\n    end\n    return sol_cost\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"To generate, the children, we create an algorithm named Divide that will create, for a given variable x, both branches x <= 0 & x >= 1 or only branch x = 0 depending on parameters chosen.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct Divide <: ClA.AbstractAlgorithm\n    log::String = \"classic divide\"\n    create_both_branches::Bool = true\nend\n\nstruct DivideInput\n    current_node::Node\nend\n\nfunction ClA.run!(algo::Divide, env, ::Formulation, input::DivideInput)\n    LOG_ && println(algo.log)\n    parent = input.current_node\n    if algo.create_both_branches && parent.depth < 2\n        var_pos_to_branch_in = parent.depth + 1\n        var_pos_to_branch_in > 4 && return []\n        LOG_ && println(\"** branch on x$(var_pos_to_branch_in) == 0 & x$(var_pos_to_branch_in) == 1\")\n        return [(var_pos_to_branch_in, 0), (var_pos_to_branch_in, 1)]\n    elseif !algo.create_both_branches\n        var_pos_to_branch_in = parent.depth\n        var_pos_to_branch_in > 4 && return []\n        LOG_ && println(\"** branch on x$(var_pos_to_branch_in) == 0\")\n        return [(var_pos_to_branch_in, 0)]\n    end\n    return []\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"The diving is a tree search algorithm that uses:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ComputeSolCost as conquer strategy\nDivide with parameter create_both_branches equals to false as divide strategy\nColuna.Algorithm.DepthFirstStrategy as explore strategy","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct Diving <: ClA.AbstractAlgorithm\n    conqueralg = ComputeSolCost(log=\"compute solution cost of Diving tree\")\n    dividealg = Divide(\n        log = \"divide for diving\",\n        create_both_branches = false\n    )\n    explore = ClA.DepthFirstStrategy()\nend\n\nstruct DivingInput\n    starting_node_in_parent_algorithm\nend\n\nfunction ClA.run!(algo::Diving, env, model::Formulation, input::DivingInput)\n    LOG_ && println(\"~~~~~~~~ Diving starts ~~~~~~~~\")\n    diving_space = ClA.new_space(ClA.search_space_type(algo), algo, model, input)\n    output = ClA.tree_search(algo.explore, diving_space, env, input)\n    LOG_ && println(\"~~~~~~~~ end of Diving ~~~~~~~~\")\n    return output\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We define the algorithm that will conquer each node of the binary tree algorithm. It runs the ComputeSolCost algorithm and then the diving algorithm if the two first variables have been fixed (i.e. if depth == 2).","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct BtConquer <: ClA.AbstractAlgorithm\n    compute = ComputeSolCost(log = \"compute solution cost for Binary tree\")\n    heuristic = Diving()\nend\n\nfunction ClA.run!(algo::BtConquer, env, model, input)\n    output = ClA.run!(algo.compute, env, model, input)\n    diving_output = Inf\n    if input.current_node.depth == 2\n        diving_input = DivingInput(input.current_node) # TODO: needs an interface or specific to the algorithm ?\n        diving_output = ClA.run!(algo.heuristic, env, model, diving_input)\n    end\n    return min(output, diving_output)\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"The binary tree algorithm is a tree search algorithm that uses:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"BtConquer as conquer strategy\nDivide with parameter create_both_branches equals to false as divide strategy\nColuna.Algorithm.DepthFirstStrategy as explore strategy","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"@with_kw struct BinaryTree <: ClA.AbstractAlgorithm\n    conqueralg = BtConquer()\n    dividealg = Divide()\n    explore = ClA.DepthFirstStrategy()\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Look at how we call the generic tree search implementation.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"function ClA.run!(algo::BinaryTree, env, reform, input)\n    search_space = ClA.new_space(ClA.search_space_type(algo), algo, reform, input)\n    return ClA.tree_search(algo.explore, search_space, env, input)\nend","category":"page"},{"location":"api/treesearch/#Implementing-tree-search-interface","page":"Tree Search","title":"Implementing tree search interface","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"First, we indicate the type of search space used by our algorithms. Note that the type of the search space can depends on the configuration of the algorithm. So there is a 1-to-n relation between tree search algorithm configurations and search space. because one search space can be used by several tree search algorithms configuration.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.search_space_type(::BinaryTree) = BtSearchSpace\nClA.search_space_type(::Diving) = DivingSearchSpace","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Now, we implement the method that calls the constructor of a search space. The type of the search space is known from above method. A search space may receive information from the tree-search algorithm. The model, and input arguments are the same than those received by the tree search algorithm.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.new_space(::Type{BtSearchSpace}, alg, model, input) =\n    BtSearchSpace(model, alg.conqueralg, alg.dividealg)\nClA.new_space(::Type{DivingSearchSpace}, alg, model, input) =\n    DivingSearchSpace(model, input.starting_node_in_parent_algorithm, alg.conqueralg, alg.dividealg)","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We implement the method that returns the root node. The definition of the root node depends on the search space.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.new_root(::BtSearchSpace, input) = Node()\nClA.new_root(space::DivingSearchSpace, input) =\n    Node(space.starting_node_in_bt)","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Then, we implement the method that converts the branching rules into nodes for the tree search algorithm.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"function ClA.new_children(::ClA.AbstractColunaSearchSpace, branches, node::Node)\n    children = Node[]\n    for (var_pos, var_val_fixed) in branches\n        child = Node(node, var_pos, var_val_fixed)\n        push!(children, child)\n    end\n    return children\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We implement the node_change method to update the search space called by the tree search algorithm just after it finishes to evaluate a node and chooses the next one. Be careful, this method is not called after the evaluation of a node when there is no more unevaluated nodes (i.e. tree exploration is finished).","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"There are two ways to store the state of a formulation at a given node. We can distribute information across the nodes or store the whole state at each node. We follow the second way (so we don't need previous).","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"function ClA.node_change!(::Node, next::Node, space::ClA.AbstractColunaSearchSpace, _)\n    for (var_pos, bounds) in enumerate(Iterators.zip(next.var_lbs, next.var_ubs))\n       space.formulation.var_domains[var_pos] = bounds\n    end\n    return\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Method after_conquer is a callback to do some operations after the conquer of a node and before the divide. Here, we update the best solution found after the conquer algorithm. We implement one method for each search space.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"function ClA.after_conquer!(space::BtSearchSpace, current, output)\n    if output < space.cost_of_best_solution\n        space.cost_of_best_solution = output\n    end\n    return\nend\n\nfunction ClA.after_conquer!(space::DivingSearchSpace, current, output)\n    if output < space.cost_of_best_solution\n        space.cost_of_best_solution = output\n    end\n    return\nend","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We implement getters to retrieve the input from the search space and the node. The input is passed to the conquer and the divide algorithms.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.get_input(::BtConquer, space::BtSearchSpace, node::Node) =\n    ComputeSolCostInput(node)\nClA.get_input(::Divide, space::BtSearchSpace, node::Node) =\n    DivideInput(node)\nClA.get_input(::ComputeSolCost, space::DivingSearchSpace, node::Node) =\n    ComputeSolCostInput(node)\nClA.get_input(::Divide, space::DivingSearchSpace, node::Node) =\n    DivideInput(node)","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"At last, we implement methods that will return the output of the tree search algorithms. We return the cost of the best solution found. We write one method for each search space.","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"ClA.tree_search_output(space::BtSearchSpace, _) = space.cost_of_best_solution\nClA.tree_search_output(space::DivingSearchSpace, _) = space.cost_of_best_solution","category":"page"},{"location":"api/treesearch/#Run-the-example","page":"Tree Search","title":"Run the example","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"We run our tree search algorithm:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"env = nothing\nmodel = Formulation()\ninput = nothing\n\noutput = ClA.run!(BinaryTree(), env, model, input)\n@show output","category":"page"},{"location":"api/treesearch/#API","page":"Tree Search","title":"API","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"api/treesearch/#Search-space","page":"Tree Search","title":"Search space","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"AbstractSearchSpace\nsearch_space_type\nnew_space","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractSearchSpace","page":"Tree Search","title":"Coluna.Algorithm.AbstractSearchSpace","text":"Contains the definition of the problem tackled by the tree search algorithm and how the nodes and transitions of the tree search space will be explored.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.Algorithm.search_space_type","page":"Tree Search","title":"Coluna.Algorithm.search_space_type","text":"Returns the type of search space depending on the tree-search algorithm and its parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.new_space","page":"Tree Search","title":"Coluna.Algorithm.new_space","text":"Creates and returns the search space of a tree search algorithm, its model, and its input.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Node","page":"Tree Search","title":"Node","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"AbstractNode\nnew_root\nget_root\nget_parent\nget_priority","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractNode","page":"Tree Search","title":"Coluna.Algorithm.AbstractNode","text":"A subspace obtained by successive divisions of the search space.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.Algorithm.new_root","page":"Tree Search","title":"Coluna.Algorithm.new_root","text":"Creates and returns the root node of a search space.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_root","page":"Tree Search","title":"Coluna.Algorithm.get_root","text":"Returns the root node of the tree to which the node belongs.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_priority","page":"Tree Search","title":"Coluna.Algorithm.get_priority","text":"Returns the priority of the node depending on the explore strategy.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"Additional methods needed for Coluna's algorithms:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"get_opt_state\nget_records\nget_branch_description\nisroot","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.get_opt_state","page":"Tree Search","title":"Coluna.Algorithm.get_opt_state","text":"Returns an OptimizationState that contains best bounds and solutions at the node.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_records","page":"Tree Search","title":"Coluna.Algorithm.get_records","text":"Returns a Records that allows to restore the state of the formulation at this node.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_branch_description","page":"Tree Search","title":"Coluna.Algorithm.get_branch_description","text":"Returns a String to display the branching constraint.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.isroot","page":"Tree Search","title":"Coluna.Algorithm.isroot","text":"Returns true is the node is root; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Tree-search-algorithm","page":"Tree Search","title":"Tree search algorithm","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"AbstractExploreStrategy\ntree_search\nchildren\nstop\ntree_search_output","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractExploreStrategy","page":"Tree Search","title":"Coluna.Algorithm.AbstractExploreStrategy","text":"Algorithm that chooses next node to evaluated in the tree search algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.Algorithm.tree_search","page":"Tree Search","title":"Coluna.Algorithm.tree_search","text":"Generic implementation of the tree search algorithm for a given explore strategy.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.children","page":"Tree Search","title":"Coluna.Algorithm.children","text":"Evaluate and generate children. This method has a specific implementation for Coluna.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.stop","page":"Tree Search","title":"Coluna.Algorithm.stop","text":"Returns true if stopping criteria are met; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.tree_search_output","page":"Tree Search","title":"Coluna.Algorithm.tree_search_output","text":"Returns the output of the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Tree-search-algorithm-for-Coluna","page":"Tree Search","title":"Tree search algorithm for Coluna","text":"","category":"section"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"AbstractColunaSearchSpace","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractColunaSearchSpace","page":"Tree Search","title":"Coluna.Algorithm.AbstractColunaSearchSpace","text":"Search space for tree search algorithms in Coluna.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"The children method has a specific implementation for AbstractColunaSearchSpace` that involves following methods:","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"get_previous\nset_previous!\nnode_change!\nget_divide\nget_reformulation\nget_input\nafter_conquer!\nnew_children","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.get_previous","page":"Tree Search","title":"Coluna.Algorithm.get_previous","text":"Returns the previous node explored by the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.set_previous!","page":"Tree Search","title":"Coluna.Algorithm.set_previous!","text":"Sets the previous node explored by the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.node_change!","page":"Tree Search","title":"Coluna.Algorithm.node_change!","text":"Methods to perform operations before the tree search algorithm evaluates a node (current). This is useful to restore the state of the formulation for instance.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_divide","page":"Tree Search","title":"Coluna.Algorithm.get_divide","text":"Returns the divide algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_reformulation","page":"Tree Search","title":"Coluna.Algorithm.get_reformulation","text":"Returns the reformulation that will be passed to an algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_input","page":"Tree Search","title":"Coluna.Algorithm.get_input","text":"Returns the input that will be passed to an algorithm. The input can be built from information contained in a search space and a node.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.after_conquer!","page":"Tree Search","title":"Coluna.Algorithm.after_conquer!","text":"Methods to perform operations after the conquer algorithms. It receives the output of the conquer algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.new_children","page":"Tree Search","title":"Coluna.Algorithm.new_children","text":"Creates and returns the children of a node associated to a search space.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"","category":"page"},{"location":"api/treesearch/","page":"Tree Search","title":"Tree Search","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/pricing.jl\"","category":"page"},{"location":"start/pricing/#Pricing-callback","page":"Pricing callback","title":"Pricing callback","text":"","category":"section"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback let you define how to solve the subproblems of a Dantzig-Wolfe decomposition to generate a new entering column in the master program. This callback is useful when you know an efficient algorithm to solve the subproblems, i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"First, we load the packages and define aliases :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"using Coluna, BlockDecomposition, JuMP, MathOptInterface, GLPK;\nconst BD = BlockDecomposition;\nconst MOI = MathOptInterface;\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"Let us see an example with the following generalized assignment problem :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"M = 1:3;\nJ = 1:15;\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5; 19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7; 13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2];\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91;91 81 66 63 59 81 87 90 65 55 57 68 92 91 86; 62 79 73 60 75 66 68 99 69 60 56 100 67 68 54];\nQ = [1020 1460 1530];\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"with the following Coluna configuration","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"for which the JuMP model takes the form:","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"model = BlockModel(coluna);\n\n@axis(M_axis, M);\n\n@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m,j] for m in M_axis) == 1);\n@objective(model, Min, sum(c[m,j]*x[m,j] for m in M_axis, j in J));\n@dantzig_wolfe_decomposition(model, dwdec, M_axis);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"where, as you can see, we omitted the knapsack constraints. These constraints are implicitly defined by the algorithm called in the pricing callback.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"Let's use a knapsack algorithm defined by the following function to solve the knapsack subproblems:","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"function solve_knapsack(cost, weight, capacity)\n    sp_model = Model(GLPK.Optimizer)\n    items = 1:length(weight)\n    @variable(sp_model, x[i in items], Bin)\n    @constraint(sp_model, weight' * x <= capacity)\n    @objective(sp_model, Min, cost' * x)\n    optimize!(sp_model)\n    x_val = value.(x)\n    return filter(i -> x_val[i] ≈ 1, collect(items))\nend","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"You can replace the content of the function by any algorithm that solves the knapsack problem (such as algorithms provided by the unregistered package Knapsacks).","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with Coluna within the pricing callback.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"function my_pricing_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M_axis)\n    cur_machine = BD.callback_spid(cbdata, model)\n\n    # Uncomment to see that the pricing callback is called.\n    # println(\"Pricing callback for machine $(cur_machine).\")\n\n    # Retrieve reduced costs of subproblem variables\n    red_costs = [BD.callback_reduced_cost(cbdata, x[cur_machine, j]) for j in J]\n\n    # Run the knapsack algorithm\n    jobs_assigned_to_cur_machine = solve_knapsack(red_costs, w[cur_machine, :], Q[cur_machine])\n\n    # Create the solution (send only variables with non-zero values)\n    sol_vars = [x[cur_machine, j] for j in jobs_assigned_to_cur_machine]\n    sol_vals = [1.0 for _ in jobs_assigned_to_cur_machine]\n    sol_cost = sum(red_costs[j] for j in jobs_assigned_to_cur_machine)\n\n    # Submit the solution to the subproblem to Coluna\n    MOI.submit(model, BD.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)\n\n    # Submit the dual bound to the solution of the subproblem\n    # This bound is used to compute the contribution of the subproblem to the lagrangian\n    # bound in column generation.\n    MOI.submit(model, BD.PricingDualBound(cbdata), sol_cost) # optimal solution\n    return\nend","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback is provided to Coluna using the keyword solver in the method specify!.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"subproblems = BD.getsubproblems(dwdec);\nBD.specify!.(subproblems, lower_multiplicity = 0, solver = my_pricing_callback);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"You can then optimize :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"optimize!(model);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"and retrieve information you need as usual :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"objective_value(model)","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"EditURL = \"https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/initial_columns.jl\"","category":"page"},{"location":"start/initial_columns/#Initial-columns","page":"Initial columns callback","title":"Initial columns","text":"","category":"section"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"The initial columns callback let you provide initial columns associated to each problem ahead the optimization. This callback is useful when you have an efficient heuristic that finds feasible solutions to the problem. You can then extract columns from the solutions and give them to Coluna through the callback. You have to make sure the columns you provide are feasible because Coluna won't check their feasibility. The cost of the columns will be computed using the perennial cost of subproblem variables.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"Let us see an example with the following generalized assignment problem :","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"M = 1:3;\nJ = 1:5;\nc = [1 1 1 1 1; 1.2 1.2 1.1 1.1 1; 1.3 1.3 1.1 1.2 1.4];\nQ = [3, 2, 3];\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"with the following Coluna configuration","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"using JuMP, GLPK, BlockDecomposition, Coluna;\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default branch-cut-and-price\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"for which the JuMP model takes the form:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"@axis(M_axis, M);\nmodel = BlockModel(coluna);\n\n@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M_axis) >= 1);\n@constraint(model, knp[m in M_axis], sum(x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M_axis, j in J));\n\n@dantzig_wolfe_decomposition(model, decomposition, M_axis)\n\nsubproblems = getsubproblems(decomposition)\nspecify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"Let's consider that the following assignement patterns are good candidates:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"machine1 = [[1,2,4], [1,3,4], [2,3,4], [2,3,5]];\nmachine2 = [[1,2], [1,5], [2,5], [3,4]];\nmachine3 = [[1,2,3], [1,3,4], [1,3,5], [2,3,4]];\n\ninitial_columns = [machine1, machine2, machine3];\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"We can write the initial columns callback:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"function initial_columns_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M_axis)\n    spid = BlockDecomposition.callback_spid(cbdata, model)\n    println(\"initial columns callback $spid\")\n\n    # Retrieve assignment patterns of a given machine\n    for col in initial_columns[spid]\n        # Create the column in the good representation\n        vars = [x[spid, j] for j in col]\n        vals = [1.0 for _ in col]\n\n        # Submit the column\n        MOI.submit(model, BlockDecomposition.InitialColumn(cbdata), vars, vals)\n    end\nend","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"The initial columns callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with Coluna within the callback.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"We provide the initial columns callback to Coluna through the following method:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"MOI.set(model, BlockDecomposition.InitialColumnsCallback(), initial_columns_callback)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"You can then optimize:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"optimize!(model)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callbacks are functions defined by the user that allow him to take over part of the default algorithm. The more classical callbacks in a branch-and-price solver are:","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Pricing callback that takes over the procedure to determine whether the current master LP   solution is optimum or produces an entering variable with negative reduced cost by solving subproblems\nSeparation callback that takes over the procedure to determine whether the current master   LP solution is feasible or produces a valid problem constraint that is violated\nBranching callback that takes over the procedure to determine whether the current master   LP solution is integer or produces a valid branching disjunctive constraint that rules out   the current fractional solution.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"note: Note\nYou can't change the original formulation in a callback because Coluna does not propagate the changes into the reformulation and does not check if solutions found are still feasible.","category":"page"},{"location":"man/callbacks/#Pricing-callback","page":"Callbacks","title":"Pricing callback","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"The pricing callback let you define how to solve the subproblems of a Dantzig-Wolfe decomposition to generate a new entering column in the master program. This callback is useful when you know an efficient algorithm to solve the subproblems, i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"See the example in the manual Pricing callback.","category":"page"},{"location":"man/callbacks/#Errors-and-Warnings","page":"Callbacks","title":"Errors and Warnings","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Algorithm.IncorrectPricingDualBound\nAlgorithm.MissingPricingDualBound\nAlgorithm.MultiplePricingDualBounds","category":"page"},{"location":"man/callbacks/#Coluna.Algorithm.IncorrectPricingDualBound","page":"Callbacks","title":"Coluna.Algorithm.IncorrectPricingDualBound","text":"IncorrectPricingDualBound\n\nError thrown when transmitting a dual bound larger than the primal bound of the  best solution to the pricing subproblem found in a run of the pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/#Coluna.Algorithm.MissingPricingDualBound","page":"Callbacks","title":"Coluna.Algorithm.MissingPricingDualBound","text":"MissingPricingDualBound\n\nError thrown when the pricing callback does not transmit any dual bound. Make sure you call MOI.submit(model, BD.PricingDualBound(cbdata), db) in your pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/#Coluna.Algorithm.MultiplePricingDualBounds","page":"Callbacks","title":"Coluna.Algorithm.MultiplePricingDualBounds","text":"MultiplePricingDualBounds\n\nError thrown when the pricing transmits multiple dual bound. Make sure you call MOI.submit(model, BD.PricingDualBound(cbdata), db) only once in your  pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/callbacks/#Separation-callbacks","page":"Callbacks","title":"Separation callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"Separation callbacks let you define how to separate cuts or constraints.","category":"page"},{"location":"man/callbacks/#Facultative-and-essential-cuts-(user-cut-and-lazy-constraint)","page":"Callbacks","title":"Facultative & essential cuts (user cut & lazy constraint)","text":"","category":"section"},{"location":"man/callbacks/","page":"Callbacks","title":"Callbacks","text":"This callback allows you to add cuts to the master problem. The cuts must be expressed in terms of the original variables. Then, Coluna expresses them over the master variables. You can find an example of essential cut separation and facultative cut separation in the JuMP documentation.","category":"page"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"man/algorithm/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"TODO : Description of how algorithms work.","category":"page"},{"location":"man/algorithm/#Tree-search-algorithm-(branch-and-bound)","page":"Algorithms","title":"Tree search algorithm (branch-and-bound)","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"TreeSearchAlgorithm","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.TreeSearchAlgorithm","page":"Algorithms","title":"Coluna.Algorithm.TreeSearchAlgorithm","text":"Coluna.Algorithm.TreeSearchAlgorithm(\n    conqueralg::AbstractConquerAlgorithm = ColCutGenConquer(),\n    dividealg::AbstractDivideAlgorithm = Branching(),\n    explorestrategy::AbstractExploreStrategy = DepthFirstStrategy(),\n    maxnumnodes = 100000,\n    opennodeslimit = 100,\n    timelimit = -1, # -1 means no time limit\n    opt_atol::Float64 = DEF_OPTIMALITY_ATOL,\n    opt_rtol::Float64 = DEF_OPTIMALITY_RTOL,\n    branchingtreefile = \"\"\n)\n\nThis algorithm is a branch and bound that uses a search tree to optimize the reformulation. At each node in the tree, it applies conqueralg to evaluate the node and improve the bounds,  dividealg to generate branching constraints, and explorestrategy to select the next node to treat.\n\nParameters : \n\nmaxnumnodes : maximum number of nodes explored by the algorithm\nopennodeslimit : maximum number of nodes waiting to be explored\ntimelimit : time limit in seconds of the algorithm\nopt_atol : optimality absolute tolerance (alpha)\nopt_rtol : optimality relative tolerance (alpha)\n\nOptions :\n\nbranchingtreefile : name of the file in which the algorithm writes an overview of the branching tree\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Conquer-algorithm","page":"Algorithms","title":"Conquer algorithm","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"ColCutGenConquer","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.ColCutGenConquer","page":"Algorithms","title":"Coluna.Algorithm.ColCutGenConquer","text":"Coluna.Algorithm.ColCutGenConquer(\n    stages = ColumnGeneration[ColumnGeneration()],\n    primal_heuristics = ParameterizedHeuristic[ParamRestrictedMasterHeuristic()],\n    cutgen = CutCallbacks(),\n    max_nb_cut_rounds = 3\n)\n\nColumn-and-cut-generation based algorithm to find primal and dual bounds for a  problem decomposed using Dantzig-Wolfe paradigm.\n\nThis algorithm applies a set of column generation algorithms whose definitions are stored in stages. These algorithms are called in the reverse order of vector stages. So usually, the first stage is the one with exact pricing, and other stages use heuristic pricing (the higher is the position of the stage,  the faster is the heuristic).\n\nThis algorithm also applies cutgen for the cut generation phase. It can apply several primal heuristics stored in primal_heuristics to more efficiently find feasible solutions.\n\nParameters :\n\nstages: column generation algorithms from the exact one to the most heuristic one\nprimal_heuristics: heuristics to find a feasible solution\ncutgen: cut generation algorithm\nmax_nb_cut_rounds : number of cut generation done by the algorithm\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"ColumnGeneration","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.ColumnGeneration","page":"Algorithms","title":"Coluna.Algorithm.ColumnGeneration","text":"Coluna.Algorithm.ColumnGeneration(\n    restr_master_solve_alg = SolveLpForm(get_dual_solution = true),\n    pricing_prob_solve_alg = SolveIpForm(\n        moi_params = MoiOptimize(\n            deactivate_artificial_vars = false,\n            enforce_integrality = false\n        )\n    ),\n    essential_cut_gen_alg = CutCallbacks(call_robust_facultative = false),\n    max_nb_iterations = 1000,\n    log_print_frequency = 1,\n    redcost_tol = 1e-4,\n    show_column_already_inserted_warning = true,\n    cleanup_threshold = 10000,\n    cleanup_ratio = 0.66,\n    smoothing_stabilization = 0.0 # should be in [0, 1],\n)\n\nColumn generation algorithm that can be applied to formulation reformulated using Dantzig-Wolfe decomposition. \n\nThis algorithm first solves the linear relaxation of the master (master LP) using restr_master_solve_alg. Then, it solves the subproblems by calling pricing_prob_solve_alg to get the columns that have the best reduced costs and that hence, may improve the master LP's objective the most.\n\nIn order for the algorithm to converge towards the optimal solution of the master LP, it suffices that the pricing oracle returns, at each iteration, a negative reduced cost solution if one exists.  The algorithm stops when all subproblems fail to generate a column with negative (positive) reduced cost in the case of a minimization (maximization) problem or when it reaches the maximum number of iterations.\n\nParameters : \n\nrestr_master_solve_alg: algorithm to optimize the master LP\npricing_prob_solve_alg: algorithm to optimize the subproblems\nessential_cut_gen_alg: algorithm to generate essential cuts which is run when the solution of the master LP is integer.\n\nOptions:\n\nmax_nb_iterations: maximum number of iterations\nlog_print_frequency: display frequency of iterations statistics\n\nUndocumented parameters are in alpha version.\n\nAbout the ouput\n\nAt each iteration (depending on log_print_frequency),  the column generation algorithm can display following statistics.\n\n<it= 90> <et=15.62> <mst= 0.02> <sp= 0.05> <cols= 4> <al= 0.00> <DB=  300.2921> <mlp=  310.3000> <PB=310.3000>\n\nHere are their meanings :\n\nit stands for the current number of iterations of the algorithm\net is the elapsed time in seconds since Coluna has started the optimisation\nmst is the time in seconds spent solving the master LP at the current iteration\nsp is the time in seconds spent solving the subproblems at the current iteration\ncols is the number of column generated by the subproblems at the current iteration\nal is the smoothing factor of the stabilisation at the current iteration (alpha version)\nDB is the dual bound of the master LP at the current iteration\nmlp is the objective value of the master LP at the current iteration\nPB is the objective value of the best primal solution found by Coluna at the current iteration\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Basic-algorithms","page":"Algorithms","title":"Basic algorithms","text":"","category":"section"},{"location":"man/algorithm/#Optimize-a-linear-program","page":"Algorithms","title":"Optimize a linear program","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"SolveLpForm","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.SolveLpForm","page":"Algorithms","title":"Coluna.Algorithm.SolveLpForm","text":"Coluna.Algorithm.SolveLpForm(\n    get_dual_solution = false,\n    relax_integrality = false,\n    get_dual_bound = false,\n    silent = true\n)\n\nSolve a linear program stored in a formulation using its first optimizer. This algorithm works only if the optimizer is interfaced with MathOptInterface.\n\nYou can define the optimizer using the default_optimizer attribute of Coluna or with the method specify! from BlockDecomposition\n\nParameters:\n\nget_dual_solution: retrieve the dual solution and store it in the ouput if equals true\nrelax_integrality: relax integer variables of the formulation before optimization if equals true\nget_dual_bound: store the dual objective value in the output if equals true\nsilent: set MOI.Silent() to its value\n\nUndocumented parameters are alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Optimize-an-mixed-integer-program-/-solve-a-combinatorial-problem","page":"Algorithms","title":"Optimize an mixed-integer program / solve a combinatorial problem","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"SolveIpForm\nMoiOptimize\nUserOptimize\nCustomOptimize","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.SolveIpForm","page":"Algorithms","title":"Coluna.Algorithm.SolveIpForm","text":"Coluna.Algorithm.SolveIpForm(\n    optimizer_id = 1\n    moi_params = MoiOptimize()\n    user_params = UserOptimize()\n    custom_params = CustomOptimize()\n)\n\nSolve an optimization problem. This algorithm can call different type of optimizers :\n\nsubsolver interfaced with MathOptInterface to optimize a mixed integer program\npricing callback defined by the user\ncustom optimizer to solve a custom model\n\nYou can specify an optimizer using the default_optimizer attribute of Coluna or with the method specify! from BlockDecomposition. If you want to define several optimizers for a given subproblem, you must use specify!:\n\nspecify!(subproblem, optimizers = [optimizer1, optimizer2, optimizer3])\n\nValue of optimizer_id is the position of the optimizer you want to use. For example, if optimizer_id is equal to 2, the algorithm will use optimizer2.\n\nBy default, the algorihm uses the first optimizer or the default optimizer if no optimizer has been specified through specify!.\n\nDepending on the type of the optimizer chosen, the algorithm will use one the  three configurations : \n\nmoi_params for subsolver interfaced with MathOptInterface\nuser_params for pricing callbacks\ncustom_params for custom solvers\n\nCustom solver is undocumented because alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.MoiOptimize","page":"Algorithms","title":"Coluna.Algorithm.MoiOptimize","text":"MoiOptimize(\n    time_limit = 600\n    deactivate_artificial_vars = false\n    enforce_integrality = false\n    get_dual_bound = true\n)\n\nConfiguration for an optimizer that calls a subsolver through MathOptInterface.\n\nParameters:\n\ntime_limit: in seconds\ndeactivate_artificial_vars: deactivate all artificial variables of the formulation if equals true\nenforce_integrality: enforce integer variables that are relaxed if equals true\nget_dual_bound: store the dual objective value in the output if equals true\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.UserOptimize","page":"Algorithms","title":"Coluna.Algorithm.UserOptimize","text":"UserOptimize(\n    max_nb_ip_primal_sols = 50\n)\n\nConfiguration for an optimizer that calls a pricing callback to solve the problem.\n\nParameters:\n\nmax_nb_ip_primal_sols: maximum number of solutions returned by the callback kept\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.CustomOptimize","page":"Algorithms","title":"Coluna.Algorithm.CustomOptimize","text":"CustomOptimize()\n\nConfiguration for an optimizer that calls a custom solver to solve a custom model.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"man/algorithm/#Divide-algorithms","page":"Algorithms","title":"Divide algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"NoBranching\nSimpleBranching\nStrongBranching","category":"page"},{"location":"man/algorithm/#Selection-criteria","page":"Algorithms","title":"Selection criteria","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"AbstractSelectionCriterion\nFirstFoundCriterion\nMostFractionalCriterion","category":"page"},{"location":"man/algorithm/#Branching-rules","page":"Algorithms","title":"Branching rules","text":"","category":"section"},{"location":"man/algorithm/","page":"Algorithms","title":"Algorithms","text":"SingleVarBranchingRule","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"danger: Danger\nColuna is under active development. Some features are undocumented because they are very experimental. Current users are expected to read the source code.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nWe assume that readers are familiar with integer programming and exact optimization methods.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a framework written in Julia to implement a decomposition approach to optimize  block-structured mixed-integer programs (MIP). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna relies on the tools of the JuMP-dev community at both ends of the problem treatment. It uses the JuMP modeling language upfront and MathOptInterface (MOI) to delegate master  and subproblems to MIP solvers. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The user introduces an original MIP that models his problem using the JuMP along our specific  extension BlockDecomposition that offers a syntax to specify the problem decomposition.  Coluna reformulates the original MIP using Dantzig-Wolfe and Benders decomposition  techniques.  Then, Coluna optimizes the reformulation using the algorithm chosen by the user.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna offers a \"black-box\" implementation of the branch-and-cut-and-price algorithm:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI). \nBlockDecomposition allows the user to provide to Coluna his decomposition of the model.   The BlockDecomposition syntax allows the user to implicilty define subsystems in the MIP on which the decomposition is based.   These subsystems are described by rows and/or columns indices.\nThe reformulation associated with the decomposition defined by the user is automatically generated by Coluna,  without requiring any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound.\nA default column (and cut) generation procedure is implemented.  It relies on underlying MOI optimizers to handle master and subproblems.   However, the user can use pricing callbacks to solve the subproblems.\nA branching scheme that preserves the pricing problem structure is offered by default;   it runs based on priorities and directives specified by the user on the original variables.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a package for Julia 1.6+.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It requires JuMP to model the problem, BlockDecomposition to define the decomposition, and a MIP solver supported by MathOptInterface to optimize the master and the subproblems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can install Coluna and its dependencies through the package manager of Julia by entering :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add Coluna","category":"page"},{"location":"#Extra-dependencies","page":"Introduction","title":"Extra dependencies","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CPLEX.jl >= 0.7.0 (cf issue 446)","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Atoptima, Mathematical Optimization Society (MOS), Région Nouvelle-Aquitaine, University of Bordeaux, and Inria","category":"page"}]
}
