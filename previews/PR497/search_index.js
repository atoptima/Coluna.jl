var documenterSearchIndex = {"docs":
[{"location":"dev/reformulation/","page":"Reformulation","title":"Reformulation","text":"CurrentModule = Coluna.MathProg\nDocTestSetup = quote\n    using Coluna.MathProg\nend","category":"page"},{"location":"dev/reformulation/#Reformulation","page":"Reformulation","title":"Reformulation","text":"","category":"section"},{"location":"dev/reformulation/","page":"Reformulation","title":"Reformulation","text":"Reformulation\ngetobjsense\ngetmaster\nadd_dw_pricing_sp!\nadd_benders_sep_sp!\nget_dw_pricing_sps\nget_benders_sep_sps\nget_dw_pricing_sp_ub_constrid\nget_dw_pricing_sp_lb_constrid","category":"page"},{"location":"dev/reformulation/#Coluna.MathProg.Reformulation","page":"Reformulation","title":"Coluna.MathProg.Reformulation","text":"Reformulation is a representation of a formulation which is solved by Coluna  using a decomposition approach.\n\nReformulation()\n\nConstruct an empty Reformulation.\n\n\n\n\n\n","category":"type"},{"location":"dev/reformulation/#Coluna.MathProg.getobjsense","page":"Reformulation","title":"Coluna.MathProg.getobjsense","text":"Returns the objective function sense of Formulation form.\n\n\n\n\n\ngetobjsense(reformulation)\n\nReturn the objective sense of the master problem of the reformulation. If the master problem has not been defined, it throws an error.\n\n\n\n\n\n","category":"function"},{"location":"dev/reformulation/#Coluna.MathProg.getmaster","page":"Reformulation","title":"Coluna.MathProg.getmaster","text":"getmaster(reformulation)\n\nReturn the formulation of the master problem.\n\n\n\n\n\n","category":"function"},{"location":"dev/reformulation/#Coluna.MathProg.add_dw_pricing_sp!","page":"Reformulation","title":"Coluna.MathProg.add_dw_pricing_sp!","text":"add_dw_pricing_sp!(reformulation, abstractmodel)\n\nAdd a Dantzig-Wolfe pricing subproblem in the reformulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/reformulation/#Coluna.MathProg.add_benders_sep_sp!","page":"Reformulation","title":"Coluna.MathProg.add_benders_sep_sp!","text":"add_benders_sep_sp!(reformulation, abstractmodel)\n\nAdd a Benders separation subproblem in the reformulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/reformulation/#Coluna.MathProg.get_dw_pricing_sps","page":"Reformulation","title":"Coluna.MathProg.get_dw_pricing_sps","text":"get_dw_pricing_sps(reformulation)\n\nReturn a Dict{FormId, AbstractModel} containing all Dabtzig-Wolfe pricing subproblems of the reformulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/reformulation/#Coluna.MathProg.get_benders_sep_sps","page":"Reformulation","title":"Coluna.MathProg.get_benders_sep_sps","text":"get_benders_sep_sps(reformulation)\n\nReturn a Dict{FormId, AbstractModel} containing all Benders separation subproblems of the reformulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/reformulation/#Coluna.MathProg.get_dw_pricing_sp_ub_constrid","page":"Reformulation","title":"Coluna.MathProg.get_dw_pricing_sp_ub_constrid","text":"get_dw_pricing_sp_ub_constrid(reformulation, spid::FormId)\n\nReturn the ConstrId of the upper bounded convexity constraint of Dantzig-Wolfe pricing subproblem with id spid.\n\n\n\n\n\n","category":"function"},{"location":"dev/reformulation/#Coluna.MathProg.get_dw_pricing_sp_lb_constrid","page":"Reformulation","title":"Coluna.MathProg.get_dw_pricing_sp_lb_constrid","text":"get_dw_pricing_sp_lb_constrid(reformulation, spid::FormId)\n\nReturn the ConstrId of the lower bounded convexity constraint of Dantzig-Wolfe pricing subproblem with id spid.\n\n\n\n\n\n","category":"function"},{"location":"dev/reformulation/","page":"Reformulation","title":"Reformulation","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"user/callbacks/#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"Callbacks are functions defined by the user that allow him to take over part of the default  algorithm.  The more classical callbacks in a branch-and-price solver are:","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"Pricing callback that takes over the procedure to determine whether the current master LP    solution is optimum or produces an entering variable with negative reduced cost\nSeparation callback that takes over the procedure to determine whether the current master   LP solution is feasible or produces a valid problem constraint that is violated\nBranching callback that takes over the procedure to determine whether the current master    LP solution is integer or produces a valid branching disjunctive constraint that rules out    the current fractional solution.","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"On this page, we use the following aliases : ","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"const BD = BlockDecomposition\nconst MOI = MathOptInterface","category":"page"},{"location":"user/callbacks/#Pricing-callback","page":"Callbacks","title":"Pricing callback","text":"","category":"section"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"The pricing callback let you define how to solve the subproblems of a Dantzig-Wolfe  decomposition to generate a new entering column in the master program.  This callback is useful when you know an efficient algorithm to solve the subproblems,  i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"Let us see an example with the generalized assignment problem for which the JuMP model takes the form:","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"model = BlockModel(optimizer)\n\n@axis(M, 1:nb_machines)\nJ = 1:nb_jobs\n\n# JuMP model\n@variable(model, x[m in M, j in J], Bin)\n@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1)\n@objective(model, Min, sum(c[m,j]*x[m,j] for m in M, j in J))\n@dantzig_wolfe_decomposition(model, dwdec, M)","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"where, as you can see, we omitted the knapsack constraints.  These constraints are implicitly defined by the algorithm called in the pricing callback.","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"Assume we have the following method that solves efficiently a knapsack problem:","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"solve_knp(job_costs, lb_jobs, ub_jobs, capacity)","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"where ","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"job_costs is an array that contains the cost of each job\nlb_jobs is an array where the j-th entry equals 1 if it is mandatory to put job j in the knapsack\nub_jobs is an array where the j-th entry equals 0 if job j cannot be put in the knapsack\ncapacity is a real that is equal to the capacity of the knapsack","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"The pricing callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with the solver within the pricing callback.","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"function my_pricing_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M)\n    cur_machine = BD.callback_spid(cbdata, model)\n\n    # Retrieve reduced costs of subproblem variables\n    red_costs = [BD.callback_reduced_cost(cbdata, x[cur_machine, j]) for j in J]\n\n    # Retrieve current bounds of subproblem variables\n    lb_x = [BD.callback_lb(cbdata, x[cur_machine, j]) for j in J]\n    ub_x = [BD.callback_ub(cbdata, x[cur_machine, j]) for j in J]\n\n    # Solve the knapsack with a custom algorithm\n    jobs_assigned_to_cur_machine = solve_knp(red_costs, lb_x, ub_x, Q[cur_machine])\n\n    # Create the solution (send only variables with non-zero values)\n    sol_vars = [x[cur_machine, j] for j in jobs_assigned_to_cur_machine]\n    sol_vals = [1.0 for j in jobs_assigned_to_cur_machine]\n    sol_cost = sum(red_costs[j] for j in jobs_assigned_to_cur_machine)\n\n    # Submit the solution to the subproblem to Coluna\n    MOI.submit(model, BD.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)\n    return\nend","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"The pricing callback is provided to Coluna using the keyword solver in the method  specify!.","category":"page"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"master = BD.getmaster(dwdec)\nsubproblems = BD.getsubproblems(dwdec)\nBD.specify!.(subproblems, lower_multiplicity = 0, solver = my_pricing_callback)","category":"page"},{"location":"user/callbacks/#Separation-callbacks","page":"Callbacks","title":"Separation callbacks","text":"","category":"section"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"Separation callbacks let you define how to separate cuts or constraints.","category":"page"},{"location":"user/callbacks/#Robust-facultative-and-essential-cuts-(user-cut-and-lazy-constraint)","page":"Callbacks","title":"Robust facultative & essential cuts (user cut & lazy constraint)","text":"","category":"section"},{"location":"user/callbacks/","page":"Callbacks","title":"Callbacks","text":"This callback allows you to add cuts to the master problem.  Example in the JuMP documentation.","category":"page"},{"location":"dev/todo/","page":"TODO","title":"TODO","text":"CurrentModule = Coluna\nDocTestSetup = quote\n    using Coluna\nend","category":"page"},{"location":"dev/todo/#References-to-classify","page":"TODO","title":"References to classify","text":"","category":"section"},{"location":"dev/todo/","page":"TODO","title":"TODO","text":"Coluna.Params\nColuna.Algorithm.OptimizationInput\nColuna.Algorithm.OptimizationOutput\nColuna.ColunaBase.gap\nColuna.ColunaBase.Solution\nColuna.ColunaBase.@exported_nestedenum\nColuna.MathProg.get_lp_dual_bound\nColuna.MathProg.ObjValues\nColuna.Algorithm.AbstractOptimizationAlgorithm\nColuna.MathProg.AbstractFormulation\nColuna.MathProg.UserOptimizer\nColuna.MathProg.Problem\nColuna.ColunaBase.TerminationStatus\nColuna.MathProg.getuid\nColuna.ColunaBase.isbetter\nColuna.MathProg.Constraint\nColuna.MathProg.Id\nColuna.Algorithm.update_ip_primal_sol!\nColuna.Algorithm.run!\nColuna.ColunaBase.printbounds\nColuna.MathProg.get_lp_primal_bound\nColuna.ColunaBase.SolutionStatus\nColuna.MathProg.lp_gap_closed\nBase.diff\nColuna.MathProg.update_ip_primal_bound!\nColuna.Algorithm.OptimizationState\nColuna.MathProg.update_lp_dual_bound!\nColuna.MathProg.getoptimizer\nColuna.MathProg.update_ip_dual_bound!\nColuna.MathProg.ip_gap_closed\nColuna.Algorithm.add_ip_primal_sol!\nColuna.ColunaBase.@nestedenum\nColuna.ColunaBase.getvalue\nColuna.ColunaBase.getsol\nColuna.ColunaBase.convert_status\nColuna.ColunaBase.getstatus\nColuna.MathProg.lp_gap\nColuna.MathProg.reset!\nColuna.MathProg.ip_gap\nColuna.MathProg.get_ip_primal_bound\nColuna.MathProg.getcoefmatrix\nColuna.MathProg.update_lp_primal_bound!\nColuna.MathProg.Variable\nColuna.MathProg.MoiOptimizer\nColuna.ColunaBase.Bound\nColuna.Algorithm.set_ip_primal_sol!\nColuna.MathProg.get_ip_dual_bound\nColuna.Algorithm.ReformData\nColuna.Algorithm.ModelData\nColuna.MathProg.get_optimization_target\nColuna.MathProg.create_formulation!","category":"page"},{"location":"dev/todo/#Coluna.Params","page":"TODO","title":"Coluna.Params","text":"Coluna.Params(\n    solver = Coluna.Algorithm.TreeSearchAlgorithm(),\n    global_art_var_cost = 10e6,\n    local_art_var_cost = 10e4\n)\n\nParameters of Coluna :\n\nsolver is the algorithm used to optimize the reformulation.\nglobal_art_var_cost is the cost of the global artificial variables in the master\nlocal_art_var_cost is the cost of the local artificial variables in the master\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.Algorithm.OptimizationInput","page":"TODO","title":"Coluna.Algorithm.OptimizationInput","text":"OptimizationInput\n\nContains OptimizationState\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.Algorithm.OptimizationOutput","page":"TODO","title":"Coluna.Algorithm.OptimizationOutput","text":"OptimizationOutput\n\nContain OptimizationState, PrimalSolution (solution to relaxation), and \nDualBound (dual bound value)\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.ColunaBase.gap","page":"TODO","title":"Coluna.ColunaBase.gap","text":"gap\n\nrelative gap. Gap is non-positive if pb reached db\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.ColunaBase.Solution","page":"TODO","title":"Coluna.ColunaBase.Solution","text":"Solution(\n    model::AbstractModel,\n    decisions::Vector,\n    values::Vector,\n    solution_values::Float64,\n    status::SolutionStatus\n)\n\nCreate a solution to the model. Other arguments are: \n\ndecisions is a vector with the index of each decision.\nvalues is a vector with the values for each decision.\nsolution_value is the value of the solution.\nstatus is the solution status.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.ColunaBase.@exported_nestedenum","page":"TODO","title":"Coluna.ColunaBase.@exported_nestedenum","text":"Create a nested enumeration and export all the items.\n\n\n\n\n\n","category":"macro"},{"location":"dev/todo/#Coluna.MathProg.get_lp_dual_bound","page":"TODO","title":"Coluna.MathProg.get_lp_dual_bound","text":"Return the best dual bound of the linear program.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.ObjValues","page":"TODO","title":"Coluna.MathProg.ObjValues","text":"ObjValues(form)\n\ntodo\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.Algorithm.AbstractOptimizationAlgorithm","page":"TODO","title":"Coluna.Algorithm.AbstractOptimizationAlgorithm","text":"AbstractOptimizationAlgorithm\n\nThis type of algorithm is used to \"bound\" a model, i.e. to improve primal\nand dual bounds of the model. Solving to optimality is a special case of \"bounding\".\nThe input of such algorithm should be of type Incumbents.    \nThe output of such algorithm should be of type OptimizationState.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.AbstractFormulation","page":"TODO","title":"Coluna.MathProg.AbstractFormulation","text":"AbstractFormulation\n\nFormulation is a mathematical representation of a problem  (model of a problem). A problem may have different formulations.  We may rename \"formulation\" to \"model\" after. Different algorithms may be applied to a formulation. A formulation should contain a dictionary of storage units used by algorithms. A formulation contains one storage unit  per storage unit type used by algorithms.    \n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.UserOptimizer","page":"TODO","title":"Coluna.MathProg.UserOptimizer","text":"UserOptimizer <: AbstractOptimizer\n\nTODO\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.Problem","page":"TODO","title":"Coluna.MathProg.Problem","text":"Problem()\n\nConstructs an empty Problem.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.ColunaBase.TerminationStatus","page":"TODO","title":"Coluna.ColunaBase.TerminationStatus","text":"TerminationStatus\n\nTheses statuses are the possible reasons why an algorithm stopped the optimization.  When a subsolver is called through MOI, the MOI TerminationStatusCode is translated into a Coluna TerminationStatus.\n\nDescription of the termination statuses: \n\nOPTIMAL : the algorithm found a global optimal solution given the optimality tolerance.\nINFEASIBLE : the algorithm proved infeasibility\nTIME_LIMIT : the algorithm stopped because of the time limit\nNODE_LIMIT : the branch-and-bound based algorithm stopped due to the node limit\nOTHER_LIMIT : the algorithm stopped because of a limit that is neither the time limit \n\nnor the node limit\n\nIf the algorithm has not been called, the default value of the termination status should be:\n\nUNKNOWN_TERMINATION_STATUS\n\nIf the subsolver called through MOI returns a  TerminationStatusCode that is not MOI.OPTIMAL, MOI.INFEASIBLE, MOI.TIME_LIMIT, MOI.NODE_LIMIT, or  MOI.OTHER_LIMIT:\n\nUNCOVERED_TERMINATION_STATUS : should not be used by a Coluna algorithm\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.getuid","page":"TODO","title":"Coluna.MathProg.getuid","text":"Returns the uid of Formulation form.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.ColunaBase.isbetter","page":"TODO","title":"Coluna.ColunaBase.isbetter","text":"isbetter(b1, b2)\n\nReturns true if bound b1 is better than bound b2. The function take into account the space (primal or dual) and the objective sense (min, max) of the bounds.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.Constraint","page":"TODO","title":"Coluna.MathProg.Constraint","text":"Constraint\n\nRepresentation of a constraint in Coluna.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.Id","page":"TODO","title":"Coluna.MathProg.Id","text":"Id{VC <: AbstractVarConstr}\n\nColuna identifier of a Variable or a Constraint.\n\nIt is composed by the following uids:\n\nuid: uid in the formulation where it was generated \norigin_form_uid: uid of the formulation where it was generated \nassigned_form_uid_in_reformulation: uid of the formulation where it is generated assigned in the reformulation process\nproc_uid: Number of the process where it was generated \n\nFor a origin jump var/constr the originformuid is the jump model while the assignedformuidinreformulation is the spform for a pure spform and the master for a pure master var. For a added var/constr the originformuid is where is was created : for instance a master column 's orginal formulation  is the subproblem for which it was a solution and is assigned formulation is the master program.Number of the process where it was generated \n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.Algorithm.update_ip_primal_sol!","page":"TODO","title":"Coluna.Algorithm.update_ip_primal_sol!","text":"update_ip_primal_sol!(optstate, sol)\n\nAdd the solution sol in the solutions list of optstate if and only if the  value of the solution is better than the incumbent. The solution is inserted in the list by the method defined in insert_function_ip_primal_sols field of OptimizationState. If the maximum length of the list is reached, the solution located at the end of the list is removed.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.Algorithm.run!","page":"TODO","title":"Coluna.Algorithm.run!","text":"run!(algo::AbstractAlgorithm, model::AbstractData, input::AbstractInput)::AbstractOutput\n\nRuns the algorithm. The storage unit of the algorithm can be obtained from the data Returns algorithm's output.    \n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.ColunaBase.printbounds","page":"TODO","title":"Coluna.ColunaBase.printbounds","text":"printbounds(db, pb [, io])\n\nPrints the lower and upper bound according to the objective sense.\n\nCan receive io::IO as an input, to eventually output the print to a file or buffer.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.get_lp_primal_bound","page":"TODO","title":"Coluna.MathProg.get_lp_primal_bound","text":"Return the best primal bound of the linear program.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.ColunaBase.SolutionStatus","page":"TODO","title":"Coluna.ColunaBase.SolutionStatus","text":"SolutionStatus\n\nDescription of the solution statuses:\n\nFEASIBLE_SOL : the solution is feasible\nINFEASIBLE_SOL : the solution is not feasible\n\nIf there is no solution or if we don't have information about the solution, the  solution status should be :\n\nUNKWNOW_SOLUTION_STATUS\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.lp_gap_closed","page":"TODO","title":"Coluna.MathProg.lp_gap_closed","text":"Return true if the gap between the best primal and dual bounds of the linear program is closed given optimality tolerances.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Base.diff","page":"TODO","title":"Base.diff","text":"diff(b1, b2)\n\nDistance between a primal bound and a dual bound that have the same objective sense. Distance is non-positive if dual bound reached primal bound.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.update_ip_primal_bound!","page":"TODO","title":"Coluna.MathProg.update_ip_primal_bound!","text":"Update the primal bound of the mixed-integer program if the new one is better than the current one according to the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.Algorithm.OptimizationState","page":"TODO","title":"Coluna.Algorithm.OptimizationState","text":"OptimizationState(\n    form; \n    termination_status = UNKNOWN_TERMINATION_STATUS,\n    ip_primal_bound = nothing, \n    ip_dual_bound = nothing, \n    lp_primal_bound = nothing, \n    lp_dual_bound = nothing,\n    max_length_ip_primal_sols = 1, \n    max_length_lp_dual_sols = 1, \n    max_length_lp_dual_sols = 1,\n    insert_function_ip_primal_sols = bestbound!, \n    insert_function_lp_primal_sols = bestbound!, \n    insert_function_lp_dual_sols = bestbound!\n    )\n\nA convenient structure to maintain and return solutions and bounds of a formulation form during an optimization process. The termination statuses is considered as unknown by default. You can define the initial incumbent bounds using ip_primal_bound, ip_dual_bound, lp_primal_bound, and lp_primal_bound keyword arguments. Incumbent bounds are set to infinite (according to formulation objective sense) by default. You can store three types of solutions ip_primal_sols, lp_primal_sols, and lp_dual_sols. These solutions are stored in three lists. Keywords max_length_ip_primal_sols, max_length_lp_primal_sols, and max_length_lp_dual_sols let you define the maximum size of the lists. Keywords insert_function_ip_primal_sols, insert_function_lp_primal_sols, and insert_function_lp_dual_sols let you provide a function to define the way you want to insert a new solution in each list. By default, lists are sorted by best bound.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.update_lp_dual_bound!","page":"TODO","title":"Coluna.MathProg.update_lp_dual_bound!","text":"Update the dual bound of the linear program if the new one is better than the  current one according to the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.getoptimizer","page":"TODO","title":"Coluna.MathProg.getoptimizer","text":"Returns the AbstractOptimizer of Formulation form.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.update_ip_dual_bound!","page":"TODO","title":"Coluna.MathProg.update_ip_dual_bound!","text":"Update the dual bound of the mixed-integer program if the new one is better than the current one according to the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.ip_gap_closed","page":"TODO","title":"Coluna.MathProg.ip_gap_closed","text":"Return true if the gap between the best primal and dual bounds of the integer program is closed given optimality tolerances.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.Algorithm.add_ip_primal_sol!","page":"TODO","title":"Coluna.Algorithm.add_ip_primal_sol!","text":"add_ip_primal_sol!(optstate, sol)\n\nAdd the solution sol at the end of the solution list of opstate, sort the solution list, remove the worst solution if the solution list size is exceded, and update the incumbent bound if  the solution is better.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.ColunaBase.@nestedenum","page":"TODO","title":"Coluna.ColunaBase.@nestedenum","text":"@nestedenum block_expression\n\nCreate a NestedEnum subtype such as :\n\nExample\n\nDocTestSetup = quote\n    using Coluna\nend\n\nColuna.ColunaBase.@nestedenum begin \n    TypeOfItem\n    ItemA <= TypeOfItem\n        ChildA1 <= ItemA\n            GrandChildA11 <= ChildA1\n            GrandChildA12 <= ChildA1\n        ChildA2 <= ItemA\n    ItemB <= TypeOfItem\n    ItemC <= TypeOfItem\nend\n\n# output\n\n\nCreate a nested enumeration with items ItemA, ChildA1, ChildA2, GrandChildA11,  GrandChildA12, ItemB, and ItemC of type TypeOfItem. The operator <= indicates the parent of the item.\n\njulia> GrandChildA11 <= ItemA\ntrue\n\njulia> GrandChildA11 <= ItemC\nfalse\n\nDocTestSetup = nothing\n\n\n\n\n\n","category":"macro"},{"location":"dev/todo/#Coluna.ColunaBase.getvalue","page":"TODO","title":"Coluna.ColunaBase.getvalue","text":"getvalue(solution) -> Float64\n\nReturn the value of solution.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.ColunaBase.getsol","page":"TODO","title":"Coluna.ColunaBase.getsol","text":"getsol(solution)\n\nReturn the dynamic sparse vector that describes solution.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.ColunaBase.convert_status","page":"TODO","title":"Coluna.ColunaBase.convert_status","text":"convert_status(status::MOI.TerminationStatusCode) -> Coluna.TerminationStatus\nconvert_status(status::Coluna.TerminationStatus) -> MOI.TerminationStatusCode\nconvert_status(status::MOI.ResultStatusCode) -> Coluna.SolutionStatus\nconvert_status(status::Coluna.SolutionStatus) -> MOI.ResultStatusCode\n\nConvert a termination or solution status of a given type to the corresponding status in another type. This method is used to communicate between Coluna and MathOptInterface.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.ColunaBase.getstatus","page":"TODO","title":"Coluna.ColunaBase.getstatus","text":"getstatus(solution) -> SolutionStatus\n\nReturn the solution status of solution.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.lp_gap","page":"TODO","title":"Coluna.MathProg.lp_gap","text":"Return the gap between the best primal and dual bounds of the linear program.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.reset!","page":"TODO","title":"Coluna.MathProg.reset!","text":"reset!(form, var)\nreset!(form, varid)\nreset!(form, constr)\nreset!(form, constraint)\n\ndoc todo\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.ip_gap","page":"TODO","title":"Coluna.MathProg.ip_gap","text":"Return the gap between the best primal and dual bounds of the integer program. Should not be used to check convergence\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.get_ip_primal_bound","page":"TODO","title":"Coluna.MathProg.get_ip_primal_bound","text":"Return the best primal bound of the mixed-integer program.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.getcoefmatrix","page":"TODO","title":"Coluna.MathProg.getcoefmatrix","text":"Returns the representation of the coefficient matrix stored in the formulation manager.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.update_lp_primal_bound!","page":"TODO","title":"Coluna.MathProg.update_lp_primal_bound!","text":"Update the primal bound of the linear program if the new one is better than the current one according to the objective sense.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.Variable","page":"TODO","title":"Coluna.MathProg.Variable","text":"Variable\n\nRepresentation of a variable in Coluna.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.MoiOptimizer","page":"TODO","title":"Coluna.MathProg.MoiOptimizer","text":"MoiOptimizer <: AbstractOptimizer\n\nWrapper that is used when the optimizer of a formulation is an MOI.AbstractOptimizer, thus inheriting MOI functionalities.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.ColunaBase.Bound","page":"TODO","title":"Coluna.ColunaBase.Bound","text":"Bound{Space,Sense}()\n\nCreate a default bound for a problem with objective sense Sense<:AbstractSense in Space<:AbstractSpace.  \n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.Algorithm.set_ip_primal_sol!","page":"TODO","title":"Coluna.Algorithm.set_ip_primal_sol!","text":"set_ip_primal_sol!(optstate, sol)\n\nEmpties the list of solutions and add solution sol in the list. The incumbent bound is not updated even if the value of the solution is better.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.get_ip_dual_bound","page":"TODO","title":"Coluna.MathProg.get_ip_dual_bound","text":"Return the best dual bound of the mixed-integer program.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.Algorithm.ReformData","page":"TODO","title":"Coluna.Algorithm.ReformData","text":"ReformData\n\nData for reformulation.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.Algorithm.ModelData","page":"TODO","title":"Coluna.Algorithm.ModelData","text":"ModelData\n\nData for a single model.\n\n\n\n\n\n","category":"type"},{"location":"dev/todo/#Coluna.MathProg.get_optimization_target","page":"TODO","title":"Coluna.MathProg.get_optimization_target","text":"If the original formulation is not reformulated, it means that the user did not provide a way to decompose the model. In such a case, Coluna will call the subsolver to optimize the original formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/#Coluna.MathProg.create_formulation!","page":"TODO","title":"Coluna.MathProg.create_formulation!","text":"Formulation stores a mixed-integer linear program.\n\ncreate_formulation!(\n    env::Coluna.Env,\n    duty::Type{<:AbstractFormDuty};\n    parent_formulation = nothing,\n    obj_sense::Type{<:Coluna.AbstractSense} = MinSense\n)\n\nCreate a new formulation in the Coluna's environment `env` with duty `duty`,\nparent formulation `parent_formulation`, and objective sense `obj_sense`.\n\n\n\n\n\n","category":"function"},{"location":"dev/todo/","page":"TODO","title":"TODO","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"CurrentModule = Coluna.MathProg\nDocTestSetup = quote\n    using Coluna.MathProg\nend","category":"page"},{"location":"dev/formulation/#Formulation","page":"Formulation","title":"Formulation","text":"","category":"section"},{"location":"dev/formulation/#Duties-of-formulations","page":"Formulation","title":"Duties of formulations","text":"","category":"section"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"Original\nDwMaster\nBendersMaster\nDwSp\nBendersSp","category":"page"},{"location":"dev/formulation/#Coluna.MathProg.Original","page":"Formulation","title":"Coluna.MathProg.Original","text":"Formulation provided by the user.\n\n\n\n\n\n","category":"type"},{"location":"dev/formulation/#Coluna.MathProg.DwMaster","page":"Formulation","title":"Coluna.MathProg.DwMaster","text":"Master of a formulation decomposed using Dantzig-Wolfe.\n\n\n\n\n\n","category":"type"},{"location":"dev/formulation/#Coluna.MathProg.BendersMaster","page":"Formulation","title":"Coluna.MathProg.BendersMaster","text":"Master of a formulation decomposed using Benders.\n\n\n\n\n\n","category":"type"},{"location":"dev/formulation/#Coluna.MathProg.DwSp","page":"Formulation","title":"Coluna.MathProg.DwSp","text":"A pricing subproblem of a formulation decomposed using Dantzig-Wolfe.\n\n\n\n\n\n","category":"type"},{"location":"dev/formulation/#Coluna.MathProg.BendersSp","page":"Formulation","title":"Coluna.MathProg.BendersSp","text":"A Benders subproblem of a formulation decomposed using Benders.\n\n\n\n\n\n","category":"type"},{"location":"dev/formulation/#Attributes-of-formulations","page":"Formulation","title":"Attributes of formulations","text":"","category":"section"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"haskey\ngetvar\ngetconstr\ngetvars\ngetconstrs","category":"page"},{"location":"dev/formulation/#Base.haskey","page":"Formulation","title":"Base.haskey","text":"haskey(formulation, id) -> Bool\n\nReturn true if formulation has a variable or a constraint with given id.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getvar","page":"Formulation","title":"Coluna.MathProg.getvar","text":"getvar(formulation, varid) -> Variable\n\nReturn the variable with given varid that belongs to formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getconstr","page":"Formulation","title":"Coluna.MathProg.getconstr","text":"getconstr(formulation, constrid) -> Constraint\n\nReturn the constraint with given constrid that belongs to formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getvars","page":"Formulation","title":"Coluna.MathProg.getvars","text":"getvars(formulation) -> Dict{VarId, Variable}\n\nReturn all variables in formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getconstrs","page":"Formulation","title":"Coluna.MathProg.getconstrs","text":"getconstrs(formulation) -> Dict{ConstrId, Constraint}\n\nReturn all constraints in formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Variables","page":"Formulation","title":"Variables","text":"","category":"section"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"setvar!","category":"page"},{"location":"dev/formulation/#Coluna.MathProg.setvar!","page":"Formulation","title":"Coluna.MathProg.setvar!","text":"setvar!(\n    formulation::Formulation, name::String, duty::Duty{Variable};\n    cost::Float64 = 0.0,\n    lb::Float64 = 0.0,\n    ub::Float64 = Inf,\n    kind::VarKind = Continuous,\n    inc_val::Float64 = 0.0,\n    is_active::Bool = true,\n    is_explicit::Bool = true,\n    moi_index::MoiVarIndex = MoiVarIndex(),\n    members::Union{ConstrMembership, Nothing} = nothing,\n    id = generatevarid(duty, form)\n)\n\nCreate a new variable in a formulation with given name and duties. Other arguments are facultative.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Constraints","page":"Formulation","title":"Constraints","text":"","category":"section"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"setconstr!","category":"page"},{"location":"dev/formulation/#Coluna.MathProg.setconstr!","page":"Formulation","title":"Coluna.MathProg.setconstr!","text":"setconstr!(\n    form::Formulation, name::String, duty::Duty{Constraint};\n    rhs::Float64 = 0.0,\n    kind::ConstrKind = Essential,\n    sense::ConstrSense = Greater,\n    inc_val::Float64 = 0.0,\n    is_active::Bool = true,\n    is_explicit::Bool = true,\n    moi_index::MoiConstrIndex = MoiConstrIndex(),\n    members = nothing,\n    loc_art_var_abs_cost = 0.0,\n    id = generateconstrid(duty, form)\n)\n\nCreate a new constraint in a formulation with given name and duties. Other arguments are facultative.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Duties-of-variables-and-constraints","page":"Formulation","title":"Duties of variables and constraints","text":"","category":"section"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"Duty","category":"page"},{"location":"dev/formulation/#Coluna.MathProg.Duty","page":"Formulation","title":"Coluna.MathProg.Duty","text":"Duty{Variable}\n\nDuties of a variable are tree-structured values wrapped in Duty{Variable} instances.  Leaves are concret duties of a variable, intermediate nodes are duties representing  families of duties, and the root node is a Duty{Variable} with value 1.\n\nDuty{Constraint}\n\nIt works like Duty{Variable}.\n\nExamples\n\nIf a duty Duty1 inherits from Duty2, then \n\njldoctest julia> Duty1 <= Duty2 true`\n\n\n\n\n\n","category":"type"},{"location":"dev/formulation/#Attributes-of-variables-and-constraints","page":"Formulation","title":"Attributes of variables and constraints","text":"","category":"section"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"Performance note : use a variable or a constraint rather than its id.","category":"page"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"getperencost\ngetcurcost\nsetcurcost!\ngetperenlb\ngetcurlb\nsetcurlb!\ngetperenub\ngetcurub\nsetcurub!\ngetperenrhs\ngetcurrhs\nsetcurrhs!\ngetperenkind\ngetcurkind\nsetcurkind!\ngetperensense\ngetcursense\nsetcursense!\ngetperenincval\ngetcurincval\nsetcurincval!\nisperenactive\niscuractive\nactivate!\ndeactivate!\nisexplicit\ngetname","category":"page"},{"location":"dev/formulation/#Coluna.MathProg.getperencost","page":"Formulation","title":"Coluna.MathProg.getperencost","text":"getperencost(formulation, variable)\ngetperencost(formulation, varid)\n\nReturn the cost as defined by the user of a variable in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getcurcost","page":"Formulation","title":"Coluna.MathProg.getcurcost","text":"getcurcost(formulation, variable)\ngetcurcost(formulation, varid)\n\nReturn the current cost of the variable in the formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.setcurcost!","page":"Formulation","title":"Coluna.MathProg.setcurcost!","text":"setcurcost!(formulation, varid, cost::Float64)\nsetcurcost!(formulation, variable, cost::Float64)\n\nSet the current cost of variable in the formulation. If the variable is active and explicit, this change is buffered before application to the  subsolver.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getperenlb","page":"Formulation","title":"Coluna.MathProg.getperenlb","text":"getperenlb(formulation, varid)\ngetperenlb(formulation, var)\n\nReturn the lower bound as defined by the user of a variable in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getcurlb","page":"Formulation","title":"Coluna.MathProg.getcurlb","text":"getcurlb(formulation, varid)\ngetcurlb(formulation, var)\n\nReturn the current lower bound of a variable in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.setcurlb!","page":"Formulation","title":"Coluna.MathProg.setcurlb!","text":"setcurlb!(formulation, varid, lb::Float64)\nsetcurlb!(formulation, var, lb::Float64)\n\nSet the current lower bound of a variable in a formulation. If the variable is active and explicit, change is buffered before application to the subsolver.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getperenub","page":"Formulation","title":"Coluna.MathProg.getperenub","text":"getperenub(formulation, varid)\ngetperenub(formulation, var)\n\nReturn the upper bound as defined by the user of a variable in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getcurub","page":"Formulation","title":"Coluna.MathProg.getcurub","text":"getcurub(formulation, varid)\ngetcurub(formulation, var)\n\nReturn the current upper bound of a variable in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.setcurub!","page":"Formulation","title":"Coluna.MathProg.setcurub!","text":"setcurub!(formulation, varid, ub::Float64)\nsetcurub!(formulation, var, ub::Float64)\n\nSet the current upper bound of a variable in a formulation. If the variable is active and explicit, change is buffered before application to the subsolver.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getperenrhs","page":"Formulation","title":"Coluna.MathProg.getperenrhs","text":"getperenrhs(formulation, constraint)\ngetperenrhs(formulation, constrid)\n\nReturn the right-hand side as defined by the user of a constraint in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getcurrhs","page":"Formulation","title":"Coluna.MathProg.getcurrhs","text":"getcurrhs(formulation, constraint)\ngetcurrhs(formulation, constrid)\n\nReturn the current right-hand side of a constraint in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.setcurrhs!","page":"Formulation","title":"Coluna.MathProg.setcurrhs!","text":"setcurrhs(formulation, constraint, rhs::Float64)\nsetcurrhs(formulation, constrid, rhs::Float64)\n\nSet the current right-hand side of a constraint in a formulation.  If the constraint is active and explicit, this change is buffered before application to the subsolver.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getperenkind","page":"Formulation","title":"Coluna.MathProg.getperenkind","text":"getperenkind(formulation, varconstr)\ngetperenkind(formulation, varconstrid)\n\nReturn the kind as defined by the user of a variable or a constraint in a formulation.\n\nKinds of variable (enum VarKind) are Continuous, Binary, or Integ.\n\nKinds of a constraint (enum ConstrKind) are : \n\nEssential when the constraint structures the problem\nFacultative when the constraint does not structure the problem\nSubSystem (to do)\n\nThe kind of a constraint cannot change.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getcurkind","page":"Formulation","title":"Coluna.MathProg.getcurkind","text":"getcurkind(formulation, variable)\ngetcurkind(formulation, varid)\n\nReturn the current kind of a variable in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.setcurkind!","page":"Formulation","title":"Coluna.MathProg.setcurkind!","text":"setcurkind!(formulation, variable, kind::VarKind)\nsetcurkind!(formulation, varid, kind::VarKind)\n\nSet the current kind of a variable in a formulation. If the variable is active and explicit, this change is buffered before application to the subsolver\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getperensense","page":"Formulation","title":"Coluna.MathProg.getperensense","text":"getperensense(formulation, varconstr)\ngetperensense(formulation, varconstrid)\n\nReturn the sense as defined by the user of a variable or a constraint in a formulation.\n\nSenses or a variable are (enum VarSense)  Positive, Negative, and Free. Senses or a constraint are (enum ConstrSense) Greater, Less, and Equal.\n\nThe perennial sense of a variable depends on its perennial bounds.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getcursense","page":"Formulation","title":"Coluna.MathProg.getcursense","text":"getcursense(formulation, varconstr)\ngetcursense(formulation, varconstrid)\n\nReturn the current sense of a variable or a constraint in a formulation. The current sense of a variable depends on its current bounds.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.setcursense!","page":"Formulation","title":"Coluna.MathProg.setcursense!","text":"setcursense!(formulation, constr, sense::ConstrSense)\nsetcursense!(formulation, constrid, sense::ConstrSense)\n\nSet the current sense of a constraint in a formulation.\n\nThis method is not applicable to variables because the sense of a variable depends on its bounds.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getperenincval","page":"Formulation","title":"Coluna.MathProg.getperenincval","text":"getperenincval(formulation, varconstrid)\ngetperenincval(formulation, varconstr)\n\nReturn the incumbent value as defined by the user of a variable or a constraint in a formulation.  The incumbent value is ?\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getcurincval","page":"Formulation","title":"Coluna.MathProg.getcurincval","text":"getcurincval(formulation, varconstrid)\ngetcurincval(formulation, varconstr)\n\nReturn the current incumbent value of a variable or a constraint in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.setcurincval!","page":"Formulation","title":"Coluna.MathProg.setcurincval!","text":"setcurincval!(formulation, varconstrid, value::Real)\n\nSet the current incumbent value of a variable or a constraint in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.isperenactive","page":"Formulation","title":"Coluna.MathProg.isperenactive","text":"isperenactive(formulation, varconstrid)\nisperenactive(formulation, varconstr)\n\nReturn true if the variable or the constraint is active in the formulation; false otherwise. A variable (or a constraint) is active if it is used in the formulation. You can fake the  deletion of the variable by deativate it. This allows you to keep the variable if you want  to reactivate it later.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.iscuractive","page":"Formulation","title":"Coluna.MathProg.iscuractive","text":"iscuractive(formulation, varconstrid)\niscuractive(formulation, varconstr)\n\nReturn true if the variable or the constraint is currently active; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.activate!","page":"Formulation","title":"Coluna.MathProg.activate!","text":"activate!(formulation, varconstrid)\nactivate!(formulation, varconstr)\n\nActivate a variable or a constraint in a formulation.\n\nactivate!(formulation, function)\n\nIt is also possible to activate variables and constraints of a formulation such that  function(varconstrid) returns true.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.deactivate!","page":"Formulation","title":"Coluna.MathProg.deactivate!","text":"deactivate!(formulation, varconstrid)\ndeactivate!(formulation, varconstr)\n\nDeactivate a variable or a constraint in a formulation.\n\ndeactivate!(formulation, function)\n\nIt is also possible to deactivate variables and constraints such that  function(varconstrid) returns true.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.isexplicit","page":"Formulation","title":"Coluna.MathProg.isexplicit","text":"isexplicit(formulation, varconstr)\nisexplicit(formulation, varconstrid)\n\nReturn true if a variable or a constraint is explicit in a formulation; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/#Coluna.MathProg.getname","page":"Formulation","title":"Coluna.MathProg.getname","text":"getname(formulation, varconstr)\ngetname(formulation, varconstrid)\n\nReturn the name of a variable or a constraint in a formulation.\n\n\n\n\n\n","category":"function"},{"location":"dev/formulation/","page":"Formulation","title":"Formulation","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"user/start/#Quick-start","page":"Getting started","title":"Quick start","text":"","category":"section"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"This quick start guide introduces the main features of Coluna through the example of the Generalized Assignment Problem.","category":"page"},{"location":"user/start/#Problem","page":"Getting started","title":"Problem","text":"","category":"section"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"Consider a set of machines M = 1:nb_machines and a set of jobs J = 1:nb_jobs. A machine m has a resource capacity Q_m . A job j assigned to a machine m has a cost c_mj and consumes w_mj resource units of the machine m. The goal is to minimize the sum of job costs while assigning each job to a machine and not exceeding the capacity of each machine.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"Let x_mj equal to one if job j is assigned to machine m; 0 otherwise. The problem has the original formulation:","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"beginalignedat4\ntextGAP equiv min mathrlapsum_m in M c_mj x_mj  \ntextst  sum_m in M x_mj = 1  quad j in J \n sum_j in J w_mj x_mj leq Q_m Â quad  quad m in M  \n x_mj  in 01  m in M j in J\nendalignedat","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"In this tutorial, you will solve the instance below using a \"simple\" branch-and-cut-and-price algorithm:","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"nb_machines = 4\nnb_jobs = 30\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5 15.2 14.3 12.6 9.2 20.8 11.7 17.3 9.2 20.3 11.4 6.2 13.8 10.0 20.9 20.6;  19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2 19.7 19.5 7.2 6.4 23.2 8.1 13.6 24.6 15.6 22.3 8.8 19.1 18.4 22.9 8.0;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7 16.6 8.3 15.9 24.3 18.6 21.1 7.5 16.8 20.9 8.9 15.2 15.7 12.7 20.8 10.4;  13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2 12.9 11.3 7.5 6.5 11.3 7.8 13.8 20.7 16.8 23.6 19.1 16.8 19.3 12.5 11.0]\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78 71 50 99 92 83 53 91 68 61 63 97 91 77 68 80; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91 75 66 100 69 60 87 98 78 62 90 89 67 87 65 100; 91 81 66 63 59 81 87 90 65 55 57 68 92 91 86 74 80 89 95 57 55 96 77 60 55 57 56 67 81 52;  62 79 73 60 75 66 68 99 69 60 56 100 67 68 54 66 50 56 70 56 72 62 85 70 100 57 96 69 65 50]\nQ = [1020 1460 1530 1190]","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"This model has a block structure: each knapsack constraint defines an independent block and the set-partitioning constraints couple these independent blocks. By applying the Dantzig-Wolfe reformulation, each knapsack constraint forms a tractable subproblem and the set-partitioning constraints are handled in a master problem.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"To introduce the model, you need to load packages JuMP and BlockDecomposition. To optimize the problem, you need Coluna and a Julia package that provides a MIP solver such as GLPK.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"using JuMP, BlockDecomposition, Coluna, GLPK","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"Next, you instantiate the solver and define the algorithm that you use to optimize the problem. In this case, the algorithm is a \"simple\" branch-and-cut-and-price provided by Coluna.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n)","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"In BlockDecomposition, an axis is the index set of subproblems. Let M be the index set of machines; it defines an axis along which we can implement the desired decomposition. In this example, the axis M defines one knapsack subproblem for each machine.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"Jobs are not involved in the decomposition, you thus define the set J of jobs as a classic range.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"@axis(M, 1:nb_machines)\nJ = 1:nb_jobs","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"The model takes the form :","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"model = BlockModel(coluna)\n@variable(model, x[m in M, j in J], Bin)\n@constraint(model, cov[j in J], sum(x[m, j] for m in M) >= 1)\n@constraint(model, knp[m in M], sum(w[m, j] * x[m, j] for j in J) <= Q[m])\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M, j in J))","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"You then apply a Dantzig-Wolfe decomposition along the M axis:","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"@dantzig_wolfe_decomposition(model, decomposition, M)","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"where decomposition is a variable that contains information about the decomposition.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"Once the decomposition is defined, you can retrieve the master and the subproblems to give additional information to the solver.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"master = getmaster(decomposition)\nsubproblems = getsubproblems(decomposition)","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"The multiplicity of a subproblem is the number of times that the same independent block shaped by the subproblem appears in the model. This multiplicy also specifies the number of solutions to the subproblem that can appear in the solution to the original problem.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"In this GAP instance, the upper multiplicity is 1 because every subproblem is different, i.e., every machine is different and used at most once.","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"The lower multiplicity is 0 because a machine may stay unused. The multiplicity specifications take the form:","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"specify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"The model is now fully defined. To solve it, you need to call:","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"optimize!(model)","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"Finally, you can retrieve the solution to the original formulation with JuMP methods. For example:","category":"page"},{"location":"user/start/","page":"Getting started","title":"Getting started","text":"value.(x[1,:])  # j-th position is equal to 1 if job j assigned to machine 1","category":"page"},{"location":"dev/algorithms/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = Coluna.Algorithm\nDocTestSetup = quote\n    using Coluna.Algorithm\nend","category":"page"},{"location":"dev/algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"dev/algorithms/","page":"Algorithms","title":"Algorithms","text":"TreeSearchAlgorithm","category":"page"},{"location":"dev/algorithms/#Coluna.Algorithm.TreeSearchAlgorithm","page":"Algorithms","title":"Coluna.Algorithm.TreeSearchAlgorithm","text":"Coluna.Algorithm.TreeSearchAlgorithm(\n    conqueralg::AbstractConquerAlgorithm = ColCutGenConquer(),\n    dividealg::AbstractDivideAlgorithm = SimpleBranching(),\n    explorestrategy::AbstractTreeExploreStrategy = DepthFirstStrategy(),\n    maxnumnodes::Int = 100000,\n    opennodeslimit::Int = 100,\n    opt_atol::Float64 = DEF_OPTIMALITY_ATOL,\n    opt_rtol::Float64 = DEF_OPTIMALITY_RTOL,\n    branchingtreefile = nothing\n)\n\nThis algorithm uses search tree to do optimization. At each node in the tree, it applies conqueralg to improve the bounds, dividealg to generate child nodes, and explorestrategy to select the next node to treat.\n\nParameters : \n\nmaxnumnodes : maximum number of nodes explored by the algorithm\nopennodeslimit : maximum number of nodes waiting to be explored.\nopt_atol : optimality absolute tolerance\nopt_rtol : optimality relative tolerance\n\nOptions :\n\nbranchingtreefile : name of the file in which the algorithm writes an overview of the\n\nbranching tree \n\n\n\n\n\n","category":"type"},{"location":"dev/algorithms/","page":"Algorithms","title":"Algorithms","text":"ColCutGenConquer","category":"page"},{"location":"dev/algorithms/#Coluna.Algorithm.ColCutGenConquer","page":"Algorithms","title":"Coluna.Algorithm.ColCutGenConquer","text":"Coluna.Algorithm.ColCutGenConquer(\n    colgen::AbstractOptimizationAlgorithm = ColumnGeneration()\n    primal_heuristics::Vector{ParameterisedHeuristic} = [DefaultRestrictedMasterHeuristic()]\n    preprocess = PreprocessAlgorithm()\n    cutgen = CutCallbacks()\n    run_preprocessing::Bool = false\n)\n\nColumn-and-cut-generation based algorithm to find primal and dual bounds for a \nproblem decomposed using Dantzig-Wolfe paradigm. It applies `colgen` for the column \ngeneration phase, `cutgen` for the cut generation phase, and it can apply several primal\nheuristics to more efficiently find feasible solutions.\n\n\n\n\n\n","category":"type"},{"location":"dev/algorithms/","page":"Algorithms","title":"Algorithms","text":"ColumnGeneration\nSolveIpForm\nSolveLpForm","category":"page"},{"location":"dev/algorithms/#Coluna.Algorithm.ColumnGeneration","page":"Algorithms","title":"Coluna.Algorithm.ColumnGeneration","text":"Coluna.Algorithm.ColumnGeneration(\n    restr_master_solve_alg = SolveLpForm(get_dual_solution = true)\n    pricing_prob_solve_alg = SolveIpForm(\n        deactivate_artificial_vars = false,\n        enforce_integrality = false,\n        log_level = 2\n    ),\n    essential_cut_gen_alg = CutCallbacks(call_robust_facultative = false)\n    max_nb_iterations::Int = 1000\n    log_print_frequency::Int = 1\n    store_all_ip_primal_sols::Bool = false\n    redcost_tol::Float = 1e-5\n    cleanup_threshold::Int = 10000\n    cleanup_ratio::Float = 0.66\n    smoothing_stabilization::Float64 = 0.0 # should be in [0, 1]\n    opt_atol::Float64 = DEF_OPTIMALITY_ATOL\n    opt_rtol::Float64 = DEF_OPTIMALITY_RTOL\n)\n\nColumn generation algorithm. It applies restr_master_solve_alg to solve the linear restricted master and pricing_prob_solve_alg to solve the subproblems.\n\n\n\n\n\n","category":"type"},{"location":"dev/algorithms/#Coluna.Algorithm.SolveIpForm","page":"Algorithms","title":"Coluna.Algorithm.SolveIpForm","text":"Coluna.Algorithm.SolveIpForm(\n    time_limit::Int = 600,\n    deactivate_artificial_vars = true,\n    enforce_integrality = true,\n    silent = true,\n    max_nb_ip_primal_sols = 50,\n    log_level = 0\n)\n\nSolve a mixed integer linear program.\n\n\n\n\n\n","category":"type"},{"location":"dev/algorithms/#Coluna.Algorithm.SolveLpForm","page":"Algorithms","title":"Coluna.Algorithm.SolveLpForm","text":"Coluna.Algorithm.SolveLpForm(\n    get_dual_solution = false,\n    relax_integrality = false,\n    set_dual_bound = false,\n    silent = true\n)\n\nSolve a linear program.\n\n\n\n\n\n","category":"type"},{"location":"dev/algorithms/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a framework written in Julia to implement a decomposition approach to optimize  block-structured mixed-integer programs (MIP). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna relies on the tools of the JuMP-dev community at both ends of the problem treatment. It uses the JuMP modeling language upfront and MathOptInterface (MOI) to delegate master  and subproblems to MIP solvers. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The user introduces an original MIP that models his problem using the JuMP along our specific  extension BlockDecomposition that offers a syntax to specify the problem decomposition.  Coluna reformulates the original MIP using Dantzig-Wolfe and Benders decomposition  techniques.  Then, Coluna optimizes the reformulation using the algorithm chosen by the user.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna offers a \"black-box\" implementation of the branch-and-cut-and-price algorithm:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI). \nBlockDecomposition allows the user to provide to Coluna his decomposition of the model.   The BlockDecomposition syntax allows the user to implicilty define subsystems in the MIP on which the decomposition is based.   These subsystems are described by rows and/or columns indices.\nThe reformulation associated with the decomposition defined by the user is automatically generated by Coluna,  without requiring any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound.\nA default column (and cut) generation procedure is implemented.  It relies on underlying MOI optimizers to handle master and subproblems.   However, the user can use pricing callbacks to solve the subproblems.\nA branching scheme that preserves the pricing problem structure is offered by default;   it runs based on priorities and directives specified by the user on the original variables.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a package for Julia 1.0+","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It requires JuMP to model the problem, BlockDecomposition to define the decomposition, and a MIP solver supported by MathOptInterface to optimize the master and the subproblems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can install Coluna and its dependencies through the package manager of Julia by entering :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add Coluna","category":"page"},{"location":"#Contributions","page":"Introduction","title":"Contributions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We welcome all contributions that help us to improve Coluna. You can suggest ways to enhance the package by opening an issue via the GitHub issues tracker","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once the suggestion is approved, you can open a Pull Request (PR) with the implementation of your suggestion. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Before requesting the review, make sure that your code follows the style guide and passes tests.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Do not forget to update the docstrings and the tests when necessary. It is very important to keep clear the goal of the PR to make the review fast. So we might close a PR that fixes two unrelated issues or more. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna style follows the blue style guide for Julia amended by the following instruction on naming :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Names of variables and functions are treated equally. Use names that express what the variable/function does. > Either use : lowercasenospace when the name is composed of three words or less with no ambiguity on words separation.\nsnake_case otherwise","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that the application of the style guide is a work in progress.","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Atoptima, Mathematical Optimization Society (MOS), RÃ©gion Nouvelle-Aquitaine, University of Bordeaux, and Inria","category":"page"}]
}
