<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom data · Coluna User Guide</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/js/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna User Guide</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../start/">Column generation</a></li><li><a class="tocitem" href="../cuts/">Valid inequalities</a></li><li><a class="tocitem" href="../pricing/">Pricing callback</a></li><li class="is-active"><a class="tocitem" href>Custom data</a><ul class="internal"><li><a class="tocitem" href="#Modelling-for-identical-subproblems"><span>Modelling for identical subproblems</span></a></li><li><a class="tocitem" href="#Custom-data-for-non-robust-cuts"><span>Custom data for non-robust cuts</span></a></li><li><a class="tocitem" href="#Pricing-callback-and-subproblem-multiplicity"><span>Pricing callback and subproblem multiplicity</span></a></li><li><a class="tocitem" href="#Non-robust-cut-separation-callback."><span>Non-robust cut separation callback.</span></a></li></ul></li><li><a class="tocitem" href="../initial_columns/">Initial columns callback</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/decomposition/">Decomposition</a></li><li><a class="tocitem" href="../../man/config/">Configuration</a></li><li><a class="tocitem" href="../../man/algorithm/">Algorithms</a></li><li><a class="tocitem" href="../../man/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/treesearch/">Tree Search</a></li><li><a class="tocitem" href="../../api/storage/">Storage</a></li><li><a class="tocitem" href="../../api/branching/">Branching</a></li></ul></li><li><a class="tocitem" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays</a></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting started</a></li><li class="is-active"><a href>Custom data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Custom data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/custom_data.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Custom-Variables-and-Cuts"><a class="docs-heading-anchor" href="#Custom-Variables-and-Cuts">Custom Variables and Cuts</a><a id="Custom-Variables-and-Cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Variables-and-Cuts" title="Permalink"></a></h1><p>Coluna allows users to attach custom data to variables and constraints. This data are useful to store information about the variable or constraint in a custom format much easier to process than extracted information from the formulation (coefficient matrix, bounds, costs, and right-hand side).</p><p>In this example, we will show how to attach custom data to variables and constraints and use them to separate non-robust cuts. We will use the Bin Packing problem as an example.</p><p>Let us consider a Bin Packing problem with only 3 items such that any pair of items fits into one bin but the 3 items do not. The objective function is to minimize the number of bins being used. Pricing is done by inspection over the 6 combinations of items (3 pairs and 3 singletons). The master LP solution has 1.5 bins at the root node, each 0.5 corresponding to a bin with one of the possible pairs of items.</p><p>In this example, we will show you how to use non-robust cuts to improve the master LP solution at the root node. Obviously, Coluna is able to solve this instance by branching on the number of bins but the limit one on the number of nodes prevents it to be solved without cuts.</p><p>We define the dependencies:</p><pre><code class="language-julia hljs">using JuMP, BlockDecomposition, Coluna, GLPK;</code></pre><p>We define the solver.</p><pre><code class="language-julia hljs">coluna = JuMP.optimizer_with_attributes(
    Coluna.Optimizer,
    &quot;default_optimizer&quot; =&gt; GLPK.Optimizer,
    &quot;params&quot; =&gt; Coluna.Params(
        solver = Coluna.Algorithm.TreeSearchAlgorithm(
            conqueralg = Coluna.Algorithm.ColCutGenConquer(
                colgen = Coluna.Algorithm.ColumnGeneration(
                            pricing_prob_solve_alg = Coluna.Algorithm.SolveIpForm(
                                optimizer_id = 1
                            ))
            ),
            maxnumnodes = 1 # we only treat the root node.
        )
    )
);</code></pre><h2 id="Modelling-for-identical-subproblems"><a class="docs-heading-anchor" href="#Modelling-for-identical-subproblems">Modelling for identical subproblems</a><a id="Modelling-for-identical-subproblems-1"></a><a class="docs-heading-anchor-permalink" href="#Modelling-for-identical-subproblems" title="Permalink"></a></h2><p>Let&#39;s define the model. Let&#39;s <span>$B$</span> the set of bins and <span>$I$</span> the set of items. We introduce variable <span>$y_b$</span> that is equal to 1 if a bin <span>$b$</span> is used and 0 otherwise. We introduce variable <span>$x_{b,i}$</span> that is equal to 1 if item <span>$i$</span> is put in a bin <span>$b$</span> and 0 otherwise.</p><p>This is a special case of Dantzig-Wolfe decomposition because there is one subproblem per bin. However, bins are identical so we are going to use the multiplicity feature of the decomposition</p><pre><code class="language-julia hljs">model = BlockModel(coluna);</code></pre><p>We must assign three items.</p><pre><code class="language-julia hljs">I = [1, 2, 3];</code></pre><p>Since we use multiplicity, <code>B</code> will represent the type of bins. So here, we declare one type of bin only.</p><pre><code class="language-julia hljs">@axis(B, [1]);</code></pre><p>We declare variable <code>y[b]</code>. Its value in the model will be the aggregation of its value for all bins of type <code>b</code>. So here, if we use three bins of type 1, <code>y[1]</code> will be equal to 3.</p><pre><code class="language-julia hljs">@variable(model, y[b in B], Bin);</code></pre><p>Same with variable <code>x[b,i]</code>, its value in the model is the aggregation of its value for all bins of type <code>b</code></p><pre><code class="language-julia hljs">@variable(model, x[b in B, i in I], Bin);</code></pre><p>Each item must be assigned to one bin.</p><pre><code class="language-julia hljs">@constraint(model, sp[i in I], sum(x[b,i] for b in B) == 1);</code></pre><p>We minimize the number of bins and we declare the decomposition.</p><pre><code class="language-julia hljs">@objective(model, Min, sum(y[b] for b in B))
@dantzig_wolfe_decomposition(model, dec, B);</code></pre><h2 id="Custom-data-for-non-robust-cuts"><a class="docs-heading-anchor" href="#Custom-data-for-non-robust-cuts">Custom data for non-robust cuts</a><a id="Custom-data-for-non-robust-cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-data-for-non-robust-cuts" title="Permalink"></a></h2><p>As said previously, at the end of the column generation at the root node, the master LP solution has 1.5 bins. It corresponds to three bins, each of them used 0.5 times containing one pair <code>(1,2)</code>, <code>(1, 3)</code>, or <code>(2, 3)</code> of items. We are going to introduce the following non-robust cut to make the master LP solution integral:</p><p class="math-container">\[sum_{s in S if length(s) &gt;= 2} λ_s &lt;= 1\]</p><p>where :</p><ul><li><span>$S$</span> is the set of possible bin assignments generated by the pricing problem.</li><li><span>$length(s)$</span> the number of items in bin assignment <span>$s \in S$</span>.</li></ul><p>This cut means that we cannot have more than one bin with at least two items.</p><p>But the problem is that the cut is expressed over the master column and we don&#39;t have access to these variables from the JuMP model. To adress this problem, Coluna offers a way to compute the coefficient of a column in a constraint by implemnting the following method:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.MathProg.computecoeff" href="#Coluna.MathProg.computecoeff"><code>Coluna.MathProg.computecoeff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">computecoeff(var, var_custom_data, constr, constr_custom_data) -&gt; Float64</code></pre><p>Dispatches on the type of custom data attached to the variable and the constraint to compute the coefficient of the variable in the constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/84e5b3ceaf4eb6fae1435a52f229bfc068f86de7/src/MathProg/formulation.jl#L189-L194">source</a></section></article><p>We therefore needs to attach custom data to the master columns and the non-robust cut to use the method <code>compute_coeff</code>.</p><p>For every subproblem solution <span>$s$</span>, we define a custom data with the number of items in the bin.</p><pre><code class="language-julia hljs">struct MyCustomVarData &lt;: BlockDecomposition.AbstractCustomData
    nb_items::Int
end
BlockDecomposition.customvars!(model, MyCustomVarData);</code></pre><p>We define a custom data for the cut that will contain the minimum number of items in a bin that can be used one. The value will be <code>2</code> in this example.</p><pre><code class="language-julia hljs">struct MyCustomCutData &lt;: BlockDecomposition.AbstractCustomData
    min_items::Int
end
BlockDecomposition.customconstrs!(model, MyCustomCutData);</code></pre><p>We implement the <code>computecoeff</code> method for the custom data we defined.</p><pre><code class="language-julia hljs">function Coluna.MathProg.computecoeff(
    ::Coluna.MathProg.Variable, var_custom_data::MyCustomVarData,
    ::Coluna.MathProg.Constraint, constr_custom_data::MyCustomCutData
)
    return (var_custom_data.nb_items &gt;= constr_custom_data.min_items) ? 1.0 : 0.0
end</code></pre><h2 id="Pricing-callback-and-subproblem-multiplicity"><a class="docs-heading-anchor" href="#Pricing-callback-and-subproblem-multiplicity">Pricing callback and subproblem multiplicity</a><a id="Pricing-callback-and-subproblem-multiplicity-1"></a><a class="docs-heading-anchor-permalink" href="#Pricing-callback-and-subproblem-multiplicity" title="Permalink"></a></h2><p>We define the pricing callback that will generate the bin with best reduced cost. Be careful, when using non-robut cuts, you must take into account the controbution of the non-robust cuts to the reduced cost of your solution.</p><pre><code class="language-julia hljs">function my_pricing_callback(cbdata)
    # Get the reduced costs of the original variables.
    I = [1, 2, 3]
    b = BlockDecomposition.callback_spid(cbdata, model)
    rc_y = BlockDecomposition.callback_reduced_cost(cbdata, y[b])
    rc_x = [BlockDecomposition.callback_reduced_cost(cbdata, x[b, i]) for i in I]

    # Get the dual values of the custom cuts (to calculate contributions of
    # non-robust cuts to the cost of the solution).
    custduals = Tuple{Int, Float64}[]
    for (_, constr) in Coluna.MathProg.getconstrs(cbdata.form.parent_formulation)
        if typeof(constr.custom_data) == MyCustomCutData
            push!(custduals, (
                constr.custom_data.min_items,
                Coluna.MathProg.getcurincval(cbdata.form.parent_formulation, constr)
            ))
        end
    end

    # Pricing by inspection.
    sols = [[1], [2], [3], [1, 2], [1, 3], [2, 3]]
    best_s = Int[]
    best_rc = Inf
    for s in sols
        rc_s = rc_y + sum(rc_x[i] for i in s) # reduced cost of the subproblem variables
        if !isempty(custduals)
            # contribution of the non-robust cuts
            rc_s -= sum((length(s) &gt;= minits) ? dual : 0.0 for (minits, dual) in custduals)
        end
        if rc_s &lt; best_rc
            best_rc = rc_s
            best_s = s
        end
    end
    # build the best one and submit
    solcost = best_rc
    solvars = JuMP.VariableRef[]
    solvarvals = Float64[]
    for i in best_s
        push!(solvars, x[b, i])
        push!(solvarvals, 1.0)
    end
    push!(solvars, y[b])
    push!(solvarvals, 1.0)
    # submit the solution
    MOI.submit(
        model, BlockDecomposition.PricingSolution(cbdata),
        solcost,
        solvars,
        solvarvals,
        MyCustomVarData(length(best_s)) # attach a custom data to the column
    )
    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), solcost)
    return
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_pricing_callback (generic function with 1 method)</code></pre><p>The pricing callback is done, we define it as solver of our pricing problem. We also specify that the lower multiplicity of the master problem is 0 and the upper multiplicity is 3. It means that the final solution to the problem can use a least 0 bin and at most 3 bins.</p><pre><code class="language-julia hljs">subproblems = BlockDecomposition.getsubproblems(dec)
BlockDecomposition.specify!.(
    subproblems,
    lower_multiplicity = 0,
    upper_multiplicity = 3,
    solver = my_pricing_callback
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Nothing}:
 nothing</code></pre><h2 id="Non-robust-cut-separation-callback."><a class="docs-heading-anchor" href="#Non-robust-cut-separation-callback.">Non-robust cut separation callback.</a><a id="Non-robust-cut-separation-callback.-1"></a><a class="docs-heading-anchor-permalink" href="#Non-robust-cut-separation-callback." title="Permalink"></a></h2><p>We now define the cut separation callback for our non-robust cut. This is the same callback than the one used for robust cuts. There is just one slight difference when you submit the non-robust cut. Since cuts are expressed over the master variables and these variables are inacessible from the JuMP model, you&#39;ll submit a constraint with an empty left-hand side and you&#39;ll leave Coluna populate the left-hand side with the values returned by <code>Coluna.MathProg.computecoeff</code>.</p><p>So let&#39;s define the callback. Basically, if the solution uses more than one bin with two items, The cut is added to the model.</p><pre><code class="language-julia hljs">function custom_cut_sep(cbdata)
    # Compute the constraint violation by iterating over the master solution.
    viol = -1.0
    for (varid, varval) in cbdata.orig_sol
        var = Coluna.MathProg.getvar(cbdata.form, varid)
        if !isnothing(var.custom_data)
            if var.custom_data.nb_items &gt;= 2
                viol += varval
            end
        end
    end
    # Add the cut (at most one variable with 2 or more of the 3 items) if violated.
    if viol &gt; 0.001
        MOI.submit(
            model, MOI.UserCut(cbdata),
            JuMP.ScalarConstraint(
                JuMP.AffExpr(0.0), # We cannot express the left-hand-side so we push 0.
                MOI.LessThan(1.0)
            ),
            MyCustomCutData(2) # Cut custom data.
        )
    end
    return
end

MOI.set(model, MOI.UserCutCallback(), custom_cut_sep)
JuMP.optimize!(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Coluna
Version 0.5.3 | https://github.com/atoptima/Coluna.jl
***************************************************************************************
**** B&amp;B tree root node
**** Local DB = -Inf, global bounds: [ -Inf , Inf ], time = 0.12 sec.
***************************************************************************************
  &lt;st= 1&gt; &lt;it=  1&gt; &lt;et= 1.79&gt; &lt;mst= 0.00&gt; &lt;sp= 0.85&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=10001.0000&gt; &lt;mlp=30000.0000&gt; &lt;PB=Inf&gt;
  &lt;st= 1&gt; &lt;it=  2&gt; &lt;et= 1.80&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=-9998.0000&gt; &lt;mlp=10001.0000&gt; &lt;PB=Inf&gt;
  &lt;st= 1&gt; &lt;it=  3&gt; &lt;et= 1.80&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=-9998.0000&gt; &lt;mlp=10001.0000&gt; &lt;PB=Inf&gt;
  &lt;st= 1&gt; &lt;it=  4&gt; &lt;et= 1.80&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=    1.5000&gt; &lt;mlp=    1.5000&gt; &lt;PB=Inf&gt;
Robust cut separation callback adds 0 new essential cuts and 1 new facultative cuts.
avg. viol. = 0.00, max. viol. = 0.00, zero viol. = 1.
  &lt;st= 1&gt; &lt;it=  1&gt; &lt;et= 2.27&gt; &lt;mst= 0.00&gt; &lt;sp= 0.01&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=    2.0000&gt; &lt;mlp= 5001.5000&gt; &lt;PB=Inf&gt;
Robust cut separation callback adds 0 new essential cuts and 0 new facultative cuts.
  &lt;st= 1&gt; &lt;it=  2&gt; &lt;et= 2.29&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=-9997.0000&gt; &lt;mlp=    2.0000&gt; &lt;PB=2.0000&gt;
  &lt;st= 1&gt; &lt;it=  3&gt; &lt;et= 2.38&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=-9997.0000&gt; &lt;mlp=    2.0000&gt; &lt;PB=2.0000&gt;
  &lt;st= 1&gt; &lt;it=  4&gt; &lt;et= 2.38&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=    2.0000&gt; &lt;mlp=    2.0000&gt; &lt;PB=2.0000&gt;
 ──────────────────────────────────────────────────────────────────────────
                                  Time                    Allocations
                         ───────────────────────   ────────────────────────
    Tot / % measured:         8.27s /  29.1%            683MiB /  28.5%

 Section         ncalls     time    %tot     avg     alloc    %tot      avg
 ──────────────────────────────────────────────────────────────────────────
 Coluna               1    2.40s  100.0%   2.40s    194MiB  100.0%   194MiB
   SolveLpForm        8   1.82ms    0.1%   227μs    230KiB    0.1%  28.7KiB
 ──────────────────────────────────────────────────────────────────────────
[ Info: Terminated
[ Info: Primal bound: 2.0
[ Info: Dual bound: 2.0</code></pre><p>We see on the output that the algorithm has converged a first time before a cut is added. Coluna then starts a new iteration taking into account the cut. We notice here an improvement of the value of the dual bound: before the cut, we converge towards 1.5. After the cut, we reach 2.0.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pricing/">« Pricing callback</a><a class="docs-footer-nextpage" href="../initial_columns/">Initial columns callback »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 5 May 2023 13:14">Friday 5 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
