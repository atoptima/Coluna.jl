<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Storage · Coluna User Guide</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/js/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna User Guide</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/start/">Column generation</a></li><li><a class="tocitem" href="../../start/cuts/">Valid inequalities</a></li><li><a class="tocitem" href="../../start/pricing/">Pricing callback</a></li><li><a class="tocitem" href="../../start/custom_data/">Custom data</a></li><li><a class="tocitem" href="../../start/initial_columns/">Initial columns callback</a></li><li><a class="tocitem" href="../../start/advanced_demo/">Advanced tutorial</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/decomposition/">Decomposition</a></li><li><a class="tocitem" href="../../man/config/">Configuration</a></li><li><a class="tocitem" href="../../man/algorithm/">Algorithms</a></li><li><a class="tocitem" href="../../man/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../benders/">Benders</a></li><li><a class="tocitem" href="../branching/">Branching</a></li><li><a class="tocitem" href="../colgen/">ColGen</a></li><li><a class="tocitem" href="../treesearch/">TreeSearch</a></li><li class="is-active"><a class="tocitem" href>Storage</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays</a></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Storage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Storage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/api/storage.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Storage-API"><a class="docs-heading-anchor" href="#Storage-API">Storage API</a><a id="Storage-API-1"></a><a class="docs-heading-anchor-permalink" href="#Storage-API" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"></div></div><p>Missing intro, missing finding the best solution.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>A storage is a collection of storage units attached to a model.</p><p>A storage unit is a type that groups a set of entities for which we want to track the value over time. We can distinguish two kinds of storage units. First, storage units that track entities of the model (e.g. status of branching constraints, lower and upper bounds of variables). Second, storage units that track additional data (e.g. data of algorithms).</p><p>Since the values of the entities grouped in a storage unit vary over time, we want to save them at specific steps of the calculation flow to restore them later. The storage interface provides two methods to do both actions:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColunaBase.create_record" href="#Coluna.ColunaBase.create_record"><code>Coluna.ColunaBase.create_record</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_record(storage, storage_unit_type)</code></pre><p>Returns a Record that contains a description of the state of the storage unit at the time  when the method is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/b4b6c95e41d0eaec4051e84c50fdefb4ffebe04d/src/ColunaBase/recordmanager.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColunaBase.restore_from_record!" href="#Coluna.ColunaBase.restore_from_record!"><code>Coluna.ColunaBase.restore_from_record!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Restore information from the model or the storage unit that is recorded in a record.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/b4b6c95e41d0eaec4051e84c50fdefb4ffebe04d/src/ColunaBase/recordmanager.jl#L13">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Let&#39;s see through a simple example how to implement this interface.</p><p>In this example, we want to find the best solution by enumerating all the possible solutions using a tree search.</p><h3 id="Formulation"><a class="docs-heading-anchor" href="#Formulation">Formulation</a><a id="Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Formulation" title="Permalink"></a></h3><p>First, we import the dependencies</p><pre><code class="language-julia hljs">using Coluna;</code></pre><p>and we define some shortcuts for the sake of conciseness.</p><pre><code class="language-julia hljs">const ClB = Coluna.ColunaBase;
const ClA = Coluna.Algorithm;</code></pre><p>We consider a data structure that maintains a model.</p><pre><code class="language-julia hljs">struct Formulation &lt;: ClB.AbstractModel
    var_names::Vector{String}
    var_costs::Vector{Float64}
    var_domains::Vector{Tuple{Float64,Float64}}
end</code></pre><p>The model has 3 integer variables. The following arrays contain their names, costs, and initial bounds.</p><pre><code class="language-julia hljs">names = [&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;];
costs = [-1, 1, -0.5];
initial_bounds = [(0,2), (0.9,2), (-1,0.5)];</code></pre><p>We instantiate the model.</p><pre><code class="language-julia hljs">formulation = Formulation(names, costs, initial_bounds);</code></pre><h3 id="Storage"><a class="docs-heading-anchor" href="#Storage">Storage</a><a id="Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Storage" title="Permalink"></a></h3><p>The tree search algorithm will branch on all feasible integer values of x1 at depth 1, x2 at depth 2, and x3 at depth 3.</p><p>Each time, the tree search algorithm will evaluate a node, it will need to know the state of the formulation (e.g. domains of variables) at this node. For this purpose, we will use the storage.</p><p>We create a storage unit for variable domains</p><pre><code class="language-julia hljs">struct VarDomainStorageUnit &lt;: ClB.AbstractRecordUnit end</code></pre><p>and its constructor.</p><pre><code class="language-julia hljs">ClB.storage_unit(::Type{VarDomainStorageUnit}, _) = VarDomainStorageUnit()</code></pre><p>The state of the variables&#39; domains at a given node is called a record. The record is defined by the following data structure:</p><pre><code class="language-julia hljs">struct VarDomainRecord &lt;: ClB.AbstractRecord
    var_domains::Vector{Tuple{Float64,Float64}}
end</code></pre><p>There is a one-to-one correspondence between storage unit types and record types. This correspondence is implemented by the two following methods:</p><pre><code class="language-julia hljs">ClB.record_type(::Type{VarDomainStorageUnit}) = VarDomainRecord
ClB.storage_unit_type(::Type{VarDomainRecord}) = VarDomainStorageUnit</code></pre><p>We implement the method that creates a record of the variables&#39; domains.</p><pre><code class="language-julia hljs">function ClB.record(::Type{VarDomainRecord}, id::Int, form::Formulation, ::VarDomainStorageUnit)
    return VarDomainRecord(copy(form.var_domains))
end</code></pre><p>We implement the method that restores the variables&#39; domains of the formulation from a given record.</p><pre><code class="language-julia hljs">function ClB.restore_from_record!(form::Formulation, ::VarDomainStorageUnit, record::VarDomainRecord)
    for (var_pos, (lb, ub)) in enumerate(record.var_domains)
        form.var_domains[var_pos] = (lb, ub)
    end
    return
end</code></pre><h3 id="Tree-search-algorithm"><a class="docs-heading-anchor" href="#Tree-search-algorithm">Tree search algorithm</a><a id="Tree-search-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-search-algorithm" title="Permalink"></a></h3><p>There is a tutorial about the tree search interface.</p><p>We define the node data structure.</p><pre><code class="language-julia hljs">mutable struct Node &lt;: Coluna.TreeSearch.AbstractNode
    depth::Int
    id::Int
    branch_description::String
    parent::Union{Nothing,Node}
    record
    function Node(parent, id, branch, record)
        depth = isnothing(parent) ? 0 : parent.depth + 1
        return new(depth, id, branch, parent, record)
    end
end

Coluna.TreeSearch.get_root(node::Node) = isnothing(node.parent) ? node : Coluna.Treesearch.root(node.parent)
Coluna.TreeSearch.get_parent(node::Node) = node.parent</code></pre><p>We define the search space data structure. Note that we keep the storage in the search space because we have access to this data structure throughout the whole tree search execution.</p><pre><code class="language-julia hljs">mutable struct FullExplSearchSpace &lt;: Coluna.TreeSearch.AbstractSearchSpace
    nb_nodes_generated::Int
    formulation::Formulation
    solution::Tuple{Vector{Float64},Float64}
    storage::ClB.Storage{Formulation}
    record_ids_per_node::Dict{Int, Any}
    function FullExplSearchSpace(form::Formulation)
        return new(0, form, ([],Inf), ClB.Storage(form), Dict{Int,Any}())
    end
end</code></pre><p>We implement the method that returns the root node.</p><pre><code class="language-julia hljs">function Coluna.TreeSearch.new_root(space::FullExplSearchSpace, _)
    space.nb_nodes_generated += 1
    return Node(nothing, 1, &quot;&quot;, nothing)
end</code></pre><p>We define a method that prints node information and the state of the formulation together.</p><pre><code class="language-julia hljs">function print_form(form, current)
    t = repeat(&quot;   &quot;, current.depth)
    node = string(&quot;Node &quot;, current.id, &quot; &quot;)
    branch = isempty(current.branch_description) ? &quot;&quot; : string(&quot;- Branch &quot;, current.branch_description, &quot; &quot;)
    domains = mapreduce(*, enumerate(form.var_domains); init = &quot;|| &quot;) do e
        var_pos = first(e)
        lb, ub = last(e)
        rhs = lb == ub ? string(&quot; == &quot;, lb) : string(&quot; ∈ [&quot;, lb, &quot;, &quot;, ub, &quot;] &quot;)
        return string(&quot;x&quot;, var_pos, rhs, &quot;  &quot;)
    end
    println(t, node, branch, domains)
end;</code></pre><p>We write a function to calculate the solution at the current formulation of a node.</p><pre><code class="language-julia hljs">function compute_sol(space::FullExplSearchSpace, current)
    model = space.formulation
    sol = Float64[]
    sol_cost = 0.0
    for (cost, (ub, lb)) in Iterators.zip(model.var_costs, model.var_domains)
        var_val = (ub + lb) / 2.0
        sol_cost += var_val * cost
        push!(sol, var_val)
    end
    return sol, sol_cost
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">compute_sol (generic function with 1 method)</code></pre><p>We write a method that updates the best-found solution when the node solution is better.</p><pre><code class="language-julia hljs">function update_best_sol!(space::FullExplSearchSpace, solution::Tuple{Vector{Float64},Float64})
    if last(solution) &lt; last(space.solution)
        space.solution = solution
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">update_best_sol! (generic function with 1 method)</code></pre><p>Let&#39;s now talk about how we will store and restore the state of the formulation in our tree search algorithm.</p><p>The algorithm starts by creating and evaluating the root node. At this node the formulation is at its initial state, so it is ready to be evaluated. After node evaluation, the tree search branches, thus changing the formulation. Consequently, before branching, we generate a record of the state of the formulation at the root node to be able to restore it later if needed. Otherwise, we will no longer know what the original formulation state was. Then, each time we generate a child, we restore the state of the formulation at the parent node, we create the branching constraint, we generate a record of the state of the modified formulation in the child node, and we restore the state of the formulation at the current node.</p><p>We could optimize the number of record/restore operations for this specific example but that is beyond the scope of this tutorial.</p><p>We group operations that evaluate the current node in the following method.</p><pre><code class="language-julia hljs">function evaluate_current_node(space::FullExplSearchSpace, current)
    # The root node does not have any record when its evaluation begins.
    if !isnothing(current.record)
         # We restore the state of the formulation using the record stored in the current node.
        ClB.restore_from_record!(space.storage, current.record)
    end

    # Print the current formulation
    print_form(space.formulation, current)

    # Compute solution
    sol = compute_sol(space, current)

    # Update best solution
    update_best_sol!(space, sol)

    # Record current state of the formulation and keep the record in the current node.
    # This is not necessary here but the formulation often changes during evaluation.
    current.record = ClB.create_record(space.storage, VarDomainStorageUnit)
end;</code></pre><p>We group operations that generate the children of the current node in the following method.</p><pre><code class="language-julia hljs">function create_children(space::FullExplSearchSpace, current)
    # Variable on which we branch.
    var_pos = current.depth + 1
    var_domain = get(space.formulation.var_domains, var_pos, (0,-1))

    return map(range(ceil(first(var_domain)), floor(last(var_domain)))) do rhs
        space.nb_nodes_generated += 1
        node_id = space.nb_nodes_generated

        # Add branching constraint - change formulation.
        space.formulation.var_domains[var_pos] = (rhs, rhs)

        # Record the state of the formulation with the branching constraint
        # and keep it in the child node.
        rec = ClB.create_record(space.storage, VarDomainStorageUnit)
        space.record_ids_per_node[node_id] = rec

        # Restore the state of the formulation at the current node.
        ClB.restore_from_record!(space.storage, current.record)

        branch = string(&quot;x&quot;, var_pos, &quot; == &quot;, rhs)
        return Node(current, node_id, branch, rec)
    end
end;</code></pre><p>We define the method <code>children</code> of the tree search API. It evaluates the current node and then generates its children.</p><pre><code class="language-julia hljs">function Coluna.TreeSearch.children(space::FullExplSearchSpace, current, _, _)
    evaluate_current_node(space, current)
    return create_children(space, current)
end</code></pre><p>We don&#39;t define specific stopping criterion.</p><pre><code class="language-julia hljs">Coluna.TreeSearch.stop(::FullExplSearchSpace, _) = false</code></pre><p>We return the best solution and the record at each node to make sure the example worked.</p><pre><code class="language-julia hljs">Coluna.TreeSearch.tree_search_output(space::FullExplSearchSpace, _) = space.record_ids_per_node, space.solution</code></pre><p>We run the example.</p><pre><code class="language-julia hljs">search_space = FullExplSearchSpace(formulation)
Coluna.TreeSearch.tree_search(Coluna.TreeSearch.DepthFirstStrategy(), search_space, nothing, nothing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Dict{Int64, Any}(5 =&gt; Main.VarDomainRecord([(2.0, 2.0), (1.0, 1.0), (-1.0, 0.5)]), 16 =&gt; Main.VarDomainRecord([(1.0, 1.0), (1.0, 1.0), (0.0, 0.0)]), 20 =&gt; Main.VarDomainRecord([(0.0, 0.0), (2.0, 2.0), (0.0, 0.0)]), 12 =&gt; Main.VarDomainRecord([(1.0, 1.0), (2.0, 2.0), (-1.0, 0.5)]), 8 =&gt; Main.VarDomainRecord([(2.0, 2.0), (2.0, 2.0), (0.0, 0.0)]), 17 =&gt; Main.VarDomainRecord([(0.0, 0.0), (1.0, 1.0), (-1.0, 0.5)]), 19 =&gt; Main.VarDomainRecord([(0.0, 0.0), (2.0, 2.0), (-1.0, -1.0)]), 22 =&gt; Main.VarDomainRecord([(0.0, 0.0), (1.0, 1.0), (0.0, 0.0)]), 6 =&gt; Main.VarDomainRecord([(2.0, 2.0), (2.0, 2.0), (-1.0, 0.5)]), 11 =&gt; Main.VarDomainRecord([(1.0, 1.0), (1.0, 1.0), (-1.0, 0.5)])…), ([2.0, 1.0, 0.0], -1.0))</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><p>To summarize from a developer&#39;s point of view, there is a one-to-one correspondence between storage unit types and record types. this correspondence is implemented by methods <code>record_type(StorageUnitType)</code> and <code>storage_unit_type(RecordType)</code>.</p><p>The developer must also implement methods <code>storage_unit(StorageUnitType)</code> and <code>record(RecordType, id, model, storage_unit)</code> that must call constructors of the custom storage unit and one of its associated records. Arguments of <code>record</code> allow the developer to record the state of entities from both the storage unit and the model.</p><p>At last, he must implement <code>restore_from_record!(storage_unit, model, record)</code> to restore the state of the entities represented by the storage unit. Entities can be in the storage unit, the model, or both of them.</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColunaBase.record_type" href="#Coluna.ColunaBase.record_type"><code>Coluna.ColunaBase.record_type</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the type of record stored in a type of storage unit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/b4b6c95e41d0eaec4051e84c50fdefb4ffebe04d/src/ColunaBase/recordmanager.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColunaBase.storage_unit_type" href="#Coluna.ColunaBase.storage_unit_type"><code>Coluna.ColunaBase.storage_unit_type</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the type of storage unit that stores a type of record.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/b4b6c95e41d0eaec4051e84c50fdefb4ffebe04d/src/ColunaBase/recordmanager.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColunaBase.storage_unit" href="#Coluna.ColunaBase.storage_unit"><code>Coluna.ColunaBase.storage_unit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a storage unit from a given type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/b4b6c95e41d0eaec4051e84c50fdefb4ffebe04d/src/ColunaBase/recordmanager.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColunaBase.record" href="#Coluna.ColunaBase.record"><code>Coluna.ColunaBase.record</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Creates a record of information from the model or a storage unit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/b4b6c95e41d0eaec4051e84c50fdefb4ffebe04d/src/ColunaBase/recordmanager.jl#L10">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ColunaBase.restore_from_record!</code>. Check Documenter&#39;s build log for details.</p></div></div><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../treesearch/">« TreeSearch</a><a class="docs-footer-nextpage" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 13 June 2023 16:46">Tuesday 13 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
