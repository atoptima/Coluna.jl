<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ColGen · Coluna.jl</title><meta name="title" content="ColGen · Coluna.jl"/><meta property="og:title" content="ColGen · Coluna.jl"/><meta property="twitter:title" content="ColGen · Coluna.jl"/><meta name="description" content="Documentation for Coluna.jl."/><meta property="og:description" content="Documentation for Coluna.jl."/><meta property="twitter:description" content="Documentation for Coluna.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/js/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting Started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/start/">Column generation</a></li><li><a class="tocitem" href="../../start/cuts/">Cut Generation</a></li><li><a class="tocitem" href="../../start/pricing/">Pricing callback</a></li><li><a class="tocitem" href="../../start/identical_sp/">Identical subproblems</a></li><li><a class="tocitem" href="../../start/custom_data/">Custom data</a></li><li><a class="tocitem" href="../../start/initial_columns/">Initial columns callback</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Advanced tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/advanced_demo/">Column Generation and Benders on Location Routing</a></li><li><a class="tocitem" href="../../start/other_pbs/">Other classic problems</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Decomposition</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/decomposition/">Decomposition paradigms</a></li><li><a class="tocitem" href="../../man/blockdecomposition/">Setup decomposition using BlockDecomposition</a></li></ul></li><li><a class="tocitem" href="../../man/config/">Configuration</a></li><li><a class="tocitem" href="../../man/algorithm/">Built-in algorithms</a></li><li><a class="tocitem" href="../../man/callbacks/">User-defined Callbacks</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../algos/">Algorithms</a></li><li><a class="tocitem" href="../benders/">Benders</a></li><li><a class="tocitem" href="../branching/">Branching</a></li><li class="is-active"><a class="tocitem" href>ColGen</a><ul class="internal"><li><a class="tocitem" href="#Context"><span>Context</span></a></li><li><a class="tocitem" href="#Generic-functions"><span>Generic functions</span></a></li><li><a class="tocitem" href="#Reformulation"><span>Reformulation</span></a></li><li><a class="tocitem" href="#Main-loop"><span>Main loop</span></a></li><li><a class="tocitem" href="#Phase-loop"><span>Phase loop</span></a></li><li><a class="tocitem" href="#Stages"><span>Stages</span></a></li><li><a class="tocitem" href="#Column-generation-iteration"><span>Column generation iteration</span></a></li><li><a class="tocitem" href="#Stabilization"><span>Stabilization</span></a></li></ul></li><li><a class="tocitem" href="../treesearch/">TreeSearch</a></li><li><a class="tocitem" href="../storage/">Storage</a></li></ul></li><li><a class="tocitem" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays</a></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>ColGen</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ColGen</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/atoptima/Coluna.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/api/colgen.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Column-generation"><a class="docs-heading-anchor" href="#Column-generation">Column generation</a><a id="Column-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Column-generation" title="Permalink"></a></h1><p>Coluna provides an interface and generic functions to implement a multi-stage column  generation algorithm together with a default implementation of this algorithm.</p><p>In this section, we are first going to present the generic functions, the implementation  with some theory backgrounds and then give the references of the interface.</p><p>You can find the generic functions and the interface in the <code>ColGen</code> submodule and the default  implementation in the <code>Algorithm</code> submodule at <code>src/Algorithm/colgen</code>.</p><h2 id="Context"><a class="docs-heading-anchor" href="#Context">Context</a><a id="Context-1"></a><a class="docs-heading-anchor-permalink" href="#Context" title="Permalink"></a></h2><p>The <code>ColGen</code> submodule provides an interface and generic functions to implement a column generation algorithm. The implementation depends on  an object called <code>context</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenContext" href="#Coluna.ColGen.AbstractColGenContext"><code>Coluna.ColGen.AbstractColGenContext</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for the objects to which belongs the implementation of the column generation and  that stores any kind of information during the execution of the column generation algorithm.</p><p><strong>IMPORTANT</strong>: implementation of the column generation mainly depends on the context type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/ColGen.jl#L7-L12">source</a></section></article><p>Coluna provides two types of context:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenContext" href="#Coluna.Algorithm.ColGenContext"><code>Coluna.Algorithm.ColGenContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColGenContext(reformulation, algo_params) -&gt; ColGenContext</code></pre><p>Creates a context to run the default implementation of the column generation algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenPrinterContext" href="#Coluna.Algorithm.ColGenPrinterContext"><code>Coluna.Algorithm.ColGenPrinterContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColGenPrinterContext(reformulation, algo_params) -&gt; ColGenPrinterContext</code></pre><p>Creates a context to run the default implementation of the column generation algorithm together with a printer that prints information about the algorithm execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/printer.jl#L1-L6">source</a></section></article><h2 id="Generic-functions"><a class="docs-heading-anchor" href="#Generic-functions">Generic functions</a><a id="Generic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-functions" title="Permalink"></a></h2><p>Generic functions are the core of the column generation algorithm. There are three generic functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.run!" href="#Coluna.ColGen.run!"><code>Coluna.ColGen.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run!(ctx, env, ip_primal_sol; iter = 1) -&gt; AbstractColGenOutput</code></pre><p>Runs the column generation algorithm.</p><p>Arguments are:</p><ul><li><code>ctx</code>: column generation context</li><li><code>env</code>: Coluna environment</li><li><code>ip_primal_sol</code>: current best primal solution to the master problem</li><li><code>iter</code>: iteration number (default: 1)</li></ul><p>This function is responsible for initializing the column generation context, the reformulation, and the stabilization. We iterate on the loop each time the phase or the stage changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/ColGen.jl#L21-L34">source</a></section></article><p>See the <a href="#Main-loop">main loop</a> section for more details.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.run_colgen_phase!" href="#Coluna.ColGen.run_colgen_phase!"><code>Coluna.ColGen.run_colgen_phase!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_colgen_phase!(ctx, phase, stage, env, ip_primal_sol, stab; iter = 1) -&gt; AbstractColGenPhaseOutput</code></pre><p>Runs a phase of the column generation algorithm.</p><p>Arguments are:</p><ul><li><code>ctx</code>: column generation context</li><li><code>phase</code>: current column generation phase</li><li><code>stage</code>: current column generation stage</li><li><code>env</code>: Coluna environment</li><li><code>ip_primal_sol</code>: current best primal solution to the master problem</li><li><code>stab</code>: stabilization</li><li><code>iter</code>: iteration number (default: 1)</li></ul><p>This function is responsible for running the column generation iterations until the phase is finished.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/ColGen.jl#L54-L70">source</a></section></article><p>See the <a href="#Phase-loop">phase loop</a> section for more details.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.run_colgen_iteration!" href="#Coluna.ColGen.run_colgen_iteration!"><code>Coluna.ColGen.run_colgen_iteration!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_colgen_iteration!(context, phase, stage, env, ip_primal_sol, stab) -&gt; AbstractColGenIterationOutput</code></pre><p>Runs an iteration of column generation.</p><p>Arguments are:</p><ul><li><code>context</code>: column generation context</li><li><code>phase</code>: current column generation phase</li><li><code>stage</code>: current column generation stage</li><li><code>env</code>: Coluna environment</li><li><code>ip_primal_sol</code>: current best primal solution to the master problem</li><li><code>stab</code>: stabilization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/ColGen.jl#L89-L101">source</a></section></article><p>See the <a href="#Column-generation-iteration">column generation iteration</a> section for more details.</p><p>They are independent of any other submodule of Coluna. You can use them to implement your own column generation algorithm.</p><h2 id="Reformulation"><a class="docs-heading-anchor" href="#Reformulation">Reformulation</a><a id="Reformulation-1"></a><a class="docs-heading-anchor-permalink" href="#Reformulation" title="Permalink"></a></h2><p>The default implementation works with a reformulated problem contained in  <code>MathProg.Reformulation</code> where master and subproblems are <code>MathProg.Formulation</code> objects.</p><p>The master has the following form:</p><p class="math-container">\[\begin{aligned}
\min \quad&amp; \sum_{k \in K} c^k \lambda^k+\bar{c} y &amp; \\
\text{s.t.} \quad&amp; \sum_{k \in K} A^k \lambda^k+\bar{A} y \geq a  &amp; (1)\\
&amp; l_k \leq \mathbf{1} \lambda^k \leq u_k &amp; (2) \\
&amp; \bar{l} \leq y \leq \bar{u} &amp; (3)
\end{aligned}\]</p><p>where <span>$\lambda$</span> are the master columns, <span>$y$</span> are the pure master variables, constraints (1) are the linking constraints, constraints (2) are the convexity constraints that depend on <span>$l_k$</span> and <span>$u_k$</span> (e.g. the lower and upper multiplicity of the subproblem <span>$k$</span> respectively), and constraints (3) are the bounds on the pure master variables.</p><p>The subproblems have the following form:</p><p class="math-container">\[\begin{aligned}
\min \quad&amp; cx + 0z \\
\text{s.t.} \quad&amp; Bx \geq b \\
&amp; 1 \leq z \leq 1
\end{aligned}\]</p><p>where <span>$x$</span> are the subproblem variables, <span>$z$</span> is a setup variable that always takes the value one in a solution to the subproblem.</p><p>The coefficients of the columns in constraints (1) and (2) of the master are computed using representative variables of the subproblems.  You can read this section (TODO Natacha) to understand how we map the subproblem solutions into master columns.</p><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_reform" href="#Coluna.ColGen.get_reform"><code>Coluna.ColGen.get_reform</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns Dantzig-Wolfe reformulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_master" href="#Coluna.ColGen.get_master"><code>Coluna.ColGen.get_master</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns master formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_pricing_subprobs" href="#Coluna.ColGen.get_pricing_subprobs"><code>Coluna.ColGen.get_pricing_subprobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_pricing_subprobs(ctx) -&gt; Vector{Tuple{SuproblemId, SpFormulation}}</code></pre><p>Returns subproblem formulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.is_minimization" href="#Coluna.ColGen.is_minimization"><code>Coluna.ColGen.is_minimization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if the objective sense is minimization; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L14">source</a></section></article><h2 id="Main-loop"><a class="docs-heading-anchor" href="#Main-loop">Main loop</a><a id="Main-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Main-loop" title="Permalink"></a></h2><p>This is a description of how the <code>Coluna.ColGen.run!</code> generic function behaves in the default implementation.</p><p>The main loop stops when the <code>Coluna.ColGen.stop_colgen</code> method returns <code>true</code>. This is the case when one of the following conditions holds: </p><ul><li>the master or a pricing subproblem is infeasible</li><li>the time limit is reached</li><li>the maximum number of iterations is reached</li></ul><p>Otherwise, the main loop runs until there is no more phase or stage to execute.</p><p>The method returns:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenOutput" href="#Coluna.Algorithm.ColGenOutput"><code>Coluna.Algorithm.ColGenOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Output of the default implementation of the column generation algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L102">source</a></section></article><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.stop_colgen" href="#Coluna.ColGen.stop_colgen"><code>Coluna.ColGen.stop_colgen</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> when the column generation algorithm must stop; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.setup_reformulation!" href="#Coluna.ColGen.setup_reformulation!"><code>Coluna.ColGen.setup_reformulation!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Setup the reformulation for the given phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/phases.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.setup_context!" href="#Coluna.ColGen.setup_context!"><code>Coluna.ColGen.setup_context!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Setup the context for the given phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/phases.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenOutput" href="#Coluna.ColGen.AbstractColGenOutput"><code>Coluna.ColGen.AbstractColGenOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for the objects that contains the output of the column generation algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.colgen_output_type" href="#Coluna.ColGen.colgen_output_type"><code>Coluna.ColGen.colgen_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colgen_output_type(ctx) -&gt; Type{&lt;:AbstractColGenOutput}</code></pre><p>Returns the type of the column generation output associated to the context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.new_output" href="#Coluna.ColGen.new_output"><code>Coluna.ColGen.new_output</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_output(OutputType, colgen_phase_output) -&gt; OutputType</code></pre><p>Returns the column generation output where <code>colgen_phase_output</code> is the output of the last column generation phase executed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L262-L267">source</a></section></article><h2 id="Phase-loop"><a class="docs-heading-anchor" href="#Phase-loop">Phase loop</a><a id="Phase-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-loop" title="Permalink"></a></h2><p>This is a description of how the <code>Coluna.ColGen.run_colgen_phase!</code> generic function behaves in the default implementation.</p><p>This function is responsible for maintaining the incumbent dual bound and the incumbent master IP primal solution.</p><p>The phase loop stops when the <code>Coluna.ColGen.stop_colgen_phase</code> method returns <code>true</code>. This is the case when one of the following conditions holds:</p><ul><li>the maximum number of iterations is reached</li><li>the time limit is reached</li><li>the master is infeasible</li><li>the master is unbounded</li><li>a pricing subproblem is infeasible</li><li>a pricing subproblem is unbounded</li><li>there is no new column generated at the last iteration</li><li>there is a new constraint or valid inequality in the master</li><li>the incumbent dual bound and the primal master LP solution value converged</li></ul><p>The method returns:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenPhaseOutput" href="#Coluna.Algorithm.ColGenPhaseOutput"><code>Coluna.Algorithm.ColGenPhaseOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Output of the default implementation of a phase of the column generation algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L85">source</a></section></article><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.stop_colgen_phase" href="#Coluna.ColGen.stop_colgen_phase"><code>Coluna.ColGen.stop_colgen_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if the column generation phase must stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/phases.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.before_colgen_iteration" href="#Coluna.ColGen.before_colgen_iteration"><code>Coluna.ColGen.before_colgen_iteration</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Placeholder method called before the column generation iteration. Does nothing by default but can be redefined to print some informations for instance. We strongly advise users against the use of this method to modify the context or the reformulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.after_colgen_iteration" href="#Coluna.ColGen.after_colgen_iteration"><code>Coluna.ColGen.after_colgen_iteration</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Placeholder method called after the column generation iteration. Does nothing by default but can be redefined to print some informations for instance. We strongly advise users against the use of this method to modify the context or the reformulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.is_better_dual_bound" href="#Coluna.ColGen.is_better_dual_bound"><code>Coluna.ColGen.is_better_dual_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if <code>new_dual_bound</code> is better than <code>dual_bound</code>; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L308">source</a></section></article><h3 id="Phase-iterator"><a class="docs-heading-anchor" href="#Phase-iterator">Phase iterator</a><a id="Phase-iterator-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-iterator" title="Permalink"></a></h3><p>In the first iterations, the restricted master LP contains a few columns and may be infeasible. To prevent this, we introduced artificial variables <span>$v$</span> and we activate/deactivate these variables depending on whether we want to prove the infeasibility of the master LP or find the optimal LP solution. The default implementation provides three phases:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenPhase0" href="#Coluna.Algorithm.ColGenPhase0"><code>Coluna.Algorithm.ColGenPhase0</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Phase 0 is a mix of phase 1 and phase 2. It sets a very large cost to artifical variables to force them to be removed from the master  LP solution. If the final master LP solution contains artifical variables either the master is infeasible or the cost of artificial variables is not large enough. Phase 1 must be run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L170-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenPhase1" href="#Coluna.Algorithm.ColGenPhase1"><code>Coluna.Algorithm.ColGenPhase1</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Phase 1 sets the cost of variables to 0 except for artifical variables. The goal is to find a solution to the master LP problem that has no artificial variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L157-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenPhase2" href="#Coluna.Algorithm.ColGenPhase2"><code>Coluna.Algorithm.ColGenPhase2</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Phase 2 solves the master LP without artificial variables. To start, it requires a set of columns that forms a feasible solution to the LP master. This set is found with phase 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L163-L167">source</a></section></article><p>Column generation always starts with Phase 0.</p><p>The default implementation of the phase iterator belongs to the following type:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColunaColGenPhaseIterator" href="#Coluna.Algorithm.ColunaColGenPhaseIterator"><code>Coluna.Algorithm.ColunaColGenPhaseIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for the default implementation of the sequence of phases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L150-L152">source</a></section></article><p>Transitions between the phases depend on four conditions:</p><ul><li>(A) the presence of artificial variables in the master LP solution</li><li>(B) the generation of new essential constraints (may happen when a new master IP solution is found)</li><li>(C) the current stage is exact</li><li>(D) column generation converged </li></ul><p>Transitions are the following:</p><div class="mermaid">flowchart TB;
    id1(Phase 0)
    id2(Phase 1)
    id3(Phase 2)
    id4(end)
    id5(error)
    id1 --A &amp; !B &amp; C--&gt; id2
    id1 --!A &amp; !B &amp; C &amp; D--&gt; id4
    id1 -- otherwise --&gt; id1
    id2 --!A &amp; !B--&gt; id3
    id2 --A &amp; C &amp; D--&gt; id4
    id2 -- otherwise --&gt; id2
    id3 -- !B &amp; C &amp; D --&gt; id4
    id3 -- otherwise --&gt; id3
    id3 -- B --&gt; id2
    id3 -- A --&gt; id5
    style id5 stroke:#f66</div><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenPhase" href="#Coluna.ColGen.AbstractColGenPhase"><code>Coluna.ColGen.AbstractColGenPhase</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A phase of the column generation. Each phase is associated with a specific set up of the reformulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/phases.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenPhaseIterator" href="#Coluna.ColGen.AbstractColGenPhaseIterator"><code>Coluna.ColGen.AbstractColGenPhaseIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An iterator that indicates how phases follow each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/phases.jl#L7-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.new_phase_iterator" href="#Coluna.ColGen.new_phase_iterator"><code>Coluna.ColGen.new_phase_iterator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a new phase iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/phases.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.initial_phase" href="#Coluna.ColGen.initial_phase"><code>Coluna.ColGen.initial_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the phase with which the column generation algorithm must start.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/phases.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.decrease_stage" href="#Coluna.ColGen.decrease_stage"><code>Coluna.ColGen.decrease_stage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the next stage involving a &quot;more exact solver&quot; than the current one. Returns <code>nothing</code> if the algorithm has already reached the exact phase (last phase).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.next_phase" href="#Coluna.ColGen.next_phase"><code>Coluna.ColGen.next_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the next phase of the column generation algorithm. Returns <code>nothing</code> if the algorithm must stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/phases.jl#L18-L21">source</a></section></article><h3 id="Phase-output"><a class="docs-heading-anchor" href="#Phase-output">Phase output</a><a id="Phase-output-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-output" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenPhaseOutput" href="#Coluna.ColGen.AbstractColGenPhaseOutput"><code>Coluna.ColGen.AbstractColGenPhaseOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for the objects that contains the output of a column generation phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.colgen_phase_output_type" href="#Coluna.ColGen.colgen_phase_output_type"><code>Coluna.ColGen.colgen_phase_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colgen_phase_outputype(ctx) -&gt; Type{&lt;:AbstractColGenPhaseOutput}</code></pre><p>Returns the type of the column generation phase output associated to the context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.new_phase_output" href="#Coluna.ColGen.new_phase_output"><code>Coluna.ColGen.new_phase_output</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_phase_output(OutputType, min_sense, phase, stage, colgen_iter_output, iter, inc_dual_bound) -&gt; OutputType</code></pre><p>Returns the column generation phase output.</p><p>Arguments of this function are:</p><ul><li><code>OutputType</code>: the type of the column generation phase output</li><li><code>min_sense</code>: <code>true</code> if it is a minimization problem; <code>false</code> otherwise</li><li><code>phase</code>: the current column generation phase</li><li><code>stage</code>: the current column generation stage</li><li><code>col_gen_iter_output</code>: the last column generation iteration output</li><li><code>iter</code>: the last iteration number</li><li><code>inc_dual_bound</code>: the current incumbent dual bound</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L230-L243">source</a></section></article><h2 id="Stages"><a class="docs-heading-anchor" href="#Stages">Stages</a><a id="Stages-1"></a><a class="docs-heading-anchor-permalink" href="#Stages" title="Permalink"></a></h2><p>A stage is a set of consecutive iterations in which we use a given pricing solver. The aim is to speed up the resolution of the pricing problem by first using an approximate but fast pricing algorithm and then switching to increasingly less heuristic algorithms until the last stage where an exact solver is used. and an exact solver at the last stage. Given a pricing solver, when the column generation does not progress anymore or the pricing solver does not return any new column, the default implementation switch to a more exact pricing solver. Stages are created using the <code>stages_pricing_solver_ids</code> of the <code>ColumnGenerationAlgorithm</code> parameter object. The default implementation implements the interface around the following object:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenStageIterator" href="#Coluna.Algorithm.ColGenStageIterator"><code>Coluna.Algorithm.ColGenStageIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default implementation of the column generation stages works as follows.</p><p>Consider a set {A,B,C} of subproblems each of them associated to the following sets of pricing solvers: {a1, a2, a3}, {b1, b2}, {c1, c2, c3, c4}. Pricing solvers a1, b1, c1 are exact solvers; others are heuristic.</p><p>The column generation algorithm will run the following stages:</p><ul><li>stage 4 with pricing solvers {a3, b2, c4}</li><li>stage 3 with pricing solvers {a2, b1, c3}</li><li>stage 2 with pricing solvers {a1, b1, c2}</li><li>stage 1 with pricing solvers {a1, b1, c1} (exact stage)</li></ul><p>Column generation moves from one stage to another when all solvers find no column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L314-L328">source</a></section></article><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenStage" href="#Coluna.ColGen.AbstractColGenStage"><code>Coluna.ColGen.AbstractColGenStage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A stage of the column generation algorithm. Each stage is associated to a specific solver for each pricing subproblem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenStageIterator" href="#Coluna.ColGen.AbstractColGenStageIterator"><code>Coluna.ColGen.AbstractColGenStageIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An iterator that indicates how stages follow each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.new_stage_iterator" href="#Coluna.ColGen.new_stage_iterator"><code>Coluna.ColGen.new_stage_iterator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a new stage iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.initial_stage" href="#Coluna.ColGen.initial_stage"><code>Coluna.ColGen.initial_stage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the stage at which the column generation algorithm must start.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.next_stage" href="#Coluna.ColGen.next_stage"><code>Coluna.ColGen.next_stage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the next stage that column generation must use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L22-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_pricing_subprob_optimizer" href="#Coluna.ColGen.get_pricing_subprob_optimizer"><code>Coluna.ColGen.get_pricing_subprob_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the optimizer for the pricing subproblem associated to the given stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.stage_id" href="#Coluna.ColGen.stage_id"><code>Coluna.ColGen.stage_id</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the id of the stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.is_exact_stage" href="#Coluna.ColGen.is_exact_stage"><code>Coluna.ColGen.is_exact_stage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if the stage uses an exact solver for the pricing subproblem; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stages.jl#L33">source</a></section></article><h2 id="Column-generation-iteration"><a class="docs-heading-anchor" href="#Column-generation-iteration">Column generation iteration</a><a id="Column-generation-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Column-generation-iteration" title="Permalink"></a></h2><p>This is a description of how the <code>Coluna.ColGen.run_colgen_iteration!</code> generic function behaves in the default implementation.</p><p>These are the main steps of a column generation iteration without stabilization. Click on the step to go to the relevant section.</p><div class="mermaid">flowchart TB;
    id1(Optimize master LP)
    id2{{Solution to master LP is integer?}}
    id3(Update incumbent primal solution if better than current one)
    id4(Compute reduced cost of subproblem variables)
    id5{{Subproblem iterator}}
    id6(Optimize pricing subproblem)
    id7(Push subproblem solution into set)
    id8(Compute dual bound)
    id9(Insert columns)
    id10(Iteration output)
    id1 --&gt; id2
    id2 --yes--&gt; id3
    id2 --no--&gt; id4
    id3 --&gt; id4
    id4 --&gt; id5
    id5 --subproblem--&gt; id6
    id6 --&gt; id7
    id7 --&gt; id5
    id5 --end--&gt; id8
    id8 --&gt; id9
    id9 --&gt; id10
    click id1 href &quot;#Optimize-master-LP&quot; &quot;Link to doc&quot;
    click id2 href &quot;#Check-integrality-of-the-master-LP-solution&quot; &quot;Link to doc&quot;
    click id3 href &quot;#Update-incumbent-primal-solution&quot; &quot;Link to doc&quot;
    click id4 href &quot;#Reduced-costs-calculation&quot; &quot;Link to doc&quot;
    click id5 href &quot;#Pricing-subproblem-iterator&quot; &quot;Link to doc&quot;
    click id6 href &quot;#Pricing-subproblem-optimization&quot; &quot;Link to doc&quot;
    click id7 href &quot;#Set-of-generated-columns&quot; &quot;Link to doc&quot;
    click id8 href &quot;#Dual-bound-calculation&quot; &quot;Link to doc&quot;
    click id9 href &quot;#Columns-insertion&quot; &quot;Link to doc&quot;
    click id10 href &quot;#Iteration-output&quot; &quot;Link to doc&quot;</div><h4 id="Optimize-master-LP"><a class="docs-heading-anchor" href="#Optimize-master-LP">Optimize master LP</a><a id="Optimize-master-LP-1"></a><a class="docs-heading-anchor-permalink" href="#Optimize-master-LP" title="Permalink"></a></h4><p>At each iteration, the algorithm requires a dual solution to the master LP to compute the reduced cost of subproblem variables.</p><p>The default implementation optimizes the master with an LP solver through MathOptInterface. It returns a primal and a dual solution.</p><p>In the default implementation, the master LP output is in the following data structure:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenMasterResult" href="#Coluna.Algorithm.ColGenMasterResult"><code>Coluna.Algorithm.ColGenMasterResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Output of the <code>ColGen.optimize_master_lp_problem!</code> method.</p><p>Contains <code>result</code>, an <code>OptimizationState</code> object that is the output of the <code>SolveLpForm</code> algorithm called to optimize the master LP problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L390-L395">source</a></section></article><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.optimize_master_lp_problem!" href="#Coluna.ColGen.optimize_master_lp_problem!"><code>Coluna.ColGen.optimize_master_lp_problem!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_master_lp_problem!(master, context, env) -&gt; MasterResult</code></pre><p>Returns an instance of a custom object <code>MasterResult</code> that implements the following methods:</p><ul><li><code>get_obj_val</code>: objective value of the master (mandatory)</li><li><code>get_primal_sol</code>: primal solution to the master (optional)</li><li><code>get_dual_sol</code>: dual solution to the master (mandatory otherwise column generation stops)</li></ul><p>It should at least return a dual solution (obtained with LP optimization or subgradient)  otherwise column generation cannot continue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L66-L76">source</a></section></article><p>You can see the additional methods to implement in the <a href="#Result-data-structures">result data structures</a> section.</p><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Check-the-integrality-of-the-master-LP-solution"><a class="docs-heading-anchor" href="#Check-the-integrality-of-the-master-LP-solution">Check the integrality of the master LP solution</a><a id="Check-the-integrality-of-the-master-LP-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Check-the-integrality-of-the-master-LP-solution" title="Permalink"></a></h4><p>The algorithm checks the integrality of the primal solution to the master LP to improve the global primal bound of the branch-cut-price algorithm.</p><p>In the default implementation, the integrality check is done using the <code>MathProg.proj_cols_is_integer</code> method. It implements the procedure described in the paper (TODO). Basically, it sorts the column used in the master LP primal solution in lexicographic order.  It assigns a weight to each column equal to the value of the column in the master LP solution.  It then forms columns of weight one by accumulating the columns of the fractional solution.  If columns are integral, the solution is integral. This is a heuristic procedure so it can miss some integer solutions.</p><p>If the solution is integral, the essential cut callback is called to make sure it is feasible.</p><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.check_primal_ip_feasibility!" href="#Coluna.ColGen.check_primal_ip_feasibility!"><code>Coluna.ColGen.check_primal_ip_feasibility!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a primal solution expressed in the original problem variables if the current master LP solution is integer feasible; <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L83-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.is_better_primal_sol" href="#Coluna.ColGen.is_better_primal_sol"><code>Coluna.ColGen.is_better_primal_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if the new master IP primal solution is better than the current; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L89-L91">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Update-incumbent-primal-solution"><a class="docs-heading-anchor" href="#Update-incumbent-primal-solution">Update incumbent primal solution</a><a id="Update-incumbent-primal-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Update-incumbent-primal-solution" title="Permalink"></a></h4><p>If the solution to master LP is integral and better than the current best one,  we need to update the incumbent. This solution is then used by the tree-search algorithm in the  bounding mechanism that prunes the nodes.</p><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.update_inc_primal_sol!" href="#Coluna.ColGen.update_inc_primal_sol!"><code>Coluna.ColGen.update_inc_primal_sol!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates the current master IP primal solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L97-L99">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Reduced-costs-calculation"><a class="docs-heading-anchor" href="#Reduced-costs-calculation">Reduced costs calculation</a><a id="Reduced-costs-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Reduced-costs-calculation" title="Permalink"></a></h4><p>Reduced costs calculation is written as a math operation in the <code>run_colgen_iteration!</code>  generic function. As a consequence, the dual solution to the master LP and the  implementation of the two following methods must return data structures that support math operations.</p><p>To speed up this operation, we cache data in the following data structure:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ReducedCostsCalculationHelper" href="#Coluna.Algorithm.ReducedCostsCalculationHelper"><code>Coluna.Algorithm.ReducedCostsCalculationHelper</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Extracted information to speed-up calculation of reduced costs of subproblem representatives and pure master variables. We extract from the master the information we need to compute the reduced cost of DW  subproblem variables:</p><ul><li><code>dw_subprob_c</code> contains the perenial cost of DW subproblem representative variables</li><li><code>dw_subprob_A</code> is a submatrix of the master coefficient matrix that involves only DW subproblem representative variables.</li></ul><p>We also extract from the master the information we need to compute the reduced cost of pure master variables:</p><ul><li><code>pure_master_c</code> contains the perenial cost of pure master variables</li><li><code>pure_master_A</code> is a submatrix of the master coefficient matrix that involves only pure master variables.</li></ul><p>Calculation is <code>c - transpose(A) * master_lp_dual_solution</code>.</p><p>This information is given to the generic implementation of the column generation algorithm through methods:</p><ul><li>ColGen.get<em>subprob</em>var<em>orig</em>costs </li><li>ColGen.get<em>orig</em>coefmatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/utils.jl#L86-L106">source</a></section></article><p>Reduced costs calculation also requires the implementation of the two following methods:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.update_master_constrs_dual_vals!" href="#Coluna.ColGen.update_master_constrs_dual_vals!"><code>Coluna.ColGen.update_master_constrs_dual_vals!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates dual value of the master constraints. Dual values of the constraints can be used when the pricing solver supports non-robust cuts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L105-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.update_reduced_costs!" href="#Coluna.ColGen.update_reduced_costs!"><code>Coluna.ColGen.update_reduced_costs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Method that you can implement if you want to store the reduced cost of subproblem variables in the context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L111-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_subprob_var_orig_costs" href="#Coluna.ColGen.get_subprob_var_orig_costs"><code>Coluna.ColGen.get_subprob_var_orig_costs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the original cost <code>c</code> of subproblems variables. to compute reduced cost <code>̄c = c - transpose(A) * π</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L117-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_subprob_var_coef_matrix" href="#Coluna.ColGen.get_subprob_var_coef_matrix"><code>Coluna.ColGen.get_subprob_var_coef_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the coefficient matrix <code>A</code> of subproblem variables in the master to compute reduced cost <code>̄c = c - transpose(A) * π</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L123-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.update_sp_vars_red_costs!" href="#Coluna.ColGen.update_sp_vars_red_costs!"><code>Coluna.ColGen.update_sp_vars_red_costs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates reduced costs of variables of a given subproblem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L129">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Pricing-subproblem-iterator"><a class="docs-heading-anchor" href="#Pricing-subproblem-iterator">Pricing subproblem iterator</a><a id="Pricing-subproblem-iterator-1"></a><a class="docs-heading-anchor-permalink" href="#Pricing-subproblem-iterator" title="Permalink"></a></h4><p>The pricing strategy is basically an iterator used to iterate over the pricing subproblems to optimize at each iteration of the column generation. The context can serve as a memory of the pricing strategy to change the way we iterate over subproblems between each column generation iteration.</p><p>The default implementation iterates over all subproblems.</p><p>Here are the references for the interface:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractPricingStrategy" href="#Coluna.ColGen.AbstractPricingStrategy"><code>Coluna.ColGen.AbstractPricingStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A pricing strategy defines how we iterate on pricing subproblems. A default pricing strategy consists in iterating on all pricing subproblems.</p><p>Basically, this object is used like this:</p><pre><code class="language-julia hljs">    pricing_strategy = ColGen.get_pricing_strategy(ctx, phase)
    next = ColGen.pricing_strategy_iterate(pricing_strategy)
    while !isnothing(next)
        (sp_id, sp_to_solve), state = next
        # Solve the subproblem `sp_to_solve`.
        next = ColGen.pricing_strategy_iterate(pricing_strategy, state)
    end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/pricing.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_pricing_strategy" href="#Coluna.ColGen.get_pricing_strategy"><code>Coluna.ColGen.get_pricing_strategy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_pricing_strategy(ctx, phase) -&gt; AbstractPricingStrategy</code></pre><p>Returns the pricing strategy object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/pricing.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.pricing_strategy_iterate" href="#Coluna.ColGen.pricing_strategy_iterate"><code>Coluna.ColGen.pricing_strategy_iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pricing_strategy_iterate(pricing_strategy) -&gt; ((sp_id, sp_to_solve), state)
pricing_strategy_iterate(pricing_strategy, state) -&gt; ((sp_id, sp_to_solve), state)</code></pre><p>Returns an iterator with the first pricing subproblem that must be optimized. The next subproblem is returned by a call to <code>Base.iterate</code> using the information provided by this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/pricing.jl#L29-L36">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Pricing-subproblem-optimization"><a class="docs-heading-anchor" href="#Pricing-subproblem-optimization">Pricing subproblem optimization</a><a id="Pricing-subproblem-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Pricing-subproblem-optimization" title="Permalink"></a></h4><p>At each iteration, the algorithm requires primal solutions to the pricing subproblems. The generic function supports multi-column generation so you can return any number of solutions.</p><p>The default implementation supports optimization of the pricing subproblems using a MILP solver or a pricing callback. Non-robust valid inequalities are not supported by MILP solvers as they change the structure of the subproblems. When using a pricing callback, you must be aware of how Coluna calculates the reduced cost of a column:</p><p>The reduced cost of a column is split into three contributions:</p><ul><li>the contribution of the subproblem variables that is the primal solution cost given the reduced cost of subproblem variables</li><li>the contribution of the non-robust constraints (i.e. master constraints that cannot be expressed using subproblem variables except the convexity constraint) that is not supported by MILP solver but that you must take into account in the pricing callback</li><li>the contribution of the master convexity constraint that is automatically taken into account by Coluna once the primal solution is returned.</li></ul><p>Therefore, when you use a pricing callback, you must not discard some columns based only on the primal solution cost because you don&#39;t know the contribution of the convexity constraint.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.GeneratedColumn" href="#Coluna.Algorithm.GeneratedColumn"><code>Coluna.Algorithm.GeneratedColumn</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Solution to a pricing subproblem after a given optimization.</p><p>It contains:</p><ul><li><code>column</code>: the solution stored as a <code>PrimalSolution</code> object</li><li><code>red_cost</code>: the reduced cost of the column</li><li><code>min_obj</code>: a boolean indicating if the objective is to minimize or maximize</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L570-L577">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenPricingResult" href="#Coluna.Algorithm.ColGenPricingResult"><code>Coluna.Algorithm.ColGenPricingResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Output of the default implementation of <code>ColGen.optimize_pricing_problem!</code>.</p><p>It contains:</p><ul><li><code>result</code>: the output of the <code>SolveIpForm</code> algorithm called to optimize the pricing subproblem</li><li><code>columns</code>: a vector of <code>GeneratedColumn</code> objects obtained by processing of the output of pricing subproblem optimization, it stores the reduced cost of each column</li><li><code>best_red_cost</code>: the best reduced cost of the columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L641-L648">source</a></section></article><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.optimize_pricing_problem!" href="#Coluna.ColGen.optimize_pricing_problem!"><code>Coluna.ColGen.optimize_pricing_problem!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_pricing_problem!(ctx, sp, env, optimizer, mast_dual_sol) -&gt; PricingResult</code></pre><p>Returns a custom object <code>PricingResult</code> that must implement the following functions:</p><ul><li><code>get_primal_sols</code>: array of primal solution to the pricing subproblem </li><li><code>get_primal_bound</code>: best reduced cost (optional ?)</li><li><code>get_dual_bound</code>: dual bound of the pricing subproblem (used to compute the master dual bound)</li><li><code>master_dual_sol</code>: dual solution <span>$\pi^{\text{out}}$</span> to the master problem used to compute the real reduced cost of the column when stabilization is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/pricing.jl#L43-L51">source</a></section></article><p>You can see the additional methods to implement in the <a href="#Result-data-structures">result data structures</a> section.</p><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Set-of-generated-columns"><a class="docs-heading-anchor" href="#Set-of-generated-columns">Set of generated columns</a><a id="Set-of-generated-columns-1"></a><a class="docs-heading-anchor-permalink" href="#Set-of-generated-columns" title="Permalink"></a></h4><p>You can define your data structure to manage the columns generated at a given iteration. Columns are inserted after the optimization of all pricing subproblems to allow the parallelization of the latter.</p><p>In the default implementation, we use the following data structure:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColumnsSet" href="#Coluna.Algorithm.ColumnsSet"><code>Coluna.Algorithm.ColumnsSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores a collection of columns.</p><p>It contains:</p><ul><li><code>columns</code>: a vector of <code>GeneratedColumn</code> objects by all pricing subproblems that will be inserted into the master</li><li><code>subprob_primal_solutions</code>: an object that stores the best columns generated by each pricing subproblem at this iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L618-L624">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.SubprobPrimalSolsSet" href="#Coluna.Algorithm.SubprobPrimalSolsSet"><code>Coluna.Algorithm.SubprobPrimalSolsSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Columns generated at the current iteration that forms the &quot;current primal solution&quot;. This is used to compute the Lagragian dual bound.</p><p>It contains:</p><ul><li><code>primal_sols</code> a dictionary that maps a formulation id to the best primal solution found by the pricing subproblem associated to this formulation</li><li><code>improve_master</code> a dictionary that maps a formulation id to a boolean indicating if the best primal solution found by the pricing subproblem associated to this formulation has negative reduced cost</li></ul><p>This structure also helps to compute the subgradient of the Lagrangian function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L588-L597">source</a></section></article><p>In the default implementation, <code>push_in_set!</code> is responsible for checking if the column has improving reduced cost. Only columns with improving reduced cost are inserted in the set. The <code>push_in_set!</code> is also responsible to insert he best primal solution to each pricing problem into the <code>SubprobPrimalSolsSet</code> object.</p><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.set_of_columns" href="#Coluna.ColGen.set_of_columns"><code>Coluna.ColGen.set_of_columns</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns an empty container that will store all the columns generated by the pricing problems during an iteration of the column generation algorithm. One must be able to iterate on this container to insert the columns in the master problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/pricing.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.push_in_set!" href="#Coluna.ColGen.push_in_set!"><code>Coluna.ColGen.push_in_set!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Pushes the column in the set of columns generated at a given iteration of the column generation algorithm. Columns stored in the set will then be considered for insertion in the master problem. Returns <code>true</code> if column was inserted in the set, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/pricing.jl#L66-L71">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Dual-bound-calculation"><a class="docs-heading-anchor" href="#Dual-bound-calculation">Dual bound calculation</a><a id="Dual-bound-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-bound-calculation" title="Permalink"></a></h4><p>In the default implementation,  given a vector <span>$\pi \geq 0$</span> of dual values to the master constraints (1), the Lagrangian  dual function is given by:</p><p class="math-container">\[L(\pi) = \pi a + \sum_{k \in K} \max_{l_k \leq \mathbf{1} \lambda^k \leq u^k} (c^k - \pi A^k)\lambda^k + \max_{ \bar{l} \leq y \leq \bar{u}} (\bar{c} - \pi \bar{A})y\]</p><p>Let:</p><ul><li>element <span>$z_k(\pi) \leq \min_i (c^k_i - \pi A^k_i)$</span> be a lower bound on the solution value of the pricing problem</li><li>element <span>$\bar{z}_j(\pi) = \bar{c} - \pi \bar{A}$</span> be the reduced cost of pure master variable <span>$y_j$</span></li></ul><p>Then, the Lagrangian dual function can be lower bounded by:</p><p class="math-container">\[L(\pi) \geq \pi a + \sum_{k \in K} \max\{ z_k(\pi) \cdot l_k,  z_k(\pi) \cdot u_k \}  + \sum_{j \in J}  \max\{ \bar{z}_j(\pi) \cdot \bar{l}_j,  \bar{z}_j(\pi) \cdot \bar{u}_j\}\]</p><p>More precisely:</p><ul><li>the first term is the contribution of the master obtained by removing the contribution of the convexity constraints (computed by <code>ColGen.Algorithm._convexity_contrib</code>), and the pure master variables (but you should see the third term) from the master LP solution value</li><li>the second term is the contribution of the subproblem variables which is the sum of the best solution value of each pricing subproblem multiplied by the lower and upper multiplicity of the subproblem depending on whether the reduced cost is negative or positive (this is computed by <code>ColGen.Algorithm._subprob_contrib</code>)</li><li>the third term is the contribution of the pure master variables which is taken into account by master LP value.</li></ul><p>Therefore, we can compute the Lagrangian dual bound as follows:</p><pre><code class="language-julia hljs">master_lp_obj_val - convexity_contrib + sp_contrib</code></pre><p>However, if the smoothing stabilization is active, we compute the dual bound at the sep-point. As a consequence, we can&#39;t use the master LP value because it corresponds to the dual solution at the out-point. We therefore need to compute the lagrangian dual bound by strictly applying the above formula.</p><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.compute_sp_init_pb" href="#Coluna.ColGen.compute_sp_init_pb"><code>Coluna.ColGen.compute_sp_init_pb</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns an initial primal bound for a pricing subproblem. Default value should be +/- infinite depending on the optimization sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L141-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.compute_sp_init_db" href="#Coluna.ColGen.compute_sp_init_db"><code>Coluna.ColGen.compute_sp_init_db</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns an initial dual bound for a pricing subproblem. Default value should be +/- infinite depending on the optimization sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L135-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.compute_dual_bound" href="#Coluna.ColGen.compute_dual_bound"><code>Coluna.ColGen.compute_dual_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_dual_bound(ctx, phase, master_lp_obj_val, master_dbs, generated_columns, mast_dual_sol) -&gt; Float64</code></pre><p>Caculates the dual bound at a given iteration of column generation. The dual bound is composed of:</p><ul><li><code>master_lp_obj_val</code>: objective value of the master LP problem</li><li><code>master_dbs</code>: dual values of the pricing subproblems</li><li>the contribution of the master convexity constraints that you should compute from <code>mast_dual_sol</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L147-L155">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Columns-insertion"><a class="docs-heading-anchor" href="#Columns-insertion">Columns insertion</a><a id="Columns-insertion-1"></a><a class="docs-heading-anchor-permalink" href="#Columns-insertion" title="Permalink"></a></h4><p>The default implementation inserts into the master all the columns stored in the <code>ColumnsSet</code> object.</p><p><strong>Reference</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.insert_columns!" href="#Coluna.ColGen.insert_columns!"><code>Coluna.ColGen.insert_columns!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Inserts columns into the master. Returns the number of columns inserted. Implementation is responsible for checking if the column must be inserted and warn the user if something unexpected happens.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L162-L166">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h4 id="Iteration-output"><a class="docs-heading-anchor" href="#Iteration-output">Iteration output</a><a id="Iteration-output-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration-output" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColGenIterationOutput" href="#Coluna.Algorithm.ColGenIterationOutput"><code>Coluna.Algorithm.ColGenIterationOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object for the output of an iteration of the column generation default implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/default.jl#L824">source</a></section></article><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenIterationOutput" href="#Coluna.ColGen.AbstractColGenIterationOutput"><code>Coluna.ColGen.AbstractColGenIterationOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for the objects that contains the output of a column generation iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.colgen_iteration_output_type" href="#Coluna.ColGen.colgen_iteration_output_type"><code>Coluna.ColGen.colgen_iteration_output_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colgen_iteration_output_type(ctx) -&gt; Type{&lt;:AbstractColGenIterationOutput}</code></pre><p>Returns the type of the column generation iteration output associated to the context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.new_iteration_output" href="#Coluna.ColGen.new_iteration_output"><code>Coluna.ColGen.new_iteration_output</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">new_iteration_output(::Type{&lt;:AbstractColGenIterationOutput}, args...) -&gt; AbstractColGenIterationOutput</code></pre><p>Arguments (i.e. <code>arg...</code>) of this function are the following:</p><ul><li><code>min_sense</code>: <code>true</code> if the objective is a minimization function; <code>false</code> otherwise</li><li><code>mlp</code>: the optimal solution value of the master LP</li><li><code>db</code>: the Lagrangian dual bound</li><li><code>nb_new_cols</code>: the number of columns inserted into the master</li><li><code>new_cut_in_master</code>: <code>true</code> if valid inequalities or new constraints added into the master; <code>false</code> otherwise</li><li><code>infeasible_master</code>: <code>true</code> if the master is proven infeasible; <code>false</code> otherwise</li><li><code>unbounded_master</code>: <code>true</code> if the master is unbounded; <code>false</code> otherwise</li><li><code>infeasible_subproblem</code>: <code>true</code> if a pricing subproblem is proven infeasible; <code>false</code> otherwise</li><li><code>unbounded_subproblem</code>: <code>true</code> if a pricing subproblem is unbounded; <code>false</code> otherwise</li><li><code>time_limit_reached</code>: <code>true</code> if time limit is reached; <code>false</code> otherwise</li><li><code>master_primal_sol</code>: the primal master LP solution</li><li><code>ip_primal_sol</code>: the incumbent primal master solution</li><li><code>dual_sol</code>: the dual master LP solution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L182-L199">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h3 id="Getters-for-Result-data-structures"><a class="docs-heading-anchor" href="#Getters-for-Result-data-structures">Getters for Result data structures</a><a id="Getters-for-Result-data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Getters-for-Result-data-structures" title="Permalink"></a></h3><table><tr><th style="text-align: right">Method name</th><th style="text-align: right">Master</th><th style="text-align: right">Pricing</th></tr><tr><td style="text-align: right"><code>is_unbounded</code></td><td style="text-align: right">X</td><td style="text-align: right">X</td></tr><tr><td style="text-align: right"><code>is_infeasible</code></td><td style="text-align: right">X</td><td style="text-align: right">X</td></tr><tr><td style="text-align: right"><code>get_primal_sol</code></td><td style="text-align: right">X</td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>get_primal_sols</code></td><td style="text-align: right"></td><td style="text-align: right">X</td></tr><tr><td style="text-align: right"><code>get_dual_sol</code></td><td style="text-align: right">X</td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>get_obj_val</code></td><td style="text-align: right">X</td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>get_primal_bound</code></td><td style="text-align: right"></td><td style="text-align: right">X</td></tr><tr><td style="text-align: right"><code>get_dual_bound</code></td><td style="text-align: right"></td><td style="text-align: right">X</td></tr></table><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.is_unbounded" href="#Coluna.ColGen.is_unbounded"><code>Coluna.ColGen.is_unbounded</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true if a master or pricing problem result is unbounded; false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.is_infeasible" href="#Coluna.ColGen.is_infeasible"><code>Coluna.ColGen.is_infeasible</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true if a master or pricing problem result is infeasible; false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_primal_sol" href="#Coluna.ColGen.get_primal_sol"><code>Coluna.ColGen.get_primal_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns primal solution to the master LP problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_primal_sols" href="#Coluna.ColGen.get_primal_sols"><code>Coluna.ColGen.get_primal_sols</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Array of primal solutions to the pricing subproblem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_dual_sol" href="#Coluna.ColGen.get_dual_sol"><code>Coluna.ColGen.get_dual_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns dual solution to the master optimization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_obj_val" href="#Coluna.ColGen.get_obj_val"><code>Coluna.ColGen.get_obj_val</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the optimal objective value of the master LP problem.&quot; See <code>optimize_master_lp_problem!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_primal_bound" href="#Coluna.ColGen.get_primal_bound"><code>Coluna.ColGen.get_primal_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns primal bound of the pricing subproblem; <code>nothing</code> if no primal bound is available and the initial dual bound returned by <code>compute_sp_init_pb</code> will be used to compute the pseudo dual bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L55-L59">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h3 id="Getters-for-Output-data-structures"><a class="docs-heading-anchor" href="#Getters-for-Output-data-structures">Getters for Output data structures</a><a id="Getters-for-Output-data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Getters-for-Output-data-structures" title="Permalink"></a></h3><table><tr><th style="text-align: right">Method name</th><th style="text-align: right">ColGen</th><th style="text-align: right">Phase</th><th style="text-align: right">Iteration</th></tr><tr><td style="text-align: right"><code>get_nb_new_cols</code></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">X</td></tr><tr><td style="text-align: right"><code>get_master_ip_primal_sol</code></td><td style="text-align: right">X</td><td style="text-align: right">X</td><td style="text-align: right">X</td></tr><tr><td style="text-align: right"><code>get_master_lp_primal_sol</code></td><td style="text-align: right">X</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>get_master_dual_sol</code></td><td style="text-align: right">X</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>get_dual_bound</code></td><td style="text-align: right">X</td><td style="text-align: right"></td><td style="text-align: right">X</td></tr><tr><td style="text-align: right"><code>get_master_lp_primal_bound</code></td><td style="text-align: right">X</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>is_infeasible</code></td><td style="text-align: right">X</td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_nb_new_cols" href="#Coluna.ColGen.get_nb_new_cols"><code>Coluna.ColGen.get_nb_new_cols</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the number of new columns inserted into the master at the end of an iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_master_ip_primal_sol" href="#Coluna.ColGen.get_master_ip_primal_sol"><code>Coluna.ColGen.get_master_ip_primal_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the incumbent primal master IP solution at the end of an iteration or a phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_master_lp_primal_sol" href="#Coluna.ColGen.get_master_lp_primal_sol"><code>Coluna.ColGen.get_master_lp_primal_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the primal master LP solution found at the last iteration of the column generation algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_master_dual_sol" href="#Coluna.ColGen.get_master_dual_sol"><code>Coluna.ColGen.get_master_dual_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the dual master LP solution found at the last iteration of the column generation algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_master_lp_primal_bound" href="#Coluna.ColGen.get_master_lp_primal_bound"><code>Coluna.ColGen.get_master_lp_primal_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the master LP solution value at the last iteration of the column generation algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/interface.jl#L286">source</a></section></article><p>Go back to the <a href="#Column-generation-iteration">column generation iteration overview</a>.</p><h2 id="Stabilization"><a class="docs-heading-anchor" href="#Stabilization">Stabilization</a><a id="Stabilization-1"></a><a class="docs-heading-anchor-permalink" href="#Stabilization" title="Permalink"></a></h2><p>Coluna provides a default implementation of the smoothing stabilization with a self-adjusted <span>$\alpha$</span> parameter, <span>$0 \leq \alpha &lt; 1$</span>.</p><p>At each iteration of the column generation algorithm, instead of generating columns for the dual solution to the master LP, we generate columns for a perturbed dual solution defined as follows:</p><p class="math-container">\[\pi^{\text{sep}} = \alpha \pi^{\text{in}} + (1-\alpha) \pi^{\text{out}}\]</p><p>where <span>$\pi^{\text{in}}$</span> is the dual solution that gives the best Lagrangian dual bound so far (also called stabilization center) and <span>$\pi^{\text{out}}$</span> is the dual solution to the master LP at the current iteration.  This solution is returned by the default implementation of <code>Coluna.ColGen.get_stab_dual_sol</code>.</p><p>Some elements of the column generation change when using stabilization.</p><ul><li>Columns are generated using the smoothed dual solution <span>$\pi^{\text{sep}}$</span> but we still need to compute the reduced cost of the columns using the original dual solution <span>$\pi^{\text{out}}$</span>.</li><li>The dual bound is computed using the smoothed dual solution <span>$\pi^{\text{sep}}$</span>.</li><li>The pseudo bound is computed using the smoothed dual solution <span>$\pi^{\text{sep}}$</span>.</li><li>The smoothed dual bound can result in the generation of no improving columns. This is called a <strong>misprice</strong>. In that case, we need to move away from the stabilization center <span>$\pi^{\text{in}}$</span> by decreasing <span>$\alpha$</span>.</li></ul><p>When using self-adjusted stabilization, the smoothing coefficient <span>$\alpha$</span> is adjusted to make the smoothed dual solution <span>$\pi^{\text{sep}}$</span> closer to the best possible dual solution on the line between <span>$\pi^{\text{in}}$</span> and <span>$\pi^{\text{out}}$</span> (i.e. where the subgradient of the current primal solution is perpendicular to the latter line). To compute the subgradient, we use the following data structure:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.SubgradientCalculationHelper" href="#Coluna.Algorithm.SubgradientCalculationHelper"><code>Coluna.Algorithm.SubgradientCalculationHelper</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Precompute information to speed-up calculation of subgradient of master variables. We extract from the master follwowing information:</p><ul><li><code>a</code> contains the perenial rhs of all master constraints except convexity constraints;</li><li><code>A</code> is a submatrix of the master coefficient matrix that involves only representative of original variables (pure master vars + DW subproblem represtative vars) </li></ul><p>Calculation is <code>a - A * (m .* z)</code> where :</p><ul><li><code>m</code> contains a multiplicity factor for each variable involved in the calculation     (lower or upper sp multiplicity depending on variable reduced cost);</li><li><code>z</code> is the concatenation of the solution to the master (for pure master vars) and pricing     subproblems (for DW subproblem represtative vars).</li></ul><p>Operation <code>m .* z</code> &quot;mimics&quot; a solution in the original space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/Algorithm/colgen/utils.jl#L150-L165">source</a></section></article><p><strong>References</strong>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.setup_stabilization!" href="#Coluna.ColGen.setup_stabilization!"><code>Coluna.ColGen.setup_stabilization!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns an instance of a data structure that contain information about the stabilization used in the column generation algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stabilization.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.update_stabilization_after_master_optim!" href="#Coluna.ColGen.update_stabilization_after_master_optim!"><code>Coluna.ColGen.update_stabilization_after_master_optim!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_stabilization_after_master_optim!(stab, phase, mast_dual_sol) -&gt; Bool</code></pre><p>Update stabilization after master optimization where <code>mast_dual_sol</code> is the dual solution to the master problem. Returns <code>true</code> if the stabilization will change the dual solution used for the pricing in the current  column generation iteration, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stabilization.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_stab_dual_sol" href="#Coluna.ColGen.get_stab_dual_sol"><code>Coluna.ColGen.get_stab_dual_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the dual solution used for the pricing in the current column generation iteration (stabilized dual solution).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stabilization.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.check_misprice" href="#Coluna.ColGen.check_misprice"><code>Coluna.ColGen.check_misprice</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if the stabilized dual solution leads to a misprice, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stabilization.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.update_stabilization_after_pricing_optim!" href="#Coluna.ColGen.update_stabilization_after_pricing_optim!"><code>Coluna.ColGen.update_stabilization_after_pricing_optim!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates stabilization after pricing optimization where:</p><ul><li><code>mast_dual_sol</code> is the dual solution to the master problem</li><li><code>valid_db</code> is the valid dual bound of the problem after optimization of the pricing problems</li><li><code>pseudo_db</code> is the pseudo dual bound of the problem after optimization of the pricing problems</li><li><code>mast_dual_sol</code> is the dual solution to the master problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stabilization.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.update_stabilization_after_misprice!" href="#Coluna.ColGen.update_stabilization_after_misprice!"><code>Coluna.ColGen.update_stabilization_after_misprice!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates stabilization after a misprice. Argument <code>mast_dual_sol</code> is the dual solution to the master problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stabilization.jl#L35-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.update_stabilization_after_iter!" href="#Coluna.ColGen.update_stabilization_after_iter!"><code>Coluna.ColGen.update_stabilization_after_iter!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates stabilization after an iteration of the column generation algorithm. Arguments:</p><ul><li><code>stab</code> is the stabilization data structure</li><li><code>ctx</code> is the column generation context</li><li><code>master</code> is the master problem</li><li><code>generated_columns</code> is the set of generated columns</li><li><code>mast_dual_sol</code> is the dual solution to the master problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stabilization.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.ColGen.get_output_str" href="#Coluna.ColGen.get_output_str"><code>Coluna.ColGen.get_output_str</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a string with a short information about the stabilization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/238204544ee2191f0a3cd50915e2a97d6cee32a6/src/ColGen/stabilization.jl#L51">source</a></section></article><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../branching/">« Branching</a><a class="docs-footer-nextpage" href="../treesearch/">TreeSearch »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Thursday 28 September 2023 14:32">Thursday 28 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
