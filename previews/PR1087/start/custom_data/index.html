<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Custom data · Coluna.jl</title><meta name="title" content="Custom data · Coluna.jl"/><meta property="og:title" content="Custom data · Coluna.jl"/><meta property="twitter:title" content="Custom data · Coluna.jl"/><meta name="description" content="Documentation for Coluna.jl."/><meta property="og:description" content="Documentation for Coluna.jl."/><meta property="twitter:description" content="Documentation for Coluna.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/js/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox" checked/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting Started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../start/">Column generation</a></li><li><a class="tocitem" href="../cuts/">Cut Generation</a></li><li><a class="tocitem" href="../pricing/">Pricing callback</a></li><li><a class="tocitem" href="../identical_sp/">Identical subproblems</a></li><li class="is-active"><a class="tocitem" href>Custom data</a><ul class="internal"><li><a class="tocitem" href="#Custom-data-for-non-robust-cuts"><span>Custom data for non-robust cuts</span></a></li><li><a class="tocitem" href="#Pricing-callback"><span>Pricing callback</span></a></li><li><a class="tocitem" href="#Non-robust-cut-separation-callback."><span>Non-robust cut separation callback.</span></a></li></ul></li><li><a class="tocitem" href="../initial_columns/">Initial columns callback</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Advanced tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../advanced_demo/">Column Generation and Benders on Location Routing</a></li><li><a class="tocitem" href="../other_pbs/">Other classic problems</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Decomposition</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/decomposition/">Decomposition paradigms</a></li><li><a class="tocitem" href="../../man/blockdecomposition/">Setup decomposition using BlockDecomposition</a></li></ul></li><li><a class="tocitem" href="../../man/config/">Configuration</a></li><li><a class="tocitem" href="../../man/algorithm/">Built-in algorithms</a></li><li><a class="tocitem" href="../../man/callbacks/">User-defined Callbacks</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/algos/">Algorithms</a></li><li><a class="tocitem" href="../../api/benders/">Benders</a></li><li><a class="tocitem" href="../../api/branching/">Branching</a></li><li><a class="tocitem" href="../../api/colgen/">ColGen</a></li><li><a class="tocitem" href="../../api/treesearch/">TreeSearch</a></li><li><a class="tocitem" href="../../api/storage/">Storage</a></li></ul></li><li><a class="tocitem" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays</a></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href>Custom data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Custom data</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/atoptima/Coluna.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/start/custom_data.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tuto_custom_data"><a class="docs-heading-anchor" href="#tuto_custom_data">Custom Variables and Cuts</a><a id="tuto_custom_data-1"></a><a class="docs-heading-anchor-permalink" href="#tuto_custom_data" title="Permalink"></a></h1><p>Coluna allows users to attach custom data to variables and constraints. This data is useful to store information about the variables or constraints in a custom format much easier to process than extracted information from the formulation (coefficient matrix, bounds, costs, and right-hand side).</p><p>In this example, we will show how to attach custom data to variables and constraints and use them to separate non-robust cuts. We will use the Bin Packing problem as an example.</p><p>Let us consider a Bin Packing problem with only 3 items such that any pair of items fits into one bin but the 3 items do not. The objective function is to minimize the number of bins being used. Pricing is done by inspection over the 6 combinations of items (3 pairs and 3 singletons). The master LP solution has 1.5 bins at the root node, each 0.5 corresponding to a bin with one of the possible pairs of items.</p><p>In this example, we will show you how to use non-robust cuts to improve the master LP solution at the root node. Obviously, Coluna is able to solve this instance by branching on the number of bins but the limit one on the number of nodes prevents it to be solved without cuts.</p><p>We define the dependencies:</p><pre><code class="language-julia hljs">using JuMP, BlockDecomposition, Coluna, GLPK;</code></pre><p>We define the solver.</p><pre><code class="language-julia hljs">coluna = JuMP.optimizer_with_attributes(
    Coluna.Optimizer,
    &quot;default_optimizer&quot; =&gt; GLPK.Optimizer,
    &quot;params&quot; =&gt; Coluna.Params(
        solver = Coluna.Algorithm.TreeSearchAlgorithm(
            conqueralg = Coluna.Algorithm.ColCutGenConquer(
                colgen = Coluna.Algorithm.ColumnGeneration(
                            pricing_prob_solve_alg = Coluna.Algorithm.SolveIpForm(
                                optimizer_id = 1
                            ))
            ),
            maxnumnodes = 1 # we only treat the root node.
        )
    )
);</code></pre><p>Let&#39;s define the model. Let&#39;s <span>$B$</span> the set of bins and <span>$I$</span> the set of items. We introduce variable <span>$y_b$</span> that is equal to 1 if a bin <span>$b$</span> is used and 0 otherwise. We introduce variable <span>$x_{b,i}$</span> that is equal to 1 if item <span>$i$</span> is put in a bin <span>$b$</span> and 0 otherwise.</p><pre><code class="language-julia hljs">model = BlockModel(coluna);</code></pre><p>We must assign three items:</p><pre><code class="language-julia hljs">I = [1, 2, 3];</code></pre><p>And we have three bins:</p><pre><code class="language-julia hljs">B = [1, 2, 3];</code></pre><p>Each bin is defining a subproblem, we declare our axis:</p><pre><code class="language-julia hljs">@axis(axis, collect(B));</code></pre><p>We declare subproblem variables <code>y[b]</code>:</p><pre><code class="language-julia hljs">@variable(model, y[b in axis], Bin);</code></pre><p>And <code>x[b,i]</code>:</p><pre><code class="language-julia hljs">@variable(model, x[b in axis, i in I], Bin);</code></pre><p>Each item must be assigned to one bin:</p><pre><code class="language-julia hljs">@constraint(model, sp[i in I], sum(x[b,i] for b in axis) == 1);</code></pre><p>We minimize the number of bins and we declare the decomposition:</p><pre><code class="language-julia hljs">@objective(model, Min, sum(y[b] for b in axis))
@dantzig_wolfe_decomposition(model, dec, axis);</code></pre><h2 id="Custom-data-for-non-robust-cuts"><a class="docs-heading-anchor" href="#Custom-data-for-non-robust-cuts">Custom data for non-robust cuts</a><a id="Custom-data-for-non-robust-cuts-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-data-for-non-robust-cuts" title="Permalink"></a></h2><p>As said previously, at the end of the column generation at the root node, the master LP solution has 1.5 bins. It corresponds to three bins, each of them used 0.5 times containing one pair <code>(1,2)</code>, <code>(1, 3)</code>, or <code>(2, 3)</code> of items. We are going to introduce the following non-robust cut to make the master LP solution integral:</p><p class="math-container">\[\sum\limits_{s \in S~if~length(s) \geq 2} λ_s \leq 1\]</p><p>where :</p><ul><li><span>$S$</span> is the set of possible bin assignments generated by the pricing problem.</li><li><span>$length(s)$</span> the number of items in bin assignment <span>$s \in S$</span>.</li></ul><p>This cut means that we cannot have more than one bin with at least two items.</p><p>But the problem is that the cut is expressed over the master column and we don&#39;t have access to these variables from the JuMP model. To address this problem, Coluna offers a way to compute the coefficient of a column in a constraint by implementing the following method:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.MathProg.computecoeff" href="#Coluna.MathProg.computecoeff"><code>Coluna.MathProg.computecoeff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">computecoeff(var_custom_data, constr_custom_data) -&gt; Float64</code></pre><p>Dispatches on the type of custom data attached to the variable and the constraint to compute the coefficient of the variable in the constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/980d2f4bd42e5a4d8aad0c489b682d944c727d81/src/MathProg/formulation.jl#L199-L204">source</a></section></article><p>We therefore need to attach custom data to the master columns and the non-robust cut to use the method <code>compute_coeff</code>.</p><p>For every subproblem solution <span>$s$</span>, we define custom data with the number of items in the bin.</p><pre><code class="language-julia hljs">struct MyCustomVarData &lt;: BlockDecomposition.AbstractCustomData
    nb_items::Int
end
BlockDecomposition.customvars!(model, MyCustomVarData);</code></pre><p>We define custom data for the cut that will contain the minimum number of items in a bin that can be used. The value will be <code>2</code> in this example.</p><pre><code class="language-julia hljs">struct MyCustomCutData &lt;: BlockDecomposition.AbstractCustomData
    min_items::Int
end
BlockDecomposition.customconstrs!(model, MyCustomCutData);</code></pre><p>We implement the <code>computecoeff</code> method for the custom data we defined.</p><pre><code class="language-julia hljs">function Coluna.MathProg.computecoeff(
    var_custom_data::MyCustomVarData, constr_custom_data::MyCustomCutData
)
    return (var_custom_data.nb_items &gt;= constr_custom_data.min_items) ? 1.0 : 0.0
end</code></pre><h2 id="Pricing-callback"><a class="docs-heading-anchor" href="#Pricing-callback">Pricing callback</a><a id="Pricing-callback-1"></a><a class="docs-heading-anchor-permalink" href="#Pricing-callback" title="Permalink"></a></h2><p>We define the pricing callback that will generate the bin with best-reduced cost. Be careful, when using non-robust cuts, you must take into account the contribution of the non-robust cuts to the reduced cost of your solution.</p><pre><code class="language-julia hljs">function my_pricing_callback(cbdata)
    # Get the reduced costs of the original variables.
    I = [1, 2, 3]
    b = BlockDecomposition.callback_spid(cbdata, model)

    rc_y = BlockDecomposition.callback_reduced_cost(cbdata, y[b])
    rc_x = [BlockDecomposition.callback_reduced_cost(cbdata, x[b, i]) for i in I]

    # Get the dual values of the custom cuts (to calculate contributions of
    # non-robust cuts to the cost of the solution).
    custduals = Tuple{Int, Float64}[]
    for (_, constr) in Coluna.MathProg.getconstrs(cbdata.form.parent_formulation)
        if typeof(constr.custom_data) == MyCustomCutData
            push!(custduals, (
                constr.custom_data.min_items,
                Coluna.MathProg.getcurincval(cbdata.form.parent_formulation, constr)
            ))
        end
    end

    # Pricing by inspection.
    sols = [[1], [2], [3], [1, 2], [1, 3], [2, 3]]
    best_s = Int[]
    best_rc = Inf
    for s in sols
        rc_s = rc_y + sum(rc_x[i] for i in s) # reduced cost of the subproblem variables
        if !isempty(custduals)
            # contribution of the non-robust cuts
            rc_s -= sum((length(s) &gt;= minits) ? dual : 0.0 for (minits, dual) in custduals)
        end
        if rc_s &lt; best_rc
            best_rc = rc_s
            best_s = s
        end
    end
    @show best_s
    # build the best one and submit
    solcost = best_rc
    solvars = JuMP.VariableRef[]
    solvarvals = Float64[]
    for i in best_s
        push!(solvars, x[b, i])
        push!(solvarvals, 1.0)
    end
    push!(solvars, y[b])
    push!(solvarvals, 1.0)
    # submit the solution
    MOI.submit(
        model, BlockDecomposition.PricingSolution(cbdata),
        solcost,
        solvars,
        solvarvals,
        MyCustomVarData(length(best_s)) # attach a custom data to the column
    )

    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), solcost)
    return
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_pricing_callback (generic function with 1 method)</code></pre><p>The pricing callback is done, we define it as the solver of our pricing problem.</p><pre><code class="language-julia hljs">subproblems = BlockDecomposition.getsubproblems(dec)
BlockDecomposition.specify!.(
    subproblems,
    solver = my_pricing_callback
);</code></pre><h2 id="Non-robust-cut-separation-callback."><a class="docs-heading-anchor" href="#Non-robust-cut-separation-callback.">Non-robust cut separation callback.</a><a id="Non-robust-cut-separation-callback.-1"></a><a class="docs-heading-anchor-permalink" href="#Non-robust-cut-separation-callback." title="Permalink"></a></h2><p>We now define the cut separation callback for our non-robust cut. This is the same callback as the one used for robust cuts. There is just one slight difference when you submit the non-robust cut. Since cuts are expressed over the master variables and these variables are inaccessible from the JuMP model, you&#39;ll submit a constraint with an empty left-hand side and you&#39;ll leave Coluna populate the left-hand side with the values returned by <code>Coluna.MathProg.computecoeff</code>.</p><p>So let&#39;s define the callback. Basically, if the solution uses more than one bin with two items, The cut is added to the model.</p><pre><code class="language-julia hljs">function custom_cut_sep(cbdata)
    # Compute the constraint violation by iterating over the master solution.
    viol = -1.0
    for (varid, varval) in cbdata.orig_sol
        var = Coluna.MathProg.getvar(cbdata.form, varid)
        if !isnothing(var.custom_data)
            if var.custom_data.nb_items &gt;= 2
                viol += varval
            end
        end
    end
    # Add the cut (at most one variable with 2 or more of the 3 items) if violated.
    if viol &gt; 0.001
        MOI.submit(
            model, MOI.UserCut(cbdata),
            JuMP.ScalarConstraint(
                JuMP.AffExpr(0.0), # We cannot express the left-hand side so we push 0.
                MOI.LessThan(1.0)
            ),
            MyCustomCutData(2) # Cut custom data.
        )
    end
    return
end

MOI.set(model, MOI.UserCutCallback(), custom_cut_sep)
JuMP.optimize!(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Coluna
Version 0.7.0 | https://github.com/atoptima/Coluna.jl
***************************************************************************************
**** B&amp;B tree root node
**** Local DB = -Inf, global bounds: [ -Inf , Inf ], time = 0.00 sec.
***************************************************************************************
best_s = [1, 2]
best_s = [1, 2]
best_s = [1, 2]
  &lt;st= 1&gt; &lt;it=  1&gt; &lt;et= 1.27&gt; &lt;mst= 0.01&gt; &lt;sp= 0.00&gt; &lt;cols= 3&gt; &lt;al= 0.00&gt; &lt;DB=-29997.0000&gt; &lt;mlp=60000.0000&gt; &lt;PB=Inf&gt;
best_s = [1, 3]
best_s = [1, 3]
best_s = [1, 3]
  &lt;st= 1&gt; &lt;it=  2&gt; &lt;et= 1.30&gt; &lt;mst= 0.03&gt; &lt;sp= 0.00&gt; &lt;cols= 3&gt; &lt;al= 0.00&gt; &lt;DB=-29999.0000&gt; &lt;mlp=30001.0000&gt; &lt;PB=Inf&gt;
best_s = [2, 3]
best_s = [2, 3]
best_s = [2, 3]
  &lt;st= 1&gt; &lt;it=  3&gt; &lt;et= 1.30&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 3&gt; &lt;al= 0.00&gt; &lt;DB=-10001.0000&gt; &lt;mlp=20002.0000&gt; &lt;PB=Inf&gt;
best_s = [1]
best_s = [1]
best_s = [1]
  &lt;st= 1&gt; &lt;it=  4&gt; &lt;et= 1.30&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 3&gt; &lt;al= 0.00&gt; &lt;DB=    3.0000&gt; &lt;mlp=15001.5000&gt; &lt;PB=Inf&gt;
best_s = [3]
best_s = [3]
best_s = [3]
  &lt;st= 1&gt; &lt;it=  5&gt; &lt;et= 1.30&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 3&gt; &lt;al= 0.00&gt; &lt;DB=-19995.0000&gt; &lt;mlp=10002.0000&gt; &lt;PB=Inf&gt;
best_s = [2]
best_s = [2]
best_s = [2]
  &lt;st= 1&gt; &lt;it=  6&gt; &lt;et= 1.30&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 3&gt; &lt;al= 0.00&gt; &lt;DB=-19995.0000&gt; &lt;mlp=10002.0000&gt; &lt;PB=Inf&gt;
Cut separation callback adds 0 new essential cuts and 0 new facultative cuts.
best_s = [1]
best_s = [1]
best_s = [1]
  &lt;st= 1&gt; &lt;it=  7&gt; &lt;et= 1.30&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=    3.0000&gt; &lt;mlp=    3.0000&gt; &lt;PB=3.0000&gt;
 ──────────────────────────────────────────────────────────────────────────
                                  Time                    Allocations
                         ───────────────────────   ────────────────────────
    Tot / % measured:         6.60s /  19.8%           2.30GiB /   3.2%

 Section         ncalls     time    %tot     avg     alloc    %tot      avg
 ──────────────────────────────────────────────────────────────────────────
 Coluna               1    1.30s  100.0%   1.30s   75.5MiB  100.0%  75.5MiB
   SolveLpForm        7   37.0ms    2.8%  5.28ms   1.96MiB    2.6%   286KiB
 ──────────────────────────────────────────────────────────────────────────
[ Info: Terminated
[ Info: Primal bound: 3.0
[ Info: Dual bound: 3.0</code></pre><p>We see on the output that the algorithm has converged a first time before a cut is added. Coluna then starts a new iteration taking into account the cut. We notice here an improvement of the value of the dual bound: before the cut, we converge towards 1.5. After the cut, we reach 2.0.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../identical_sp/">« Identical subproblems</a><a class="docs-footer-nextpage" href="../initial_columns/">Initial columns callback »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Friday 6 October 2023 13:27">Friday 6 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
