<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ColGen · Coluna User Guide</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/js/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna User Guide</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/start/">Column generation</a></li><li><a class="tocitem" href="../../start/cuts/">Valid inequalities</a></li><li><a class="tocitem" href="../../start/pricing/">Pricing callback</a></li><li><a class="tocitem" href="../../start/custom_data/">Custom data</a></li><li><a class="tocitem" href="../../start/initial_columns/">Initial columns callback</a></li><li><a class="tocitem" href="../../start/advanced_demo/">Advanced tutorial</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/decomposition/">Decomposition</a></li><li><a class="tocitem" href="../../man/config/">Configuration</a></li><li><a class="tocitem" href="../../man/algorithm/">Algorithms</a></li><li><a class="tocitem" href="../../man/callbacks/">Callbacks</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../branching/">Branching</a></li><li class="is-active"><a class="tocitem" href>ColGen</a><ul class="internal"><li><a class="tocitem" href="#Phases"><span>Phases</span></a></li><li><a class="tocitem" href="#Stages"><span>Stages</span></a></li><li><a class="tocitem" href="#Optimization-of-the-Master"><span>Optimization of the Master</span></a></li><li><a class="tocitem" href="#Calculation-of-reduced-costs"><span>Calculation of reduced costs</span></a></li><li><a class="tocitem" href="#Pricing-strategy"><span>Pricing strategy</span></a></li><li><a class="tocitem" href="#Pricing-subproblem-optimization"><span>Pricing subproblem optimization</span></a></li><li><a class="tocitem" href="#Columns-management-and-insertion"><span>Columns management and insertion</span></a></li><li><a class="tocitem" href="#Dual-bound-calculation"><span>Dual bound calculation</span></a></li></ul></li><li><a class="tocitem" href="../treesearch/">TreeSearch</a></li><li><a class="tocitem" href="../storage/">Storage</a></li></ul></li><li><a class="tocitem" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays</a></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>ColGen</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ColGen</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/api/colgen.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ColGen-API"><a class="docs-heading-anchor" href="#ColGen-API">ColGen API</a><a id="ColGen-API-1"></a><a class="docs-heading-anchor-permalink" href="#ColGen-API" title="Permalink"></a></h1><p>Coluna provides an interface and generic functions to implement a multi-stage column generation algorithm. Here is an overview of the main concepts and a description of the  default implementation:</p><h2 id="Phases"><a class="docs-heading-anchor" href="#Phases">Phases</a><a id="Phases-1"></a><a class="docs-heading-anchor-permalink" href="#Phases" title="Permalink"></a></h2><p>In the first iterations, the restricted master LP contains a few columns and may be  infeasible. To prevent this, we introduce artificial variables and we change the  formulation depending on whether we want to prove the infeasibility of the master LP or find  the optimal solution. The default implementation provides three phases:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.Algorithm.ColGenPhase1" href="#Coluna.Algorithm.ColGenPhase1"><code>Coluna.Algorithm.ColGenPhase1</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Phase 1 sets the cost of variables to 0 except for artifical variables. The goal is to find a solution to the master LP problem that has no artificial variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/Algorithm/colgen/default.jl#L105-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.Algorithm.ColGenPhase2" href="#Coluna.Algorithm.ColGenPhase2"><code>Coluna.Algorithm.ColGenPhase2</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Phase 2 solves the master LP without artificial variables. To start, it requires a set of columns that forms a feasible solution to the LP master. This set is found with phase 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/Algorithm/colgen/default.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.Algorithm.ColGenPhase3" href="#Coluna.Algorithm.ColGenPhase3"><code>Coluna.Algorithm.ColGenPhase3</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Phase 3 is a mix of phase 1 and phase 2. It sets a very large cost to artifical variables to force them to be removed from the master  LP solution. If the final master LP solution contains artifical variables either the master is infeasible or the cost of artificial variables is not large enough. Phase 1 must be run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/Algorithm/colgen/default.jl#L118-L124">source</a></section></article><p>Here are the references for the interface:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenPhase" href="#Coluna.ColGen.AbstractColGenPhase"><code>Coluna.ColGen.AbstractColGenPhase</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A phase of the column generation. Each phase is associated with a specific set up of the reformulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/phases.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenPhaseIterator" href="#Coluna.ColGen.AbstractColGenPhaseIterator"><code>Coluna.ColGen.AbstractColGenPhaseIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An iterator that indicates how phases follow each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/phases.jl#L7-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.new_phase_iterator" href="#Coluna.ColGen.new_phase_iterator"><code>Coluna.ColGen.new_phase_iterator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a new phase iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/phases.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.initial_phase" href="#Coluna.ColGen.initial_phase"><code>Coluna.ColGen.initial_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the phase with which the column generation algorithm must start.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/phases.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.decrease_stage" href="#Coluna.ColGen.decrease_stage"><code>Coluna.ColGen.decrease_stage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the next stage involving a &quot;more exact solver&quot; than the current one. Returns <code>nothing</code> if the algorithm has already reached the exact phase (last phase).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.next_phase" href="#Coluna.ColGen.next_phase"><code>Coluna.ColGen.next_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the next phase of the column generation algorithm. Returns <code>nothing</code> if the algorithm must stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/phases.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.setup_reformulation!" href="#Coluna.ColGen.setup_reformulation!"><code>Coluna.ColGen.setup_reformulation!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Setup the reformulation for the given phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/phases.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.setup_context!" href="#Coluna.ColGen.setup_context!"><code>Coluna.ColGen.setup_context!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Setup the context for the given phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/phases.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.stop_colgen_phase" href="#Coluna.ColGen.stop_colgen_phase"><code>Coluna.ColGen.stop_colgen_phase</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if the column generation phase must stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/phases.jl#L30">source</a></section></article><h2 id="Stages"><a class="docs-heading-anchor" href="#Stages">Stages</a><a id="Stages-1"></a><a class="docs-heading-anchor-permalink" href="#Stages" title="Permalink"></a></h2><p>A stage is a set of consecutive iterations in which we use a given pricing solver.  The goal is to solve the pricing subproblem with very fast heuristic solvers first and then switch to a &quot;more exact&quot; solver when a given condition is met. The last stage generally uses an exact solver.</p><p>Here are the references for the interface:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenStage" href="#Coluna.ColGen.AbstractColGenStage"><code>Coluna.ColGen.AbstractColGenStage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A stage of the column generation algorithm. Each stage is associated to a specific solver for each pricing subproblem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.AbstractColGenStageIterator" href="#Coluna.ColGen.AbstractColGenStageIterator"><code>Coluna.ColGen.AbstractColGenStageIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An iterator that indicates how stages follow each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.new_stage_iterator" href="#Coluna.ColGen.new_stage_iterator"><code>Coluna.ColGen.new_stage_iterator</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a new stage iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.initial_stage" href="#Coluna.ColGen.initial_stage"><code>Coluna.ColGen.initial_stage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the stage at which the column generation algorithm must start.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.next_stage" href="#Coluna.ColGen.next_stage"><code>Coluna.ColGen.next_stage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the next stage that column generation must use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L22-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_pricing_subprob_optimizer" href="#Coluna.ColGen.get_pricing_subprob_optimizer"><code>Coluna.ColGen.get_pricing_subprob_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the optimizer for the pricing subproblem associated to the given stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.stage_id" href="#Coluna.ColGen.stage_id"><code>Coluna.ColGen.stage_id</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the id of the stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.is_exact_stage" href="#Coluna.ColGen.is_exact_stage"><code>Coluna.ColGen.is_exact_stage</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if the stage uses an exact solver for the pricing subproblem; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/stages.jl#L33">source</a></section></article><p>The default implementation of the stages is as follows.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Coluna.ColGen.ColGenStageIterator</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Optimization-of-the-Master"><a class="docs-heading-anchor" href="#Optimization-of-the-Master">Optimization of the Master</a><a id="Optimization-of-the-Master-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-of-the-Master" title="Permalink"></a></h2><p>At each iteration, the algorithm requires a dual solution to the master LP to compute the reduced cost of subproblem variables.</p><p>The default implementation optimizes the master with an LP solver through MathOptInterface. It returns a primal and a dual solution.</p><p>Here are the references for the interface:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.optimize_master_lp_problem!" href="#Coluna.ColGen.optimize_master_lp_problem!"><code>Coluna.ColGen.optimize_master_lp_problem!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_master_lp_problem!(master, context, env) -&gt; MasterResult</code></pre><p>Returns an instance of a custom object <code>MasterResult</code> that implements the following methods:</p><ul><li><code>get_obj_val</code>: objective value of the master (mandatory)</li><li><code>get_primal_sol</code>: primal solution to the master (optional)</li><li><code>get_dual_sol</code>: dual solution to the master (mandatory otherwise column generation stops)</li></ul><p>It should at least return a dual solution (obtained with LP optimization or subgradient)  otherwise column generation cannot continue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L121-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_obj_val" href="#Coluna.ColGen.get_obj_val"><code>Coluna.ColGen.get_obj_val</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the optimal objective value of the master LP problem.&quot; See <code>optimize_master_lp_problem!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L134-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_primal_sol" href="#Coluna.ColGen.get_primal_sol"><code>Coluna.ColGen.get_primal_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns primal solution to the master LP problem.  See <code>optimize_master_lp_problem!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L140-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_dual_sol" href="#Coluna.ColGen.get_dual_sol"><code>Coluna.ColGen.get_dual_sol</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns dual solution to the master optimization problem.  See <code>optimize_master_lp_problem!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L146-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.is_optimal" href="#Coluna.ColGen.is_optimal"><code>Coluna.ColGen.is_optimal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true if a master or pricing problem result is optimal; false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.is_infeasible" href="#Coluna.ColGen.is_infeasible"><code>Coluna.ColGen.is_infeasible</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true if a master or pricing problem result is infeasible; false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.is_unbounded" href="#Coluna.ColGen.is_unbounded"><code>Coluna.ColGen.is_unbounded</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns true if a master or pricing problem result is unbounded; false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L111">source</a></section></article><p>Optionally, the algorithm can check the integrality of the primal solution to the master LP in order to improve the global primal bound of the branch-cut-price algorithm. The default implementation checks the integrality of the primal solution.</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.check_primal_ip_feasibility!" href="#Coluna.ColGen.check_primal_ip_feasibility!"><code>Coluna.ColGen.check_primal_ip_feasibility!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a primal solution expressed in the original problem variables if the current master LP solution is integer feasible; <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L152-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.isbetter" href="#Coluna.ColGen.isbetter"><code>Coluna.ColGen.isbetter</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns <code>true</code> if the new master IP primal solution is better than the current; <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L158-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.update_inc_primal_sol!" href="#Coluna.ColGen.update_inc_primal_sol!"><code>Coluna.ColGen.update_inc_primal_sol!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates the current master IP primal solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L163-L165">source</a></section></article><h2 id="Calculation-of-reduced-costs"><a class="docs-heading-anchor" href="#Calculation-of-reduced-costs">Calculation of reduced costs</a><a id="Calculation-of-reduced-costs-1"></a><a class="docs-heading-anchor-permalink" href="#Calculation-of-reduced-costs" title="Permalink"></a></h2><p>Reduced costs calculation is written as a math operation in the <code>run_colgen_iteration!</code>  generic function. As a consequence, the dual solution to the master LP and the  implementation of the two following methods must return data structures that support math operations.</p><p>Reduced costs calculation also requires the implementation of the two following methods:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.update_master_constrs_dual_vals!" href="#Coluna.ColGen.update_master_constrs_dual_vals!"><code>Coluna.ColGen.update_master_constrs_dual_vals!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates dual value of the master constraints. Dual values of the constraints can be used when the pricing solver supports non-robust cuts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L171-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_subprob_var_orig_costs" href="#Coluna.ColGen.get_subprob_var_orig_costs"><code>Coluna.ColGen.get_subprob_var_orig_costs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the original cost <code>c</code> of subproblems variables. to compute reduced cost <code>̄c = c - transpose(A) * π</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L177-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_subprob_var_coef_matrix" href="#Coluna.ColGen.get_subprob_var_coef_matrix"><code>Coluna.ColGen.get_subprob_var_coef_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the coefficient matrix <code>A</code> of subproblem variables in the master to compute reduced cost <code>̄c = c - transpose(A) * π</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L183-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.update_sp_vars_red_costs!" href="#Coluna.ColGen.update_sp_vars_red_costs!"><code>Coluna.ColGen.update_sp_vars_red_costs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Updates reduced costs of variables of a given subproblem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L189">source</a></section></article><h2 id="Pricing-strategy"><a class="docs-heading-anchor" href="#Pricing-strategy">Pricing strategy</a><a id="Pricing-strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Pricing-strategy" title="Permalink"></a></h2><p>The pricing strategy is basically an iterator used to iterate over the pricing subproblems to optimize at each iteration of the column generation. The context can serve as a memory of the pricing strategy to change the way we iterate over subproblems between each column generation iteration.</p><p>The default implementation iterates over all subproblems.</p><p>Here are the references for the interface:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.AbstractPricingStrategy" href="#Coluna.ColGen.AbstractPricingStrategy"><code>Coluna.ColGen.AbstractPricingStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A pricing strategy defines how we iterate on pricing subproblems. A default pricing strategy consists in iterating on all pricing subproblems.</p><p>Basically, this object is used like this:</p><pre><code class="language-julia hljs">    pricing_strategy = ColGen.get_pricing_strategy(ctx, phase)
    next = ColGen.pricing_strategy_iterate(pricing_strategy)
    while !isnothing(next)
        (sp_id, sp_to_solve), state = next
        # Solve the subproblem `sp_to_solve`.
        next = ColGen.pricing_strategy_iterate(pricing_strategy, state)
    end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_pricing_strategy" href="#Coluna.ColGen.get_pricing_strategy"><code>Coluna.ColGen.get_pricing_strategy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_pricing_strategy(ctx, phase) -&gt; AbstractPricingStrategy</code></pre><p>Returns the pricing strategy object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.pricing_strategy_iterate" href="#Coluna.ColGen.pricing_strategy_iterate"><code>Coluna.ColGen.pricing_strategy_iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pricing_strategy_iterate(pricing_strategy) -&gt; ((sp_id, sp_to_solve), state)
pricing_strategy_iterate(pricing_strategy, state) -&gt; ((sp_id, sp_to_solve), state)</code></pre><p>Returns an iterator with the first pricing subproblem that must be optimized. The next subproblem is returned by a call to <code>Base.iterate</code> using the information provided by this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L29-L36">source</a></section></article><h2 id="Pricing-subproblem-optimization"><a class="docs-heading-anchor" href="#Pricing-subproblem-optimization">Pricing subproblem optimization</a><a id="Pricing-subproblem-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Pricing-subproblem-optimization" title="Permalink"></a></h2><p>At each iteration, the algorithm requires primal solutions to the pricing subproblems. The generic function supports multi-column generation so you can return any number of solutions.</p><p>The default implementation supports optimization of the pricing subproblems using a MILP solver or a pricing callback. Non-robust valid inequalities are not supported by MILP solvers as they change the structure of the subproblems. When using a pricing callback, you must be aware of how Coluna calculates the reduced cost of a column:</p><p>The reduced cost of a column is split into three contributions:</p><ul><li>the contribution of the subproblem variables that is the primal solution cost given the reduced cost of subproblem variables</li><li>the contribution of the non-robust constraints (i.e. master constraints that cannot be expressed using subproblem variables except the convexity constraint) that is not supported by MILP solver but that you must take into account in the pricing callback</li><li>the contribution of the master convexity constraint that is automatically taken into account by Coluna once the primal solution is returned.</li></ul><p>Therefore, it is very important that you do not discard some columns based only on the primal solution cost because you don&#39;t know the contribution of the convexity constraint.</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.optimize_pricing_problem!" href="#Coluna.ColGen.optimize_pricing_problem!"><code>Coluna.ColGen.optimize_pricing_problem!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_pricing_problem!(ctx, sp, env, optimizer, mast_dual_sol) -&gt; PricingResult</code></pre><p>Returns a custom object <code>PricingResult</code> that must implement the following functions:</p><ul><li><code>get_primal_sols</code>: array of primal solution to the pricing subproblem </li><li><code>get_primal_bound</code>: best reduced cost (optional ?)</li><li><code>get_dual_bound</code>: dual bound of the pricing subproblem (used to compute the master dual bound)</li></ul><p>TODO: talk about master<em>dual</em>sol</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L56-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_primal_sols" href="#Coluna.ColGen.get_primal_sols"><code>Coluna.ColGen.get_primal_sols</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Array of primal solutions to the pricing subproblem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.get_dual_bound" href="#Coluna.ColGen.get_dual_bound"><code>Coluna.ColGen.get_dual_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns dual bound of the pricing subproblem; <code>nothing</code> if no dual bound is available and the intial dual bound returned by <code>compute_sp_init_db</code> will be used to compute the master dual bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L71-L75">source</a></section></article><p>You must also implement the <code>Coluna.ColGen.is_optimal</code>, <code>Coluna.ColGen.is_infeasible</code>, and <code>Coluna.ColGen.is_unbounded</code> for the pricing result.</p><h2 id="Columns-management-and-insertion"><a class="docs-heading-anchor" href="#Columns-management-and-insertion">Columns management and insertion</a><a id="Columns-management-and-insertion-1"></a><a class="docs-heading-anchor-permalink" href="#Columns-management-and-insertion" title="Permalink"></a></h2><p>You can define your data structure to manage the columns generated at a given iteration. Columns are inserted after the optimization of all pricing subproblems to allow the parallelization of the latter.</p><p>Here are the references for the interface:</p><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.set_of_columns" href="#Coluna.ColGen.set_of_columns"><code>Coluna.ColGen.set_of_columns</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns an empty container that will store all the columns generated by the pricing problems during an iteration of the column generation algorithm. One must be able to iterate on this container to insert the columns in the master problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.push_in_set!" href="#Coluna.ColGen.push_in_set!"><code>Coluna.ColGen.push_in_set!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Pushes the column in the set of columns generated at a given iteration of the column generation algorithm. Columns stored in the set will then be considered for insertion in the master problem. Returns <code>true</code> if column was inserted in the set, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.insert_columns!" href="#Coluna.ColGen.insert_columns!"><code>Coluna.ColGen.insert_columns!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Inserts columns into the master. Returns the number of columns inserted. Implementation is responsible for checking if the column must be inserted and warn the user if something unexpected happens.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L196-L200">source</a></section></article><h2 id="Dual-bound-calculation"><a class="docs-heading-anchor" href="#Dual-bound-calculation">Dual bound calculation</a><a id="Dual-bound-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-bound-calculation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.compute_sp_init_db" href="#Coluna.ColGen.compute_sp_init_db"><code>Coluna.ColGen.compute_sp_init_db</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns an initial dual bound for a pricing subproblem. Default value should be +/- infinite depending on the optimization sense.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/pricing.jl#L43-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Coluna.ColGen.compute_dual_bound" href="#Coluna.ColGen.compute_dual_bound"><code>Coluna.ColGen.compute_dual_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_dual_bound(ctx, phase, master_lp_obj_val, master_dbs, mast_dual_sol) -&gt; Float64</code></pre><p>Caculates the dual bound at a given iteration of column generation. The dual bound is composed of:</p><ul><li><code>master_lp_obj_val</code>: objective value of the master LP problem</li><li><code>master_dbs</code>: dual values of the pricing subproblems</li><li>the contribution of the master convexity constraints that you should compute from <code>mast_dual_sol</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/958dc41464875ed03461463cd0bde0773148af2e/src/ColGen/interface.jl#L214-L222">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../branching/">« Branching</a><a class="docs-footer-nextpage" href="../treesearch/">TreeSearch »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 1 June 2023 13:20">Thursday 1 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
