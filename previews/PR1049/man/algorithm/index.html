<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in algorithms · Coluna.jl</title><meta name="title" content="Built-in algorithms · Coluna.jl"/><meta property="og:title" content="Built-in algorithms · Coluna.jl"/><meta property="twitter:title" content="Built-in algorithms · Coluna.jl"/><meta name="description" content="Documentation for Coluna.jl."/><meta property="og:description" content="Documentation for Coluna.jl."/><meta property="twitter:description" content="Documentation for Coluna.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.048/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/js/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs (Ctrl + /)"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Getting Started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/start/">Column generation</a></li><li><a class="tocitem" href="../../start/cuts/">Cut Generation</a></li><li><a class="tocitem" href="../../start/pricing/">Pricing callback</a></li><li><a class="tocitem" href="../../start/identical_sp/">Identical subproblems</a></li><li><a class="tocitem" href="../../start/custom_data/">Custom data</a></li><li><a class="tocitem" href="../../start/initial_columns/">Initial columns callback</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Advanced tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/advanced_demo/">Column Generation and Benders on Location Routing</a></li><li><a class="tocitem" href="../../start/other_pbs/">Other classic problems</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Decomposition</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../decomposition/">Decomposition paradigms</a></li><li><a class="tocitem" href="../blockdecomposition/">Setup decomposition using BlockDecomposition</a></li></ul></li><li><a class="tocitem" href="../config/">Configuration</a></li><li class="is-active"><a class="tocitem" href>Built-in algorithms</a><ul class="internal"><li><a class="tocitem" href="#Branch-and-Bound"><span>Branch-and-Bound</span></a></li><li><a class="tocitem" href="#Conquer-algorithms"><span>Conquer algorithms</span></a></li><li><a class="tocitem" href="#Divide-algorithms"><span>Divide algorithms</span></a></li><li><a class="tocitem" href="#Explore-strategies"><span>Explore strategies</span></a></li><li><a class="tocitem" href="#Cut-generation-algorithms"><span>Cut generation algorithms</span></a></li><li><a class="tocitem" href="#Column-generation-algorithms"><span>Column generation algorithms</span></a></li><li><a class="tocitem" href="#External-call-to-optimize-a-linear-program"><span>External call to optimize a linear program</span></a></li><li><a class="tocitem" href="#External-call-to-optimize-a-mixed-integer-program-/-combinatorial-problem"><span>External call to optimize a mixed-integer program / combinatorial problem</span></a></li></ul></li><li><a class="tocitem" href="../callbacks/">User-defined Callbacks</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/algos/">Algorithms</a></li><li><a class="tocitem" href="../../api/benders/">Benders</a></li><li><a class="tocitem" href="../../api/branching/">Branching</a></li><li><a class="tocitem" href="../../api/colgen/">ColGen</a></li><li><a class="tocitem" href="../../api/treesearch/">TreeSearch</a></li><li><a class="tocitem" href="../../api/storage/">Storage</a></li></ul></li><li><a class="tocitem" href="../../dynamic_sparse_arrays/">Dynamic Sparse Arrays</a></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><div class="docs-left"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Built-in algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Built-in algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/atoptima/Coluna.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/man/algorithm.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Built-in-Algorithms"><a class="docs-heading-anchor" href="#Built-in-Algorithms">Built-in Algorithms</a><a id="Built-in-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-Algorithms" title="Permalink"></a></h1><h2 id="Branch-and-Bound"><a class="docs-heading-anchor" href="#Branch-and-Bound">Branch-and-Bound</a><a id="Branch-and-Bound-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-and-Bound" title="Permalink"></a></h2><p>Branch-and-Bound algorithm aims to find an optimal solution of a MIP by successive divisions of the search space. An introduction to the Branch-and-Bound algorithm can be found <a href="https://en.wikipedia.org/wiki/Branch_and_bound">here</a>. </p><p>Coluna provides a generic Branch-and-Bound algorithm whose three main elements can be easily modified:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.TreeSearchAlgorithm" href="#Coluna.Algorithm.TreeSearchAlgorithm"><code>Coluna.Algorithm.TreeSearchAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.TreeSearchAlgorithm(
    conqueralg::AbstractConquerAlgorithm = ColCutGenConquer(),
    dividealg::AbstractDivideAlgorithm = Branching(),
    explorestrategy::AbstractExploreStrategy = DepthFirstStrategy(),
    maxnumnodes = 100000,
    opennodeslimit = 100,
    timelimit = -1, # -1 means no time limit
    opt_atol::Float64 = DEF_OPTIMALITY_ATOL,
    opt_rtol::Float64 = DEF_OPTIMALITY_RTOL,
    branchingtreefile = &quot;&quot;,
    jsonfile = &quot;&quot;,
    print_node_info = true
)</code></pre><p>This algorithm is a branch and bound that uses a search tree to optimize the reformulation. At each node in the tree, it applies <code>conqueralg</code> to evaluate the node and improve the bounds,  <code>dividealg</code> to generate branching constraints, and <code>explorestrategy</code> to select the next node to treat.</p><p>The three main elements of the algorithm are:</p><ul><li>the conquer strategy (<code>conqueralg</code>): evaluation of the problem at a node of the Branch-and-Bound tree. Depending on the type of decomposition used ahead of the Branch-and-Bound, you can use either Column Generation (if your problem is decomposed following Dantzig-Wolfe transformation) and/or Cut Generation (for Dantzig-Wolfe and Benders decompositions). </li><li>the branching strategy (<code>dividealg</code>): how to create new branches i.e. how to divide the search space</li><li>the explore strategy (<code>explorestrategy</code>): the evaluation order of your nodes </li></ul><p>Parameters: </p><ul><li><code>maxnumnodes</code> : maximum number of nodes explored by the algorithm</li><li><code>opennodeslimit</code> : maximum number of nodes waiting to be explored</li><li><code>timelimit</code> : time limit in seconds of the algorithm</li><li><code>opt_atol</code> : optimality absolute tolerance (alpha)</li><li><code>opt_rtol</code> : optimality relative tolerance (alpha)</li></ul><p>Options:</p><ul><li><code>branchingtreefile</code> : name of the file in which the algorithm writes an overview of the branching tree</li><li><code>jsonfile</code> : name of the file in which the algorithm writes the solution in JSON format</li><li><code>print_node_info</code> : log the tree into the console</li></ul><p><strong>Warning</strong>: if you set a name for the <code>branchingtreefile</code> AND the <code>jsonfile</code>, the algorithm will only write in the json file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/treesearch.jl#L1-L40">source</a></section></article><p>Conquer, divide algorithms and the explore strategy available with the <code>TreeSearchAlgorithm</code> are listed in the following mind map. </p><div class="mermaid">mindmap
    TreeSearchAlgorithm
        (conquer)
            BendersConquer
            ColCutGenConquer
            RestrMasterLpConquer
        (divide)
            NoBranching
            ClassicBranching
            StrongBranching
        (explore)
            DepthFirstStrategy
            BestDualBoundStrategy</div><h2 id="Conquer-algorithms"><a class="docs-heading-anchor" href="#Conquer-algorithms">Conquer algorithms</a><a id="Conquer-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Conquer-algorithms" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Algorithm.BendersConquer</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColCutGenConquer" href="#Coluna.Algorithm.ColCutGenConquer"><code>Coluna.Algorithm.ColCutGenConquer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.ColCutGenConquer(
    colgen = ColumnGeneration(),
    cutgen = CutCallbacks(),
    primal_heuristics = ParameterizedHeuristic[ParamRestrictedMasterHeuristic()],
    max_nb_cut_rounds = 3
)</code></pre><p>Column-and-cut-generation based algorithm to find primal and dual bounds for a  problem decomposed using Dantzig-Wolfe paradigm.</p><p>Parameters :</p><ul><li><code>colgen</code>: column generation algorithm</li><li><code>cutgen</code>: cut generation algorithm</li><li><code>primal_heuristics</code>: heuristics to find a feasible solution</li><li><code>max_nb_cut_rounds</code> : number of cut generation done by the algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/conquer.jl#L68-L84">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Algorithm.RestrMasterLpConquer</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Divide-algorithms"><a class="docs-heading-anchor" href="#Divide-algorithms">Divide algorithms</a><a id="Divide-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Divide-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.NoBranching" href="#Coluna.Algorithm.NoBranching"><code>Coluna.Algorithm.NoBranching</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Divide algorithm that does nothing. It does not generate any child.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/branching/branchingalgo.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ClassicBranching" href="#Coluna.Algorithm.ClassicBranching"><code>Coluna.Algorithm.ClassicBranching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClassicBranching(
    selection_criterion = MostFractionalCriterion()
    rules = [Branching.PrioritisedBranchingRule(SingleVarBranchingRule(), 1.0, 1.0)]
    int_tol = 1e-6
)</code></pre><p>Chooses the best candidate according to a selection criterion and generates the two children.</p><p><strong>Parameters</strong></p><ul><li><code>selection_criterion</code>: selection criterion to choose the best candidate</li><li><code>rules</code>: branching rules to generate the candidates</li><li><code>int_tol</code>: tolerance to determine if a variable is integer</li></ul><p>It is implemented as a specific case of the strong branching algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/branching/branchingalgo.jl#L33-L48">source</a></section></article><p>Strong branching is the main algorithm that we provide and it is the default implementation of the <code>Branching</code> submodule. You can have more information about the algorithm by reading the <code>Branching</code> submodule documentation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.StrongBranching" href="#Coluna.Algorithm.StrongBranching"><code>Coluna.Algorithm.StrongBranching</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StrongBranching(
    phases = [],
    rules = [Branching.PrioritisedBranchingRule(SingleVarBranchingRule(), 1.0, 1.0)],
    selection_criterion = MostFractionalCriterion(),
    verbose = true,
    int_tol = 1e-6
)</code></pre><p>The algorithm that performs a (multi-phase) (strong) branching in a tree search algorithm.</p><p>Strong branching is a procedure that heuristically selects a branching constraint that potentially gives the best progress of the dual bound. The procedure selects a collection  of branching candidates based on their branching rule and their score. Then, the procedure evaluates the progress of the dual bound in both branches of each branching candidate by solving both potential children using a conquer algorithm. The candidate that has the largest product of dual bound improvements in the branches  is chosen to be the branching constraint.</p><p>When the dual bound improvement produced by the branching constraint is difficult to compute (e.g. time-consuming in the context of column generation), one can let the branching algorithm quickly estimate the dual bound improvement of each candidate and retain the most promising branching candidates. This is called a <strong>phase</strong>. The goal is to first evaluate a large number of candidates with a very fast conquer algorithm and retain a certain number of promising ones.  Then, over the phases, it evaluates the improvement with a more precise conquer algorithm and restrict the number of retained candidates until only one is left.</p><p><strong>Parameters</strong>:</p><ul><li><code>phases</code>: a vector of <a href="man/@ref"><code>Coluna.Algorithm.BranchingPhase</code></a></li><li><code>rules</code>: a vector of <a href="man/@ref"><code>Coluna.Algorithm.Branching.PrioritisedBranchingRule</code></a></li><li><code>selection_criterion</code>: a selection criterion to choose the initial candidates</li><li><code>verbose</code>: if true, print the progress of the strong branching procedure</li><li><code>int_tol</code>: tolerance to determine if a variable is integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/branching/branchingalgo.jl#L152-L186">source</a></section></article><p>All the possible algorithms that can be used within the strong branching are listed in the following mind map.</p><div class="mermaid">mindmap
    StrongBranching
        (phases)
            (conquer)
                BendersConquer
                ColCutGenConquer
                RestrMasterLpConquer
            (score)
                ProductScore
                TreeDepthScore
        (rules)
            SingleVarBranchingRule
        (selection_criterion)
            FirstFoundCriterion
            MostFractionalCriterion</div><h2 id="Explore-strategies"><a class="docs-heading-anchor" href="#Explore-strategies">Explore strategies</a><a id="Explore-strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Explore-strategies" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.TreeSearch.DepthFirstStrategy" href="#Coluna.TreeSearch.DepthFirstStrategy"><code>Coluna.TreeSearch.DepthFirstStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Explore the tree search space with a depth-first strategy. The next visited node is the last one pushed in the stack of unexplored nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/TreeSearch/explore.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.TreeSearch.BestDualBoundStrategy" href="#Coluna.TreeSearch.BestDualBoundStrategy"><code>Coluna.TreeSearch.BestDualBoundStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Explore the tree search space with a best-first strategy. The next visited node is the one with the highest local dual bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/TreeSearch/explore.jl#L9-L12">source</a></section></article><h2 id="Cut-generation-algorithms"><a class="docs-heading-anchor" href="#Cut-generation-algorithms">Cut generation algorithms</a><a id="Cut-generation-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Cut-generation-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.BendersCutGeneration" href="#Coluna.Algorithm.BendersCutGeneration"><code>Coluna.Algorithm.BendersCutGeneration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.BendersCutGeneration(
    restr_master_solve_alg = SolveLpForm(get_dual_sol = true, relax_integrality = true),
    restr_master_optimizer_id = 1,
    separation_solve_alg = SolveLpForm(get_dual_sol = true, relax_integrality = true)
    max_nb_iterations::Int = 100,
)</code></pre><p>Benders cut generation algorithm that can be applied to a formulation reformulated using Benders decomposition.</p><p>This algorithm is an implementation of the generic algorithm provided by the <code>Benders</code> submodule.</p><p><strong>Parameters:</strong></p><ul><li><code>restr_master_solve_alg</code>: algorithm to solve the restricted master problem</li><li><code>restr_master_optimizer_id</code>: optimizer id to use to solve the restricted master problem</li><li><code>separation_solve_alg</code>: algorithm to solve the separation problem (must be a LP solver that returns a dual solution)</li></ul><p><strong>Option:</strong></p><ul><li><code>max_nb_iterations</code>: maximum number of iterations</li></ul><p><strong>About the output</strong></p><p>At each iteration, the Benders cut generation algorithm show following statistics:</p><pre><code class="nohighlight hljs">&lt;it=  6&gt; &lt;et= 0.05&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cuts= 0&gt; &lt;master=  293.5000&gt;</code></pre><p>where:</p><ul><li><code>it</code> stands for the current number of iterations of the algorithm</li><li><code>et</code> is the elapsed time in seconds since Coluna has started the optimisation</li><li><code>mst</code> is the time in seconds spent solving the master problem at the current iteration</li><li><code>sp</code> is the time in seconds spent solving the separation problem at the current iteration</li><li><code>cuts</code> is the number of cuts generated at the current iteration</li><li><code>master</code> is the objective value of the master problem at the current iteration</li></ul><p><strong>Debug options</strong> (print at each iteration):</p><ul><li><code>debug_print_master</code>: print the master problem</li><li><code>debug_print_master_primal_solution</code>: print the master problem with the primal solution</li><li><code>debug_print_master_dual_solution</code>: print the master problem with the dual solution (make sure the <code>restr_master_solve_alg</code> returns a dual solution)</li><li><code>debug_print_subproblem</code>: print the subproblem</li><li><code>debug_print_subproblem_primal_solution</code>: print the subproblem with the primal solution</li><li><code>debug_print_subproblem_dual_solution</code>: print the subproblem with the dual solution</li><li><code>debug_print_generated_cuts</code>: print the generated cuts</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/benders.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.CutCallbacks" href="#Coluna.Algorithm.CutCallbacks"><code>Coluna.Algorithm.CutCallbacks</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CutCallbacks(
    call_robust_facultative = true,
    call_robust_essential = true,
    tol::Float64 = 1e-6
)</code></pre><p>Runs the cut user callbacks attached to a formulation.</p><p><strong>Parameters:</strong></p><ul><li><code>call_robust_facultative</code>: if true, call all the robust facultative cut user callbacks (i.e. user cut callbacks)</li><li><code>call_robust_essential</code>: if true, call all the robust essential cut user callbacks (i.e. lazy constraint callbacks)</li><li><code>tol</code>: tolerance used to determine if a cut is violated</li></ul><p>See the JuMP documentation for more information about user callbacks and the tutorials in the Coluna documentation for examples of user callbacks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/basic/cutcallback.jl#L1-L17">source</a></section></article><h2 id="Column-generation-algorithms"><a class="docs-heading-anchor" href="#Column-generation-algorithms">Column generation algorithms</a><a id="Column-generation-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Column-generation-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.ColumnGeneration" href="#Coluna.Algorithm.ColumnGeneration"><code>Coluna.Algorithm.ColumnGeneration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.ColumnGeneration(
    restr_master_solve_alg = SolveLpForm(get_dual_sol = true),
    pricing_prob_solve_alg = SolveIpForm(
        moi_params = MoiOptimize(
            deactivate_artificial_vars = false,
            enforce_integrality = false
        )
    ),
    essential_cut_gen_alg = CutCallbacks(call_robust_facultative = false),
    max_nb_iterations = 1000,
    log_print_frequency = 1,
    redcost_tol = 1e-4,
    show_column_already_inserted_warning = true,
    cleanup_threshold = 10000,
    cleanup_ratio = 0.66,
    smoothing_stabilization = 0.0 # should be in [0, 1],
)</code></pre><p>Column generation algorithm that can be applied to formulation reformulated using Dantzig-Wolfe decomposition. </p><p>This algorithm first solves the linear relaxation of the master (master LP) using <code>restr_master_solve_alg</code>. Then, it solves the subproblems by calling <code>pricing_prob_solve_alg</code> to get the columns that have the best reduced costs and that hence, may improve the master LP&#39;s objective the most.</p><p>In order for the algorithm to converge towards the optimal solution of the master LP, it suffices that the pricing oracle returns, at each iteration, a negative reduced cost solution if one exists.  The algorithm stops when all subproblems fail to generate a column with negative (positive) reduced cost in the case of a minimization (maximization) problem or when it reaches the maximum number of iterations.</p><p><strong>Parameters:</strong> </p><ul><li><code>restr_master_solve_alg</code>: algorithm to optimize the master LP</li><li><code>pricing_prob_solve_alg</code>: algorithm to optimize the subproblems</li><li><code>essential_cut_gen_alg</code>: algorithm to generate essential cuts which is run when the solution of the master LP is integer.</li></ul><p><strong>Options:</strong></p><ul><li><code>max_nb_iterations</code>: maximum number of iterations</li><li><code>log_print_frequency</code>: display frequency of iterations statistics</li></ul><p>Undocumented parameters are in alpha version.</p><p><strong>About the ouput</strong></p><p>At each iteration (depending on <code>log_print_frequency</code>),  the column generation algorithm can display following statistics.</p><pre><code class="nohighlight hljs">&lt;it= 90&gt; &lt;et=15.62&gt; &lt;mst= 0.02&gt; &lt;sp= 0.05&gt; &lt;cols= 4&gt; &lt;al= 0.00&gt; &lt;DB=  300.2921&gt; &lt;mlp=  310.3000&gt; &lt;PB=310.3000&gt;</code></pre><p>Here are their meanings :</p><ul><li><code>it</code> stands for the current number of iterations of the algorithm</li><li><code>et</code> is the elapsed time in seconds since Coluna has started the optimisation</li><li><code>mst</code> is the time in seconds spent solving the master LP at the current iteration</li><li><code>sp</code> is the time in seconds spent solving the subproblems at the current iteration</li><li><code>cols</code> is the number of column generated by the subproblems at the current iteration</li><li><code>al</code> is the smoothing factor of the stabilisation at the current iteration (alpha version)</li><li><code>DB</code> is the dual bound of the master LP at the current iteration</li><li><code>mlp</code> is the objective value of the master LP at the current iteration</li><li><code>PB</code> is the objective value of the best primal solution found by Coluna at the current iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/colgen.jl#L1-L61">source</a></section></article><h2 id="External-call-to-optimize-a-linear-program"><a class="docs-heading-anchor" href="#External-call-to-optimize-a-linear-program">External call to optimize a linear program</a><a id="External-call-to-optimize-a-linear-program-1"></a><a class="docs-heading-anchor-permalink" href="#External-call-to-optimize-a-linear-program" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.SolveLpForm" href="#Coluna.Algorithm.SolveLpForm"><code>Coluna.Algorithm.SolveLpForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.SolveLpForm(
    get_ip_primal_sol = false,
    get_dual_sol = false,
    relax_integrality = false,
    get_dual_bound = false,
    silent = true
)</code></pre><p>Solve a linear program stored in a formulation using its first optimizer. This algorithm works only if the optimizer is interfaced with MathOptInterface.</p><p>You can define the optimizer using the <code>default_optimizer</code> attribute of Coluna or with the method <code>specify!</code> from BlockDecomposition</p><p>Parameters:</p><ul><li><code>get_ip_primal_sol</code>: update the primal solution of the formulation if equals <code>true</code></li><li><code>get_dual_sol</code>: retrieve the dual solution and store it in the ouput if equals <code>true</code></li><li><code>relax_integrality</code>: relax integer variables of the formulation before optimization if equals <code>true</code></li><li><code>get_dual_bound</code>: store the dual objective value in the output if equals <code>true</code></li><li><code>silent</code>: set <code>MOI.Silent()</code> to its value</li></ul><p>Undocumented parameters are alpha.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/basic/solvelpform.jl#L1-L24">source</a></section></article><h2 id="External-call-to-optimize-a-mixed-integer-program-/-combinatorial-problem"><a class="docs-heading-anchor" href="#External-call-to-optimize-a-mixed-integer-program-/-combinatorial-problem">External call to optimize a mixed-integer program / combinatorial problem</a><a id="External-call-to-optimize-a-mixed-integer-program-/-combinatorial-problem-1"></a><a class="docs-heading-anchor-permalink" href="#External-call-to-optimize-a-mixed-integer-program-/-combinatorial-problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.SolveIpForm" href="#Coluna.Algorithm.SolveIpForm"><code>Coluna.Algorithm.SolveIpForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Coluna.Algorithm.SolveIpForm(
    optimizer_id = 1
    moi_params = MoiOptimize()
    user_params = UserOptimize()
    custom_params = CustomOptimize()
)</code></pre><p>Solve an optimization problem. This algorithm can call different type of optimizers :</p><ul><li>subsolver interfaced with MathOptInterface to optimize a mixed integer program</li><li>pricing callback defined by the user</li><li>custom optimizer to solve a custom model</li></ul><p>You can specify an optimizer using the <code>default_optimizer</code> attribute of Coluna or with the method <code>specify!</code> from BlockDecomposition. If you want to define several optimizers for a given subproblem, you must use <code>specify!</code>:</p><pre><code class="nohighlight hljs">specify!(subproblem, optimizers = [optimizer1, optimizer2, optimizer3])</code></pre><p>Value of <code>optimizer_id</code> is the position of the optimizer you want to use. For example, if <code>optimizer_id</code> is equal to 2, the algorithm will use <code>optimizer2</code>.</p><p>By default, the algorihm uses the first optimizer or the default optimizer if no optimizer has been specified through <code>specify!</code>.</p><p>Depending on the type of the optimizer chosen, the algorithm will use one the  three configurations : </p><ul><li><code>moi_params</code> for subsolver interfaced with MathOptInterface</li><li><code>user_params</code> for pricing callbacks</li><li><code>custom_params</code> for custom solvers</li></ul><p>Custom solver is undocumented because alpha.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/basic/solveipform.jl#L4-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.MoiOptimize" href="#Coluna.Algorithm.MoiOptimize"><code>Coluna.Algorithm.MoiOptimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MoiOptimize(
    time_limit = 600
    deactivate_artificial_vars = false
    enforce_integrality = false
    get_dual_bound = true
)</code></pre><p>Configuration for an optimizer that calls a subsolver through MathOptInterface.</p><p>Parameters:</p><ul><li><code>time_limit</code>: in seconds</li><li><code>deactivate_artificial_vars</code>: deactivate all artificial variables of the formulation if equals <code>true</code></li><li><code>enforce_integrality</code>: enforce integer variables that are relaxed if equals <code>true</code></li><li><code>get_dual_bound</code>: store the dual objective value in the output if equals <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/basic/subsolvers.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.UserOptimize" href="#Coluna.Algorithm.UserOptimize"><code>Coluna.Algorithm.UserOptimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UserOptimize(
    max_nb_ip_primal_sols = 50
)</code></pre><p>Configuration for an optimizer that calls a pricing callback to solve the problem.</p><p>Parameters:</p><ul><li><code>max_nb_ip_primal_sols</code>: maximum number of solutions returned by the callback kept</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/basic/subsolvers.jl#L107-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Coluna.Algorithm.CustomOptimize" href="#Coluna.Algorithm.CustomOptimize"><code>Coluna.Algorithm.CustomOptimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CustomOptimize()</code></pre><p>Configuration for an optimizer that calls a custom solver to solve a custom model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/atoptima/Coluna.jl/blob/e7e6bb42078b07a0c263b59d2d76dca290bf7a56/src/Algorithm/basic/subsolvers.jl#L121-L125">source</a></section></article><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../config/">« Configuration</a><a class="docs-footer-nextpage" href="../callbacks/">User-defined Callbacks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Tuesday 5 September 2023 08:26">Tuesday 5 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
