<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Decomposition · Coluna User Guide</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Coluna User Guide</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Getting started</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../start/start/">Column generation</a></li><li><a class="tocitem" href="../../start/cuts/">Valid inequalities</a></li><li><a class="tocitem" href="../../start/pricing/">Pricing callback</a></li><li><a class="tocitem" href="../../start/initial_columns/">Initial columns callback</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Decomposition</a><ul class="internal"><li><a class="tocitem" href="#Dantzig-Wolfe"><span>Dantzig-Wolfe</span></a></li><li><a class="tocitem" href="#Dantzig-Wolfe-with-identical-subproblems-(alpha)"><span>Dantzig-Wolfe with identical subproblems (alpha)</span></a></li><li><a class="tocitem" href="#Benders-(alpha)"><span>Benders (alpha)</span></a></li><li class="toplevel"><a class="tocitem" href="#BlockDecomposition"><span>BlockDecomposition</span></a></li><li class="toplevel"><a class="tocitem" href="#Errors-and-warnings"><span>Errors and warnings</span></a></li><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../config/">Configuration</a></li><li><a class="tocitem" href="../algorithm/">Algorithms</a></li><li><a class="tocitem" href="../callbacks/">Callbacks</a></li></ul></li><li><a class="tocitem" href="../../qa/">Q&amp;A</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Decomposition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Decomposition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/atoptima/Coluna.jl/blob/master/docs/src/man/decomposition.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Decomposition-and-reformulation"><a class="docs-heading-anchor" href="#Decomposition-and-reformulation">Decomposition &amp; reformulation</a><a id="Decomposition-and-reformulation-1"></a><a class="docs-heading-anchor-permalink" href="#Decomposition-and-reformulation" title="Permalink"></a></h1><p>Coluna is a framework to optimizate mixed-integer programs that you can decompose. In other words, if you remove the linking constraints or linking variables from you program, you&#39;ll get sets of constraints (blocks) that you can solve independently.</p><h2 id="Dantzig-Wolfe"><a class="docs-heading-anchor" href="#Dantzig-Wolfe">Dantzig-Wolfe</a><a id="Dantzig-Wolfe-1"></a><a class="docs-heading-anchor-permalink" href="#Dantzig-Wolfe" title="Permalink"></a></h2><p>Let&#39;s consider the following coefficient matrix that has a block diagonal structure in gray and some linking constraints in blue :</p><p><img src="../../static/dwdec.png" alt="Dantzig-Wolfe decomposition"/></p><p>You penalize the violation of the linking constraints in the objective function. You can then solve the blocks independently.</p><p>The Dantzig-Wolfe reformulation gives raise to a master problem with an exponential number of variables. Coluna dynamically generates these variables by solving the subproblems. It&#39;s the column generation algorithm.</p><p>Let&#39;s consider the following original formulation in which we partition variables into two vectors <span>$x_1$</span> and <span>$x_2$</span> :</p><p><img src="../../static/dw_origform.svg" alt="Original formulation"/></p><p>When you apply a Dantzig-Wofe decomposition to this formulation,  Coluna reformulates it into the following master problem :</p><p><img src="../../static/dw_master.svg" alt="Master formulation"/></p><p>where <span>$Q_1$</span> is the index-set of the solutions to the first subproblem and  <span>$Q_2$</span> is the index-set of the solutions to the second subproblem. The set of the solutions to the first and the second subproblems are <span>$\{\tilde{x}^q_1\}_{q \in Q_1}$</span> and <span>$\{\tilde{x}^q_2\}_{q \in Q_2}$</span> respectively. These solutions are expressed in terms of the original variables. The multiplicity of the subproblems is defined in the convexity constraints. Lower and upper multiplicity are <span>$1$</span> by default.</p><p>At the beginning of the column generation algorithm, the master formulation does not have any master columns. Therefore, the master may be infeasible.  To prevent this, Coluna adds a local artifical variable specific to each constraint of the master and a global artificial variable. Costs of articial and global artificial variables can be defined in <a href="man/@ref">Coluna.Params</a>.</p><p>Subproblems take the following form (here, it&#39;s the first subproblem) :</p><p><img src="../../static/dw_sp.svg" alt="Subproblem n°1 formulation"/></p><p>where <span>$\bar{c}$</span> is the reduced cost of the original variables computed by the column generation algorithm.</p><h2 id="Dantzig-Wolfe-with-identical-subproblems-(alpha)"><a class="docs-heading-anchor" href="#Dantzig-Wolfe-with-identical-subproblems-(alpha)">Dantzig-Wolfe with identical subproblems (alpha)</a><a id="Dantzig-Wolfe-with-identical-subproblems-(alpha)-1"></a><a class="docs-heading-anchor-permalink" href="#Dantzig-Wolfe-with-identical-subproblems-(alpha)" title="Permalink"></a></h2><p>When some subproblems are identical (same coefficient matrix and rhs),  you can avoid solving all of them at each iteration by defining only one subproblem and setting its multiplicity to the number of time it appears.</p><p>Let us see an example with Dantzig-Wolfe and a variant of the Generalized Assignment Problem.</p><p>Consider a set of machine type <code>T = 1:nb_machine_types</code> and a set of jobs <code>J = 1:nb_jobs</code>. A machine type <code>t</code> has a resource capacity <code>Q[t]</code> and the factory contains <code>U[t]</code> machines of type <code>t</code>. A job <code>j</code> assigned to a machine of type <code>t</code> has a cost <code>c[t,j]</code> and consumes <code>w[t,j]</code> resource units of the machine of type <code>t</code>.</p><p>Consider the following instance :</p><pre><code class="language-julia hljs">nb_machine_types = 2;
nb_jobs = 10;
J = 1:nb_jobs;
Q = [10, 15];
U = [3, 2];  # 3 machines of type 1 &amp; 2 machines of type 2
c = [10 11 13 11 12 14 15 8 9 11; 20 21 23 21 22 24 25 18 19 21];
w = [4 4 5 4 4 3 4 5 6 5; 5 5 6 5 5 4 5 6 7 6];</code></pre><p>Here is the JuMP model to optimize this instance a classic solver : </p><pre><code class="language-julia hljs">using JuMP, GLPK;

T1 = [1, 2, 3]; # U[1] machines
T2 = [4, 5]; # U[2] machines
M = union(T1, T2);
m2t = [1, 1, 1, 2, 2]; # machine id -&gt; type id

model = Model(GLPK.Optimizer);
@variable(model, x[M, J], Bin); # 1 if job j assigned to machine m
@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1);
@constraint(model, knp[m in M], sum(w[m2t[m],j] * x[m,j] for j in J) &lt;= Q[m2t[m]]);
@objective(model, Min, sum(c[m2t[m],j] * x[m,j] for m in M, j in J));

optimize!(model);
objective_value(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">154.0</code></pre><p>You can decompose over the machines by defining an axis on <code>M</code>. However, if you want to take advantage of the identical subproblems, you must  define the formulation as follows : </p><pre><code class="language-julia hljs">using BlockDecomposition, Coluna, JuMP, GLPK;
const BD = BlockDecomposition

coluna = optimizer_with_attributes(
    Coluna.Optimizer,
    &quot;params&quot; =&gt; Coluna.Params(
        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP
    ),
    &quot;default_optimizer&quot; =&gt; GLPK.Optimizer # GLPK for the master &amp; the subproblems
);

@axis(T, 1:nb_machine_types);

model = BlockModel(coluna);
@variable(model, x[T, J], Bin); # 1 if job j assigned to machine m
@constraint(model, cov[j in J], sum(x[t,j] for t in T) == 1);
@constraint(model, knp[t in T], sum(w[t] * x[t,j] for j in J) &lt;= Q[t]);
@objective(model, Min, sum(c[t,j] * x[t,j] for t in T, j in J));</code></pre><p>We assign jobs to a type of machine and we define one knapsack constraint for each type. This formulation cannot be solved as it stands with a commercial solver.</p><p>Then, we decompose and specify the multiplicity of each knapsack subproblem : </p><pre><code class="language-julia hljs">@dantzig_wolfe_decomposition(model, dec_on_types, T);
sps = getsubproblems(dec_on_types)
for t in T
    specify!(sps[t], lower_multiplicity = 0, upper_multiplicity = U[t]);
end
getsubproblems(dec_on_types)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{BlockDecomposition.SubproblemForm}:
 Subproblem formulation for T = 1 contains :	 0.0 &lt;= multiplicity &lt;= 3.0

 Subproblem formulation for T = 2 contains :	 0.0 &lt;= multiplicity &lt;= 2.0
</code></pre><p>We see that subproblem for machine type 1 has upper multiplicity equals to 3, and second subproblem for machine type 2 has upper multiplicity equals to 2. It means that we can use at most 3 machines of type 1 and at most 2 machines of type 2.</p><p>We can then optimize</p><pre><code class="language-julia hljs">optimize!(model);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Coluna
Version 0.4.2 | https://github.com/atoptima/Coluna.jl
***************************************************************************************
**** BaB tree root node
**** Local DB = -Inf, global bounds : [ -Inf , Inf ], time = 4.37 sec.
***************************************************************************************
  &lt;it=  1&gt; &lt;et=17.16&gt; &lt;mst= 2.29&gt; &lt;sp= 3.23&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=100000.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  2&gt; &lt;et=17.65&gt; &lt;mst= 0.11&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=70057.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  3&gt; &lt;et=17.65&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=60117.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  4&gt; &lt;et=17.65&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=50080.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  5&gt; &lt;et=17.65&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=40091.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  6&gt; &lt;et=17.65&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=10159.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  7&gt; &lt;et=17.65&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=10159.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  8&gt; &lt;et=17.65&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=-19835.0000&gt; &lt;mlp=10159.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  9&gt; &lt;et=17.81&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=Inf&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
***************************************************************************************
**** BaB tree node N° 2, parent N° 1, depth 1, 2 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , Inf ], time = 19.74 sec.
**** Branching constraint: PricingSetupVar_sp_4&gt;=2.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et=19.82&gt; &lt;mst= 0.06&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  174.0000&gt; &lt;PB=Inf&gt;
  &lt;it=  2&gt; &lt;et=19.82&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 0&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=Inf&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
***************************************************************************************
**** BaB tree node N° 3, parent N° 2, depth 2, 3 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , Inf ], time = 19.82 sec.
**** Branching constraint: x[1,5]&gt;=1.0
***************************************************************************************
  &lt;it=  1&gt; &lt;et=19.82&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 2&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp= 1820.6667&gt; &lt;PB=Inf&gt;
  &lt;it=  2&gt; &lt;et=19.82&gt; &lt;mst= 0.00&gt; &lt;sp= 0.00&gt; &lt;cols= 1&gt; &lt;al= 0.00&gt; &lt;DB=  154.0000&gt; &lt;mlp=  154.0000&gt; &lt;PB=Inf&gt;
[ Info: Column generation algorithm has converged.
[ Info: Running Restricted Master IP heuristic
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 4, parent N° 2, depth 2, 2 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 19.97 sec.
**** Branching constraint: x[1,5]&lt;=0.0
***************************************************************************************
[ Info: IP Gap is closed: 0.0. Abort treatment.
Node is already conquered. No children will be generated.
***************************************************************************************
**** BaB tree node N° 5, parent N° 1, depth 1, 1 open nodes
**** Local DB = 154.0000, global bounds : [ 154.0000 , 154.0000 ], time = 19.98 sec.
**** Branching constraint: PricingSetupVar_sp_4&lt;=1.0
***************************************************************************************
[ Info: IP Gap is closed: 0.0. Abort treatment.
Node is already conquered. No children will be generated.
 ────────────────────────────────────────────────────────────────────────────────
                                        Time                    Allocations
                               ───────────────────────   ────────────────────────
       Tot / % measured:            90.1s /  22.7%           6.45GiB /  25.7%

 Section               ncalls     time    %tot     avg     alloc    %tot      avg
 ────────────────────────────────────────────────────────────────────────────────
 Coluna                     1    20.5s  100.0%   20.5s   1.66GiB  100.0%  1.66GiB
   SolveLpForm             13    1.61s    7.9%   124ms   39.1MiB    2.3%  3.01MiB
   Cleanup columns         13    261ms    1.3%  20.0ms   11.4MiB    0.7%   897KiB
   Getting primal s...     13    217ms    1.1%  16.7ms   3.16MiB    0.2%   249KiB
   Store records            5    126ms    0.6%  25.2ms   4.98MiB    0.3%  1.00MiB
   Update Lagrangia...     13    118ms    0.6%  9.10ms   2.84MiB    0.2%   224KiB
   Update reduced c...     13    103ms    0.5%  7.92ms   3.91MiB    0.2%   308KiB
   Smoothing update        13   23.5ms    0.1%  1.81ms   3.85MiB    0.2%   303KiB
   Restore/remove r...      5   59.5μs    0.0%  11.9μs     0.00B    0.0%    0.00B
 ────────────────────────────────────────────────────────────────────────────────
[ Info: Terminated
[ Info: Primal bound: 154.0
[ Info: Dual bound: 154.0</code></pre><p>and retrieve the disagreggated solution</p><pre><code class="language-julia hljs">for t in T
    assignment_patterns = BD.getsolutions(model, t);
    for pattern in assignment_patterns
        nb_times_pattern_used = BD.value(pattern);
        jobs_in_pattern = [];
        for j in J
            if BD.value(pattern, x[t, j]) ≈ 1
                push!(jobs_in_pattern, j);
            end
        end
        println(&quot;Pattern of machine type $t used $nb_times_pattern_used times : $jobs_in_pattern&quot;);
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Pattern of machine type 1 used 1.0 times : Any[3, 4]
Pattern of machine type 1 used 1.0 times : Any[7, 10]
Pattern of machine type 1 used 1.0 times : Any[2, 5]
Pattern of machine type 2 used 1.0 times : Any[1, 8, 9]
Pattern of machine type 2 used 1.0 times : Any[6]</code></pre><h2 id="Benders-(alpha)"><a class="docs-heading-anchor" href="#Benders-(alpha)">Benders (alpha)</a><a id="Benders-(alpha)-1"></a><a class="docs-heading-anchor-permalink" href="#Benders-(alpha)" title="Permalink"></a></h2><p>Let&#39;s consider the following coefficient matrix that has a block diagonal structure in gray and some linking variables in blue :</p><p><img src="../../static/bdec.png" alt="Benders decomposition"/></p><p>You fix the complicated variables, then you can solve the blocks independently.</p><p>This decomposition is an alpha feature.</p><h1 id="BlockDecomposition"><a class="docs-heading-anchor" href="#BlockDecomposition">BlockDecomposition</a><a id="BlockDecomposition-1"></a><a class="docs-heading-anchor-permalink" href="#BlockDecomposition" title="Permalink"></a></h1><p>The index-set of the subproblems is declared through an <a href="#BlockDecomposition.@axis"><code>BlockDecomposition.@axis</code></a>.  It returns an array. Each value of the array is a subproblem index wrapped into a <code>BlockDecomposition.AxisId</code>. Each time BlockDecomposition finds an <code>AxisId</code> in the indices of a variable and a constraint, it knows to which subproblem the variable or the constraint belongs.</p><p>BlockDecomposition allows the user to perform two types of decomposition using <a href="#BlockDecomposition.@dantzig_wolfe_decomposition"><code>BlockDecomposition.@dantzig_wolfe_decomposition</code></a> and <a href="#BlockDecomposition.@benders_decomposition"><code>BlockDecomposition.@benders_decomposition</code></a>.</p><p>The macro creates a decomposition tree where the root is the master and the depth is the number of nested decomposition. A classic Dantzig-Wolfe or Benders decomposition produces a decomposition tree of depth 1. At the moment, nested decomposition is not supported.</p><p>You can get the subproblem membership of all variables and constraints using the method <a href="#BlockDecomposition.annotation"><code>BlockDecomposition.annotation</code></a>.</p><p>BlockDecomposition does not change the JuMP model. It decorates the model with additional information. All these information are stored in the <code>ext</code> field of the JuMP model.</p><h1 id="Errors-and-warnings"><a class="docs-heading-anchor" href="#Errors-and-warnings">Errors and warnings</a><a id="Errors-and-warnings-1"></a><a class="docs-heading-anchor-permalink" href="#Errors-and-warnings" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.MasterVarInDwSp" href="#BlockDecomposition.MasterVarInDwSp"><code>BlockDecomposition.MasterVarInDwSp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Error thrown when a master variable is in a constraint that belongs to a Dantzig-Wolfe subproblem.</p><p>You can retrieve the JuMP variable and the JuMP constraint where the error occurs:</p><pre><code class="language-julia hljs">error.variable
error.constraint</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.VarsOfSameDwSpInMaster" href="#BlockDecomposition.VarsOfSameDwSpInMaster"><code>BlockDecomposition.VarsOfSameDwSpInMaster</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Warning when a master constraint involves variables that belong to the same Dantzig-Wolfe subproblem. It means you can move the constraint in a subproblem.</p></div></section></article><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.BlockModel" href="#BlockDecomposition.BlockModel"><code>BlockDecomposition.BlockModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BlockModel(optimizer [, direct_model = false])</code></pre><p>Return a JuMP model which BlockDecomposition will decompose using instructions given by the user.</p><p>If you define <code>direct_model = true</code>, the method creates the model with <code>JuMP.direct_model</code>, otherwise it uses <code>JuMP.Model</code>.</p></div></section></article><p>These are the methods to decompose a JuMP model :</p><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.@axis" href="#BlockDecomposition.@axis"><code>BlockDecomposition.@axis</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@axis(name, collection)</code></pre><p>Declare <code>collection</code> as an index-set of subproblems.  You can access the axis using the variable <code>name</code>.</p><p><strong>Examples</strong></p><p>Consider a formulation that has a decomposition which gives raise to 5 subproblems. Let {1,2,3,4,5} be the index-set of the subproblems.</p><p>To perform this decomposition with BlockDecomposition, we must declare an axis that contains the index-set of the subproblems :</p><pre><code class="language-julia-repl hljs">julia&gt; L = 1:5
1:5

julia&gt; @axis(K, L)
BlockDecomposition.Axis{:K, Int64}(:K, BlockDecomposition.AxisId{:K, Int64}[1, 2, 3, 4, 5])

julia&gt; K[1]
1

julia&gt; typeof(K[1])
BlockDecomposition.AxisId{:K, Int64}</code></pre><p>The elements of the axis are <code>AxisId</code>. You must use <code>AxisId</code> in the indices of the variables and the constraints that you declare otherwise BlockDecomposition assign them to the master problem.</p><pre><code class="nohighlight hljs">@variable(model, x[l in L]) # x[l] belongs to the master for any l ∈ L
@variable(model, y[k in K]) # y[k], k ∈ K, belongs to subproblem k (because K is an axis)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.@benders_decomposition" href="#BlockDecomposition.@benders_decomposition"><code>BlockDecomposition.@benders_decomposition</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@benders_decomposition(model, name, axis)</code></pre><p>Register a Benders decomposition on the JuMP model <code>model</code> where the index-set of the subproblems is defined by the axis <code>axis</code>.</p><p>Create a variable <code>name</code> from which the user can access decomposition tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.@dantzig_wolfe_decomposition" href="#BlockDecomposition.@dantzig_wolfe_decomposition"><code>BlockDecomposition.@dantzig_wolfe_decomposition</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@dantzig_wolfe_decomposition(model, name, axis)</code></pre><p>Register a Dantzig-Wolfe decomposition on the JuMP model <code>model</code> where the index-set of the subproblems is defined by the axis <code>axis</code>.</p><p>Create a variable <code>name</code> from which the user can access the decomposition tree.</p></div></section></article><p>These are the methods to set additional information to the decomposition (multiplcity and optimizers) :</p><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.getmaster" href="#BlockDecomposition.getmaster"><code>BlockDecomposition.getmaster</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getmaster(node) -&gt; MasterForm</code></pre><p>Return an object that wraps the annotation that describes the master formulation of a decomposition stored at the <code>node</code> of the decomposition tree.</p><p>This method is not defined if the node is a leaf of the decomposition tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.getsubproblems" href="#BlockDecomposition.getsubproblems"><code>BlockDecomposition.getsubproblems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getsubproblems(node) -&gt; Vector{SubproblemForm}</code></pre><p>Return a vector of objects that wrap the annotations that describe subproblem formulations of a decomposition stored at <code>node</code> of the decomposition tree.</p><p>This method is not defined if the node is a leaf of the decomposition tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.specify!" href="#BlockDecomposition.specify!"><code>BlockDecomposition.specify!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">specify!(
    subproblem, 
    lower_multiplicity = 1,
    upper_multiplicity = 1,
    solver = nothing
)</code></pre><p>Method that allows the user to specify additional property of the subproblems.</p><p>The multiplicity of <code>subproblem</code> is the number of times that the same independant block shaped by the subproblem in the coefficient matrix appears in the model. It is equivalent to the number of solutions to the subproblem that can appear in the solution  of the original problem.</p><p>The solver of the subproblem is the way the subproblem will be optimized. It can be either a function (pricing callback), an optimizer of MathOptInterface  (e.g. <code>Gurobi.Optimizer</code>, <code>CPLEX.Optimizer</code>, <code>Glpk.Optimizer</code>... with attributes),  or <code>nothing</code>. In the latter case, the solver will use a default optimizer that  should be defined in the parameters of the main solver.</p><p><strong>Advanced usage</strong> :  The user can use several solvers to optimize a subproblem : </p><pre><code class="nohighlight hljs">specify!(subproblem, solver = [Gurobi.Optimizer, my_callback, my_second_callback])</code></pre><p>Coluna always uses the first solver by default. Be cautious because changes are always buffered to all solvers. So you may degrade performances if you use a lot of solvers.</p></div></section></article><p>This method help you to check your decomposition :</p><article class="docstring"><header><a class="docstring-binding" id="BlockDecomposition.annotation" href="#BlockDecomposition.annotation"><code>BlockDecomposition.annotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">annotation(node)</code></pre><p>Return the annotation that describes the master/subproblem of a given node of the decomposition tree.</p><pre><code class="nohighlight hljs">annotation(model, variable)
annotation(model, constraint)</code></pre><p>Return the subproblem to which a variable or a constraint belongs.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../start/initial_columns/">« Initial columns callback</a><a class="docs-footer-nextpage" href="../config/">Configuration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Wednesday 10 August 2022 13:28">Wednesday 10 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
