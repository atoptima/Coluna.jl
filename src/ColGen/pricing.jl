#############################################################################
# Pricing strategy
#############################################################################
"""
A pricing strategy defines how we iterate on pricing subproblems.
A default pricing strategy consists in iterating on all pricing subproblems.

Basically, this object is used like this:

```julia
    pricing_strategy = ColGen.get_pricing_strategy(ctx, phase)
    it = ColGen.pricing_strategy_iterate(pricing_strategy)
    while !isnothing(it)
        (sp_id, sp_to_solve), state = It
        # Solve the subproblem `sp_to_solve`.
        it = iterate(it, state)
    end
```
"""
abstract type AbstractPricingStrategy end

"""
    get_pricing_strategy(ctx, phase) -> AbstractPricingStrategy

Returns the pricing strategy object.
"""
@mustimplement "ColGenPricing" get_pricing_strategy(ctx, phase)

"""
    pricing_strategy_iterate(pricing_strategy) -> ((sp_id, sp_to_solve), state)

Returns an iterator with the first pricing subproblem that must be optimized.
The next subproblem is returned by a call to `Base.iterate` using the information
provided by this method.
"""
@mustimplement "ColGenPricing" pricing_strategy_iterate(::AbstractPricingStrategy)

#############################################################################
# Columns generation.
#############################################################################
"""
Returns an initial dual bound for a pricing subproblem.
Default value should be +/- infinite depending on the optimization sense.
"""
@mustimplement "ColGenIteration" compute_sp_init_db()

"""
Returns an empty container that will store all the columns generated by the pricing problems
during an iteration of the column generation algorithm.
One must be able to iterate on this container to insert the columns in the master problem.
"""
@mustimplement "ColGenPricing" set_of_columns(ctx)

"""
    optimize_pricing_problem!(ctx, sp) -> PricingResult

Returns a custom object `PricingResult` that must implement following functions:
- `get_primal_sols`: array of primal solution to the pricing subproblem 
- `get_primal_bound`: best reduced cost (optional ?)
- `get_dual_bound`: dual bound of the pricing subproblem (used to compute the master dual bound)
"""
@mustimplement "ColGenPricing" optimize_pricing_problem!(ctx, sp)

"Array of primal solutions to the pricing subproblem"
@mustimplement "ColGenPricing" get_primal_sols(pricing_res)

"""
Returns dual bound of the pricing subproblem; `nothing` if no dual bound is available and
the intial dual bound returned by `compute_sp_init_db` will be used to compute the master
dual bound.
"""
@mustimplement "ColGenPricing" get_dual_bound(pricing_res)

"""
Push the column in the set of columns generated at a given iteration of the column
generation algorithm.
Columns stored in the set will then be considered for insertion in the master problem.
"""
@mustimplement "ColGenPricing" push_in_set!(pool, column)








