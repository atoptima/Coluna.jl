#############################################################################
# Pricing strategy
#############################################################################
"""
A pricing strategy defines how we iterate on pricing subproblems.
A default pricing strategy consists in iterating on all pricing subproblems.

Basically, this object is used like this:

```julia
    pricing_strategy = ColGen.get_pricing_strategy(ctx, phase)
    next = ColGen.pricing_strategy_iterate(pricing_strategy)
    while !isnothing(next)
        (sp_id, sp_to_solve), state = next
        # Solve the subproblem `sp_to_solve`.
        next = ColGen.pricing_strategy_iterate(pricing_strategy, state)
    end
```
"""
abstract type AbstractPricingStrategy end

"""
    get_pricing_strategy(ctx, phase) -> AbstractPricingStrategy

Returns the pricing strategy object.
"""
@mustimplement "ColGenPricing" get_pricing_strategy(ctx, phase) = nothing

"""
    pricing_strategy_iterate(pricing_strategy) -> ((sp_id, sp_to_solve), state)
    pricing_strategy_iterate(pricing_strategy, state) -> ((sp_id, sp_to_solve), state)

Returns an iterator with the first pricing subproblem that must be optimized.
The next subproblem is returned by a call to `Base.iterate` using the information
provided by this method.
"""
@mustimplement "ColGenPricing" pricing_strategy_iterate(::AbstractPricingStrategy) = nothing
@mustimplement "ColGenPricing" pricing_strategy_iterate(::AbstractPricingStrategy, state) = nothing

#############################################################################
# Pricing subproblem optimization
#############################################################################
"""
    optimize_pricing_problem!(ctx, sp, env, optimizer, mast_dual_sol) -> PricingResult

Returns a custom object `PricingResult` that must implement the following functions:
- `get_primal_sols`: array of primal solution to the pricing subproblem 
- `get_primal_bound`: best reduced cost (optional ?)
- `get_dual_bound`: dual bound of the pricing subproblem (used to compute the master dual bound)
- `master_dual_sol`: dual solution ``\\pi^{\\text{out}}`` to the master problem used to compute the real reduced cost of the column when stabilization is active
"""
@mustimplement "ColGenPricing" optimize_pricing_problem!(ctx, sp, env, optimizer, mast_dual_sol, stab_changes_mast_dual_sol) = nothing


#############################################################################
# Set of Generated Columns.
#############################################################################

"""
Returns an empty container that will store all the columns generated by the pricing problems
during an iteration of the column generation algorithm.
One must be able to iterate on this container to insert the columns in the master problem.
"""
@mustimplement "ColGenColumnsSet" set_of_columns(ctx) = nothing

"""
Pushes the column in the set of columns generated at a given iteration of the column
generation algorithm.
Columns stored in the set will then be considered for insertion in the master problem.
Returns `true` if column was inserted in the set, `false` otherwise.
"""
@mustimplement "ColGenColumnsSet" push_in_set!(context, pool, column) = nothing








