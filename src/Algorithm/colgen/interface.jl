abstract type AbstractColGenContext end 

"""
Structure where we store performance information about the column generation algorithm.
We can use these kpis as a stopping criteria for instance.
"""
abstract type AbstractColGenKpis end


"""
An iterator that indicates how a set of phases follow each other.

"""
abstract type AbstractColGenPhaseIterator end

"""
A phase of the column generation.
Each phase is associated with a specific set up of the reformulation.
"""
abstract type AbstractColGenPhase end

"Returns the phase with which the column generation algorithm must start." 
@mustimplement "ColGenPhase" initial_phase(::AbstractColGenContext)

"""
Returns the next phase of the column generation algorithm.
Returns `nothing` if the algorithm must stop.
"""
@mustimplement "ColGenPhase" next_phase(::AbstractColGenContext, ::AbstractColGenPhase, ctx::AbstractColGenContext)


"Setup the reformulation for the given phase."
@mustimplement "ColGen" setup_reformulation!(::AbstractColGenPhase, ::AbstractColGenContext, reform)

"Returns `true` if the column generation phase must stop."
@mustimplement "ColGen" stop_colgen_phase(context, phase, reform)


"""
Placeholder method called before the column generation iteration.
Does nothing by default but can be redefined to print some informations for instance.
We strongly advise users against the use of this method to modify the context or the reformulation.
"""
@mustimplement "ColGen" before_colgen_iteration(ctx::AbstractColGenContext, phase, reform)


"""
Runs an iteration of column generation.
"""
@mustimplement "ColGen" colgen_iteration(ctx::AbstractColGenContext, phase, reform)


"""
Placeholder method called after the column generation iteration.
Does nothing by default but can be redefined to print some informations for instance.
We strongly advise users against the use of this method to modify the context or the reformulation.
"""
@mustimplement "ColGen" after_colgen_iteration(::AbstractColGenContext, phase, reform, colgen_iter_output)

@mustimplement "ColGen" initial_primal_solution()

@mustimplement "ColGen" initial_dual_solution()

@mustimplement "ColGen" before_cut_separation()

@mustimplement "ColGen" run_cut_separation!()

@mustimplement "ColGen" after_cut_separation()

function run_colgen_phase!(context, phase, reform)
    colgen_iteration = 0
    cutsep_iteration = 0
    while !stop_colgen_phase(context, phase, reform)
        # cleanup ?
        before_colgen_iteration(context, phase, reform)
        colgen_iter_output = run_colgen_iteration!(context, phase, reform)
        after_colgen_iteration(context, phase, reform, colgen_iter_output)
        colgen_iteration += 1
        if separate_cuts()
            before_cut_separation()
            run_cut_separation!(context, phase, reform)
            after_cut_separation()
            cutsep_iteration += 1
        end
    end
end

function run!()
    phase = initial_phase(context)
    while !isnothing(phase)
        setup_reformulation(reform, phase, context)
        run_colgen_phase!(context, phase, reform)
        phase = next_phase(context, phase, reform)
    end
    return
end

############################################################################################
# Iteration of a column generation algorithm
############################################################################################

"""
Returns an instance of an object that implements both following functions:
- `get_primal_sol`: primal solution to the master (optional)
- `get_dual_sol`: dual solution to the master (mandatory otherwise column generation stops)

It should at least return a dual solution (obtained with LP optimization or subgradient) 
otherwise column generation cannot continue.
"""
@mustimplement "ColGenIteration" optimize_master_problem!()

"""
Returns primal solution of master optimization problem. 
See `optimize_master_problem!`.
"""
@mustimplement "ColGenIteration" get_primal_sol()

"""
Returns dual solution of master optimization problem. 
See `optimize_master_problem!`.
"""
@mustimplement "ColGenIteration" get_dual_sol()

"Compute reduced costs of subproblem variables."
@mustimplement "ColGenIteration" compute_sp_vars_red_costs()

"Update reduced costs of variables of a given subproblem."
@mustimplement "ColGenIteration" update_sp_vars_red_costs!()

"TODO"
@mustimplement "ColGenIteration" update_master_constrs_dual_vals!()

"""
Returns an initial dual bound for a pricing subproblem.
Default value should be +/- infinite depending on the optimization sense.
"""
@mustimplement "ColGenIteration" compute_sp_init_db()

"""
Returns an empty container that will store all the columns generated by the pricing problem.
One must be able to iterate on this container to insert the columns in the master problem.
"""
@mustimplement "ColgenIteration" pool_of_columns()

"""
Returns an arrays of objects that implement both following functions:
- `get_primal_sols`: array of primal solution to the pricing subproblem (mandatory)
- `get_ip_bound`: best reduced cost (mandatory)
- `get_dual_bound`: dual bound of the pricing subproblem (optional)

If no dual value is returned, the bound returne by `compute_sp_init_db`
"""
@mustimplement "ColGenIteration" optimize_pricing_problem!()


"Returns the dual bound to the master."
@mustimplement "ColGenIteration" compute_dual_bound!()

"Inserts columns into the master. Returns the number of columns inserted."
@mustimplement "ColGenIteration" insert_columns!()


# Pricing strategy iterator on subproblems

"""
A pricing strategy defines how we iterate on pricing subproblems.
A default pricing strategy can consists in iterating on all pricing subproblems.
"""
abstract type AbstractPricingStrategy end

"""
Returns the first subproblem that must be optimized.
"""
@mustimplement "ColGenPricingStrategy" first_sp(::AbstractPricingStrategy)

"""
Returns the next subproblem to optimize, or `nothing` if all subproblems have been solved or 
if we should stop solving pricing subproblems.
"""
@mustimplement "ColGenPricingStrategy" next_sp(::AbstractPricingStrategy)


"""
    run_colgen_iteration!(context, phase, reform)
"""
function run_colgen_iteration!()
    mast_result = optimize_master_lp_problem!(context, phase, reform)

    _check_master_termination_status(mast_result)

    # Master primal solution
    primal_mast_result = get_primal_sol(mast_result)
    if !isnothing(primal_mast_result)
        # If the master LP problem has a primal solution, we can try to find a integer feasible
        # solution.
        ip_primal_sol = check_primal_ip_feasibility(context, phase, reform)
        if !isnothing(ip_primal_sol)
            update_inc_primal_sol!(context, ip_primal_sol)
        end
    end

    dual_mast_result = get_dual_sol(mast_result)
    if isnothing(dual_mast_result)
        # error or stop?
    end

    update_master_constrs_dual_vals!(context, phase, reform, mast_dual_sol)

    # Stabilization

    # We separate computation and update of reduced costs for two reasons.
    # First, you need to iterate on each subproblem to update reduced costs whereas this is
    # not the case when you compute reduced costs (the most efficient way to compute sp vars
    # reduced costs is to perform a SpMV operation on the whole coefficient matrix of the 
    # master).
    # Second, it allows devs to tests if reduced costs are well computed. 
    red_costs = compute_sp_vars_red_costs(context, phase, reform, mast_dual_sol)
    for sp in get_dw_sp(reform)
        update_sp_vars_red_costs!(context, sp, red_costs)
    end

    # To compute the master dual bound, we need a dual bound to each pricing subproblems.
    # So we ask for an initial dual bound for each pricing subproblem that we update when
    # solving the pricing subproblem.
    # Depending on the pricing strategy, the user can choose to solve only some subproblems.
    # If the some subproblems have not been solved, we use this initial dual bound to
    # compute the master dual bound.
    sps_db = Dict(id(sp) => compute_sp_init_db(context, sp) for sp in get_dw_sp(reform))

    # Solve pricing subproblems
    pricing_strategy = get_pricing_strategy(context, phase)
    sp_to_solve = first_sp(pricing_strategy, reform)

    # All generated columns will be stored in the following container. We will insert them
    # into the master after the optimization of the pricing subproblems.
    generated_columns = pool_of_columns()

    while !isnothing(sp_to_solve)
        pricing_result = optimize_pricing_problem!(context, sp_to_solve)
        _check_pricing_termination_status(pricing_result)

        primal_sols = get_primal_sols(pricing_result)
        for primal_sol in primal_sols # multi column generation
            push!(generated_columns, primal_sol)
        end

        # Updates the initial bound if the pricing subproblem result has a dual bound.
        sp_db = get_dual_bound(context, pricing_result)
        if !isnothing(sp_db)
            sps_db[id(sp_to_solve)] = sp_db
        end

        sp_to_solve = next_sp(pricing_strategy, sp_to_solve)
    end

    # Insert columns into the master.
    insert_columns!(context, phase, reform, generated_columns)


    db = compute_dual_bound!(context, phase, reform, sps_db)
    # check gap

    return
end

