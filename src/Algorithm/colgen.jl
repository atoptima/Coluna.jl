"""
    Coluna.Algorithm.ColumnGeneration(
        restr_master_solve_alg = SolveLpForm(get_dual_sol = true),
        pricing_prob_solve_alg = SolveIpForm(
            moi_params = MoiOptimize(
                deactivate_artificial_vars = false,
                enforce_integrality = false
            )
        ),
        essential_cut_gen_alg = CutCallbacks(call_robust_facultative = false),
        strict_integrality_check = false, 
        max_nb_iterations = 1000,
        log_print_frequency = 1,
        redcost_tol = 1e-4,
        show_column_already_inserted_warning = true,
        cleanup_threshold = 10000,
        cleanup_ratio = 0.66,
        smoothing_stabilization = 0.0 # should be in [0, 1],
    )

Column generation algorithm that can be applied to formulation reformulated using
Dantzig-Wolfe decomposition. 

This algorithm first solves the linear relaxation of the master (master LP) using `restr_master_solve_alg`.
Then, it solves the subproblems by calling `pricing_prob_solve_alg` to get the columns that
have the best reduced costs and that hence, may improve the master LP's objective the most.

In order for the algorithm to converge towards the optimal solution of the master LP,
it suffices that the pricing oracle returns, at each iteration, a negative reduced cost solution if one exists. 
The algorithm stops when all subproblems fail to generate a column with negative
(positive) reduced cost in the case of a minimization (maximization) problem or when it
reaches the maximum number of iterations.

**Parameters:** 
- `restr_master_solve_alg`: algorithm to optimize the master LP
- `pricing_prob_solve_alg`: algorithm to optimize the subproblems
- `essential_cut_gen_alg`: algorithm to generate essential cuts which is run when the solution of the master LP is integer.

**Options:**
- `max_nb_iterations`: maximum number of iterations
- `log_print_frequency`: display frequency of iterations statistics
- `strict_integrality_check`: by default (value `false`) the integrality check in column generation is performed by the mapping procedure 
                              from "F. Vanderbeck, Branching in branch-and-price: a generic scheme, Math.Prog. (2011)";
                              in the case the pricing subproblems are solved by a callback, and some subproblem integer variables 
                              are "hidden" from _Coluna_, the mapping procedure may not be valid, and the integrality should be checked 
                              in the "strict" way (explicitly verifying that all columns are integer)

Undocumented parameters are in alpha version.

## About the ouput

At each iteration (depending on `log_print_frequency`), 
the column generation algorithm can display following statistics.

    <it= 90> <et=15.62> <mst= 0.02> <sp= 0.05> <cols= 4> <al= 0.00> <DB=  300.2921> <mlp=  310.3000> <PB=310.3000>

Here are their meanings :
- `it` stands for the current number of iterations of the algorithm
- `et` is the elapsed time in seconds since Coluna has started the optimisation
- `mst` is the time in seconds spent solving the master LP at the current iteration
- `sp` is the time in seconds spent solving the subproblems at the current iteration
- `cols` is the number of column generated by the subproblems at the current iteration
- `al` is the smoothing factor of the stabilisation at the current iteration (alpha version)
- `DB` is the dual bound of the master LP at the current iteration
- `mlp` is the objective value of the master LP at the current iteration
- `PB` is the objective value of the best primal solution found by Coluna at the current iteration
"""
struct ColumnGeneration <: AbstractOptimizationAlgorithm
    restr_master_solve_alg::SolveLpForm
    restr_master_optimizer_id::Int
    pricing_prob_solve_alg::SolveIpForm
    stages_pricing_solver_ids::Vector{Int}
    essential_cut_gen_alg::CutCallbacks
    strict_integrality_check::Bool
    max_nb_iterations::Int64
    log_print_frequency::Int64
    store_all_ip_primal_sols::Bool
    redcost_tol::Float64
    show_column_already_inserted_warning::Bool
    throw_column_already_inserted_warning::Bool
    solve_subproblems_parallel::Bool 
    cleanup_threshold::Int64 
    cleanup_ratio::Float64
    smoothing_stabilization::Float64
    opt_atol::Float64
    opt_rtol::Float64
    print::Bool
    ColumnGeneration(;
        restr_master_solve_alg = SolveLpForm(get_dual_sol=true),
        restr_master_optimizer_id = 1,
        pricing_prob_solve_alg = SolveIpForm(
            moi_params = MoiOptimize(
                deactivate_artificial_vars = false,
                enforce_integrality = false
            )
        ),
        stages_pricing_solver_ids = [1],
        essential_cut_gen_alg = CutCallbacks(call_robust_facultative=false),
        strict_integrality_check = false,
        max_nb_iterations = 1000,
        log_print_frequency = 1,
        store_all_ip_primal_sols = false,
        redcost_tol = 1e-4,
        show_column_already_inserted_warning = true,
        throw_column_already_inserted_warning = false,
        solve_subproblems_parallel = false,
        cleanup_threshold = 10000,
        cleanup_ratio = 0.66,
        smoothing_stabilization = 0.0, # should be in [0, 1]
        opt_atol = Coluna.DEF_OPTIMALITY_ATOL,
        opt_rtol = Coluna.DEF_OPTIMALITY_RTOL,
        print = true
    ) = new(
        restr_master_solve_alg,
        restr_master_optimizer_id,
        pricing_prob_solve_alg,
        stages_pricing_solver_ids,
        essential_cut_gen_alg,
        strict_integrality_check,
        max_nb_iterations,
        log_print_frequency,
        store_all_ip_primal_sols,
        redcost_tol,
        show_column_already_inserted_warning,
        throw_column_already_inserted_warning,
        solve_subproblems_parallel,
        cleanup_threshold,
        cleanup_ratio,
        smoothing_stabilization,
        opt_atol,
        opt_rtol,
        print
    )
end

############################################################################################
# Column generation parameters checker.
# `check_parameter` returns true by default
############################################################################################1
# function check_parameter(::ColumnGeneration, ::Val{:restr_master_solve_alg}, value, reform)
    
# end

# function check_parameter(::ColumnGeneration, ::Val{:restr_master_optimizer_id}, value, reform)

# end

# function check_parameter(::ColumnGeneration, ::Val{:pricing_prob_solve_alg}, value, reform)

# end

# function check_parameter(::ColumnGeneration, ::Val{:stages_pricing_solver_ids}, value, reform)

# end

# function check_parameter(::ColumnGeneration, ::Val{:essential_cut_gen_alg}, value, reform)

# end

check_parameter(::ColumnGeneration, ::Val{:max_nb_iterations}, value, reform) = value > 0
check_parameter(::ColumnGeneration, ::Val{:log_print_frequency}, value, reform) = value > 1
check_parameter(::ColumnGeneration, ::Val{:redcost_tol}, value, reform) = value > 0
check_parameter(::ColumnGeneration, ::Val{:cleanup_threshold}, value, reform) = value > 0
check_parameter(::ColumnGeneration, ::Val{:cleanup_ratio}, value, reform) = 0 < value < 1
check_parameter(::ColumnGeneration, ::Val{:smoothing_stabilization}, value, reform) =  0 <= value <= 1
check_parameter(::ColumnGeneration, ::Val{:opt_atol}, value, reform) = value > 0
check_parameter(::ColumnGeneration, ::Val{:opt_rtol}, value, reform) = value > 0


stabilization_is_used(algo::ColumnGeneration) = !iszero(algo.smoothing_stabilization)

############################################################################################
# Implementation of Algorithm interface.
############################################################################################

function get_child_algorithms(algo::ColumnGeneration, reform::Reformulation)
    child_algs = Dict{String, Tuple{AlgoAPI.AbstractAlgorithm, MathProg.Formulation}}(
        "restr_master_solve_alg" => (algo.restr_master_solve_alg, getmaster(reform)),
        "essential_cut_gen_alg" => (algo.essential_cut_gen_alg, getmaster(reform))
    ) 

    for (id, spform) in get_dw_pricing_sps(reform)
        child_algs["pricing_prob_solve_alg_sp$id"] = (algo.pricing_prob_solve_alg, spform)
    end

    return child_algs
end

function get_units_usage(algo::ColumnGeneration, reform::Reformulation) 
    units_usage = Tuple{AbstractModel,UnitType,UnitPermission}[] 
    master = getmaster(reform)
    push!(units_usage, (master, MasterColumnsUnit, READ_AND_WRITE))
    push!(units_usage, (master, StaticVarConstrUnit, READ_ONLY))
    push!(units_usage, (master, PartialSolutionUnit, READ_ONLY))

    # as column generation may call essential cut callbacks
    # TO DO: it would be good to verify first whether any callback is really defined 
    push!(units_usage, (master, MasterCutsUnit, READ_AND_WRITE)) 
    
    for (_, spform) in get_dw_pricing_sps(reform)
        push!(units_usage, (spform, StaticVarConstrUnit, READ_ONLY))
    end
    if stabilization_is_used(algo)
        #push!(units_usage, (master, ColGenStabilizationUnit, READ_AND_WRITE))
    end
    return units_usage
end

############################################################################################
# Column generation algorithm.
############################################################################################
function _colgen_context(algo::ColumnGeneration)
    algo.print && return ColGenPrinterContext
    return ColGenContext
end

function _new_context(C::Type{<:ColGen.AbstractColGenContext}, reform, algo)
    return C(reform, algo)
end

function _colgen_optstate_output(result, master)
    optstate = OptimizationState(master)

    if ColGen.is_infeasible(result)
        # If the column generation finds the problem infeasible, we consider that all the
        # other information are irrelevant.
        setterminationstatus!(optstate, INFEASIBLE)
    else
        lp_primal_sol = ColGen.get_master_lp_primal_sol(result)
        if !isnothing(lp_primal_sol)
            set_lp_primal_sol!(optstate, lp_primal_sol)
        end

        ip_primal_sol = ColGen.get_master_ip_primal_sol(result)
        if !isnothing(ip_primal_sol)
            update_ip_primal_sol!(optstate, ip_primal_sol)
        end

        lp_dual_sol = ColGen.get_master_dual_sol(result)
        if !isnothing(lp_dual_sol)
            update_lp_dual_sol!(optstate, lp_dual_sol)
        end

        db = ColGen.get_dual_bound(result)
        if !isnothing(result.db)
            set_lp_dual_bound!(optstate, DualBound(master, db))
            set_ip_dual_bound!(optstate, DualBound(master, db))
        end

        mlp = ColGen.get_master_lp_primal_bound(result)
        if !isnothing(mlp)
            set_lp_primal_bound!(optstate, PrimalBound(master, mlp))
        end
    end
    return optstate
end

# run!() function to be called from the ColGenConquer algorithm
function run!(algo::ColumnGeneration, env::Env, reform::Reformulation, input::AbstractConquerInput)
    # We build 
    C = _colgen_context(algo)
    ctx = _new_context(C, reform, algo)
    result = ColGen.run!(ctx, env, get_global_primal_handler(input))

    master = getmaster(reform)
    return _colgen_optstate_output(result, master)
end

# run!() function to be called from optimize!(), i.e. when ColumnGeneration is the top Coluna algorithm
function run!(
    algo::ColumnGeneration, env::Env, reform::Reformulation, input_state::OptimizationState
)
    C = _colgen_context(algo)
    ctx = _new_context(C, reform, algo)
    result = ColGen.run!(
        ctx, env, GlobalPrimalBoundHandler(
            reform; 
            ip_primal_bound = get_ip_primal_bound(input_state)
        )
    )

    master = getmaster(reform)
    output_state = _colgen_optstate_output(result, master)

    # if !isnothing(get_global_primal_sol(space.inc_primal_manager))
    #     add_ip_primal_sol!(space.optstate, get_global_primal_sol(space.inc_primal_manager))
    # end

    if ip_gap_closed(output_state, rtol = algo.opt_rtol, atol = algo.opt_atol)
        setterminationstatus!(output_state, OPTIMAL)
    else
        setterminationstatus!(output_state, OTHER_LIMIT)
    end
    return output_state
end