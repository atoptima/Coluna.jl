var documenterSearchIndex = {"docs":
[{"location":"man/decomposition/#Dantzig-Wolfe-and-Benders-decompositions","page":"Decomposition paradigms","title":"Dantzig-Wolfe and Benders decompositions","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Coluna is a framework to optimize mixed-integer programs that you can decompose. In other words, if you remove the linking constraints or linking variables from your program, you'll get sets of constraints (blocks) that you can solve independently.","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Decompositions are typically used on programs whose constraints or variables can be divided into a set of \"easy\" constraints (respectively easy variables) and a set of \"hard\" constraints (respectively hard variables). Decomposing on constraints leads to Dantzig-Wolfe transformation while decomposing on variables leads to the Benders transformation. Both of these decompositions are implemented in Coluna. ","category":"page"},{"location":"man/decomposition/#Dantzig-Wolfe","page":"Decomposition paradigms","title":"Dantzig-Wolfe","text":"","category":"section"},{"location":"man/decomposition/#Original-formulation","page":"Decomposition paradigms","title":"Original formulation","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Let's consider the following coefficient matrix that has a block diagonal structure in gray and some linking constraints in blue :","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"(Image: Dantzig-Wolfe decomposition)","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"You penalize the violation of the linking constraints in the objective function. You can then solve the blocks independently.","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"The Dantzig-Wolfe reformulation gives rise to a master problem with an exponential number of variables. Coluna dynamically generates these variables by solving the subproblems. It's the column generation algorithm.","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Let's consider the following original formulation in which we partition variables into two vectors x_1 and x_2 :","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"beginaligned\nmin quad c_1 x_1 + c_2 x_2  \ntextst quad A_1 x_1 + A_2 x_2 geq b  (1)\n D_1 x_1 quad quad quad   geq d_1  (2) \n quad   quad quad D_2 x_2 geq d_2  (3) \nendaligned","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"variables x_1 and x_2 are the original variables of the problem (duty: OriginalVar)\nconstraints (1) are the linking constraints (duty: OriginalConstr)\nconstraints (2) shapes the first subproblem (duty: OriginalConstr)\nconstraints (3) shapes the second subproblem (duty: OriginalConstr)","category":"page"},{"location":"man/decomposition/#Master","page":"Decomposition paradigms","title":"Master","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"When you apply a Dantzig-Wofe decomposition to this formulation,  Coluna reformulates it into the following master problem :","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"beginaligned\nmin quad sumlimits_q in Q_1 c_1 tildex_1^q lambda_q + sumlimits_q in Q_2 c_2 tildex_2^q lambda_q + fa \ntextst quad sumlimits_q in Q_1 A_1 tildex_1^q lambda_q + sumlimits_q in Q_2 A_2 tildex_2^q lambda_q + a geq b  (1)\n L_1 leq sumlimits_q in Q_1 tildez_1lambda_q leq U_1  (2)\n L_2 leq sumlimits_q in Q_2 tildez_2lambda_q leq U_2  (3)\n lambda_q geq 0 quad q in Q_1 cup Q_2\nendaligned","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"where:","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"set Q_1 is the index set of the solutions to the first subproblem \nset Q_2 is the index set of the solutions to the second subproblem\nset of the solutions to the first is tildex^q_1_q in Q_1 (duty: MasterRepPricingVar)\nset of the solutions to the second subproblem is tildex^q_2_q in Q_2 respectively (duty: MasterRepPricingVar)\nconstraint (1) is the reformulation of the linking constraints (duty: MasterMixedConstr)\nconstraint (2) is the convexity constraint of the first subproblem and involves the lower L_1 and upper U_1 multiplicity of the subproblem (duty: MasterConvexityConstr)\nconstraint (3) is the convexity constraint of the second subproblem and involves the lower L_2 and upper U_2 multiplicity of the subproblem (duty: MasterConvexityConstr)\nvariables tildez_1 and tildez_2 are representative of pricing setup variables in the master (always equal to 1) (duty: MasterRepPricingVar)\nvariables lambda_q are the columns (duty: MasterCol)\nvariable a is the artificial variable (duty: MasterArtVar)","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"At the beginning of the column generation algorithm, the master formulation does not have any master columns. Therefore, the master may be infeasible.  To prevent this, Coluna adds a local artificial variable a specific to each constraint of the master and a global artificial variable. Costs f of artificial and global artificial variables can be defined in Coluna.Params.","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Lower and upper multiplicities of subproblems are 1 by default. However, when some subproblems are identical (same coefficient matrix and right-hand side),  you can avoid solving all of them at each iteration by defining only one subproblem and setting its multiplicity to the number of times it appears. See this tutorial to get an example of Dantzig-Wolfe decomposition with identical subproblems. ","category":"page"},{"location":"man/decomposition/#Pricing-Subproblem","page":"Decomposition paradigms","title":"Pricing Subproblem","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Subproblems take the following form (here, it's the first subproblem):","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"beginaligned\nmin quad barc_1 x_1 + z_1\ntextst quad D_1x_1 geq d_1  (1)\n quad x_1 geq 0\nendaligned","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"where:","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"vector barc is the reduced cost of the subproblem variables computed by the column generation algorithm. \nvariables x_1 are the subproblem variables (duty: DwSpPricingVar)\nconstraint (1) is the subproblem constraint (duty: DwSpPureConstr)\nvariable z_1 is the pricing setup variable (always equal to 1) (duty: DwSpSetupVar)","category":"page"},{"location":"man/decomposition/#Benders","page":"Decomposition paradigms","title":"Benders","text":"","category":"section"},{"location":"man/decomposition/#Original-formulation-2","page":"Decomposition paradigms","title":"Original formulation","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Let's consider the following coefficient matrix that has a block diagonal structure in gray and some linking variables in blue :","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"(Image: Benders decomposition)","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"The intuition behind Benders decomposition is that some hard problems can become much easier with some of their variables fixed.  Benders aims to divide the variables of the problem into two \"levels\": the 1st level variables which, once fixed, make it easier to find a solution for the remaining variables, the so-called 2nd-level variables.","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"The question is how to set the 1st level variables. Benders' theory proceeds by the successive generation of cuts: given a 1st-level solution, we ask the following questions:","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Is the subproblem infeasible? If so, then the 1st-level solution is not correct and must be eliminated. A feasibility cut will be derived from the dual subproblem and added to the master.\nDoes the aggregation of the master and subproblem solutions give rise to an optimal solution to the problem? It depends on a criterion that can be computed. If it is the case, we are done, else, we derive an optimality cut from the dual subproblem and add it into the master.","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Formally, given an original MIP:","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"beginaligned\nmin quad cx + fy  \ntextst quad Ax geq a  (2) \n Ey geq e                   (3) \n Bx + Dy geq d              (4)\n x y geq 0  x in mathbbZ^n\nendaligned","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"where:","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"variables x are the 1st-level variables (duty: OriginalVar)\nvariables y are the 2nd-level variables (duty: OriginalVar)\nconstraints (2) are the 1st-level constraints (duty: OriginalConstr)\nconstraints (3) are the 2nd-level constraints (duty: OriginalConstr)\nconstraints (4) are the linking constraints (duty: OriginalConstr)","category":"page"},{"location":"man/decomposition/#Master-2","page":"Decomposition paradigms","title":"Master","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"When you apply a Benders decomposition to this formulation,  Coluna reformulates it into the following master problem :","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"beginaligned\nmin quad cx + sumlimits_k in Keta_k  \ntextst quad Ax geq a  (5)\n textbenders cuts  (6) \n eta_k in mathbbR quad forall k in K\nendaligned","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"where:","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"variables x are the 1st-level variables (duty: MasterBendFirstStageVar)\nvariables eta are the second stage cost variables (duty: MasterBendSecondStageCostVar)\nconstraints (5) are the first-level constraints (duty: MasterPureConstr)\nconstraints (6) are the benders cuts (duty: ``)","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Note that the eta variables are free.","category":"page"},{"location":"man/decomposition/#Separation-subproblem","page":"Decomposition paradigms","title":"Separation subproblem","text":"","category":"section"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Here is the form of a given separation subproblem:","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"beginaligned\nmin quad fy  \ntextst quad Dy geq d - Bbarx  (7) \n Ey geq e  (8) \n y geq 0 \nendaligned","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"where:","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"variables y are the 2nd-level variables (duty: BendSpSepVar)\nvalues barx are a solution to the master problem \nconstraints (7) are the linking constraints with the 1st-level variables fixed to barx (duty: BendSpTechnologicalConstr)\nconstraints (8) are the 2nd-level constraints (duty: BendSpPureConstr)","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"Note that in the special case where the master problem is unbounded, the shape of the subproblem is slightly modified. See the API section to get more information.","category":"page"},{"location":"man/decomposition/","page":"Decomposition paradigms","title":"Decomposition paradigms","text":"","category":"page"},{"location":"api/algos/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"danger: Danger\nWork in progress.","category":"page"},{"location":"api/algos/#Parameters-of-an-algorithm","page":"Algorithms","title":"Parameters of an algorithm","text":"","category":"section"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"From a user perspective, the algorithms are objects that contains a set of parameters.","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"The object must inherit from Coluna.AlgoAPI.AbstractAlgorithm. We usually provide a keyword constructor to define default values for parameters and therefore ease the definition of the object.","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"struct MyCustomAlgorithm <: Coluna.AlgoAPI.AbstractAlgorithm\n    param1::Int\n    param2::Float64\n    child_algo::Coluna.AlgoAPI.AbstractAlgorithm\nend\n\n# Help the user to define the algorithm:\nfunction MyCustomAlgorithm(;\n    param1 = 1,\n    param2 = 2,\n    child_algo = AnotherAlgorithm()\n) \n    return MyCustomAlgorithm(param1, param2, child_algo)\nend","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"Algorithms can use other algorithms. They are organized as a tree structure.","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"** Example for the TreeSearchAlgorithm **:","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"graph TD\n    TreeSearchAlgorithm ---> ColCutGenConquer\n    TreeSearchAlgorithm ---> ClassicBranching\n    ColCutGenConquer --> ColumnGeneration\n    ColCutGenConquer --> RestrictedHeuristicMaster\n    RestrictedHeuristicMaster --> SolveIpForm#2\n    ColumnGeneration --> SolveLpForm#1\n    ColumnGeneration --> SolveIpForm#1\n    ColumnGeneration --> CutCallbacks\n","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"Coluna.AlgoAPI.AbstractAlgorithm","category":"page"},{"location":"api/algos/#Coluna.AlgoAPI.AbstractAlgorithm","page":"Algorithms","title":"Coluna.AlgoAPI.AbstractAlgorithm","text":"Supertype for algorithms parameters. Data structures that inherit from this type are intented for the users. The convention is to define the data structure together with a constructor that contains only kw args.\n\nFor instance:\n\n    struct MyAlgorithmParams <: AbstractAlgorithmParams\n        param1::Int\n        param2::Int\n        MyAlgorithmParams(; param1::Int = 1, param2::Int = 2) = new(param1, param2)\n    end\n\n\n\n\n\n","category":"type"},{"location":"api/algos/#Init","page":"Algorithms","title":"Init","text":"","category":"section"},{"location":"api/algos/#Parameters-checking","page":"Algorithms","title":"Parameters checking","text":"","category":"section"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"When Coluna starts, it initializes the algorithms chosen by the user. A most important step is to check the consistency of the parameters supplied by the user and the compatibility of the algorithms with the model that will be received (usually MathProg.Reformulation). Algorithms usually have many parameters and are sometimes interdependent and nested. It is crucial to ensure that the user-supplied parameters are correct and give hints to fix them otherwise.","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"The entry-point of the parameter consistency checking is the following method:","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"Coluna.Algorithm.check_alg_parameters","category":"page"},{"location":"api/algos/#Coluna.Algorithm.check_alg_parameters","page":"Algorithms","title":"Coluna.Algorithm.check_alg_parameters","text":"check_alg_parameters(top_algo, reform) -> Vector{Tuple{Symbol, AbstractAlgorithm, Any}}\n\nChecks the consistency of the parameters of the top algorithm and its children algorithms. Returns a vector of tuples (name of the parameter, algorithm, value of the parameter) that lists all the inconsistencies found in the algorithms tree.\n\n\n\n\n\n","category":"function"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"Developer of an algorithm must implement the following methods:","category":"page"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"Coluna.Algorithm.check_parameter","category":"page"},{"location":"api/algos/#Units-usage","page":"Algorithms","title":"Units usage","text":"","category":"section"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"Coluna.AlgoAPI.get_child_algorithms\nColuna.AlgoAPI.get_units_usage","category":"page"},{"location":"api/algos/#Run","page":"Algorithms","title":"Run","text":"","category":"section"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"Coluna.AlgoAPI.run!","category":"page"},{"location":"api/algos/#Coluna.AlgoAPI.run!","page":"Algorithms","title":"Coluna.AlgoAPI.run!","text":"run!(algo::AbstractAlgorithm, env, model, input)\n\nDefault method to call an algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/algos/","page":"Algorithms","title":"Algorithms","text":"","category":"page"},{"location":"dynamic_sparse_arrays/#Dynamic-Sparse-Arrays","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"","category":"section"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"This package aims to provide dynamic sparse vectors and matrices in Julia.  Unlike the sparse arrays provided in SparseArrays, arrays from this package have unfixed sizes.  It means that we can add or delete rows and columns after the instantiation of the array.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"DynamicSparseArrays is a registered package.","category":"page"},{"location":"dynamic_sparse_arrays/#Introduction","page":"Dynamic Sparse Arrays","title":"Introduction","text":"","category":"section"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"Coluna is a branch-cut-and-price framework. It means that Coluna's algorithms dynamically generate constraints and variables. Therefore, the coefficient matrix (which is usually sparse) must support the addition of new rows and columns.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"For this purpose, we implemented the packed-memory array data structure to handle the dynamic sparse vector introduced in the following papers:","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"BENDER, Michael A. et HU, Haodong. An adaptive packed-memory array. ACM Transactions on Database Systems (TODS), 2007, vol. 32, no 4, p. 26.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"BENDER, Michael A., DEMAINE, Erik D., et FARACH-COLTON, Martin. Cache-oblivious B-trees. SIAM Journal on Computing, 2005, vol. 35, no 2, p. 341-358.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"On top of the packed-memory array, we implemented the data structure introduced in the following paper to handle the dynamic sparse matrix.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"WHEATMAN, Brian et XU, Helen. Packed Compressed Sparse Row: A Dynamic Graph Representation. In : 2018 IEEE High Performance extreme Computing Conference (HPEC). IEEE, 2018. p. 1-7.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"The implementation may vary from the description in the papers. If you find some enhancements, please contact guimarqu.","category":"page"},{"location":"dynamic_sparse_arrays/#Overview","page":"Dynamic Sparse Arrays","title":"Overview","text":"","category":"section"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"The packed-memory array (PackedMemoryArray{K,T}) is a Vector{Union{Nothing,Tuple{K,T}}} where K is the type of the keys and T is the type of the values. We keep empty entries (i.e. Nothing) in the array to add new values later fast. Non-empty entries are sorted by ascending key order. The array is virtually split into segments of equal size. The goal is to maintain the density (i.e. number of non-empty values/size of the segment) of each segment between pre-defined bounds. We also consider the density of certain unions of segments represented by nodes of the tree in gray. The root node of the tree is the union of all segments, thus the whole array. When one node of the tree has a density outside the allowed bounds, we need to rebalance the parent. It means that we redistribute the empty and non-empty entries to fit the density bounds. If the density bounds are not respected at the root node, we resize the array.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"On top of the packed-memory array, there is the (PackedCSC{K,T}).  This is a particular case of a matrix where values are of type T, row keys of type K, and column keys of type Int. Each column of the matrix (partition) is delimited by a semaphore which is a non-empty entry with a reserved key value defined by the semaphore_key function. In the example, the first partition has its semaphore at position 1, starts at position 2, and finishes at position 9.  At position 10, it's the semaphore that signals the beginning of the second partition. In each partition, non-empty entries are sorted by ascending key order.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"As you can see, the PackedCSC{K,T} is not well suited to the matrix. Indeed, each column is associated with a partition. If you have a column with only zero values, the array will contain a partition with only empty entries. Lastly, the type of column key is Int. Therefore, built on top of PackedCSC{K,T}, MappedCSC{K,L,T} corrects all these shortcomings. This data structure just associates a column key of type L to each partition of PackedCSC{K,T}.","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"<div style=\"width:75%; margin-left:auto; margin-right:auto\">","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"(Image: Dynamic Sparse Arrays)","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"<p style=\"text-align: center;\">Architecture overview.</p>\n</div>","category":"page"},{"location":"dynamic_sparse_arrays/#References","page":"Dynamic Sparse Arrays","title":"References","text":"","category":"section"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"    CurrentModule = DynamicSparseArrays","category":"page"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"dynamicsparsevec\ndynamicsparse","category":"page"},{"location":"dynamic_sparse_arrays/#DynamicSparseArrays.dynamicsparsevec","page":"Dynamic Sparse Arrays","title":"DynamicSparseArrays.dynamicsparsevec","text":"dynamicsparsevec(I, V, [combine, n])\n\nCreates a dynamic sparse vector S of length n such that S[I[k]] = S[V[k]]. The combine operator is used to combine the values of V that have same id in I.\n\n\n\n\n\n","category":"function"},{"location":"dynamic_sparse_arrays/#DynamicSparseArrays.dynamicsparse","page":"Dynamic Sparse Arrays","title":"DynamicSparseArrays.dynamicsparse","text":"dynamicsparse(I, J, V, [m, n])\n\nCreates a dynamic sparse matrix S of dimensions m×n such that S[I[k], J[k]] = V[k].\n\n\n\n\n\ndynamicsparse(Ti, Tj, Tv [; fill_mode = true])\n\nCreates an empty dynamic sparse matrix with row keys of type Ti, column keys of  type Tj, and non-zero values of type Tv. By default, the matrix is returned in a \"fill mode\". This allows the user to fill the matrix with non-zero entries. All the write operations are stored in a Dict. When the matrix is filled, the user must call closefillmode!(matrix).\n\n\n\n\n\n","category":"function"},{"location":"dynamic_sparse_arrays/","page":"Dynamic Sparse Arrays","title":"Dynamic Sparse Arrays","text":"","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"CurrentModule = Coluna","category":"page"},{"location":"api/branching/#Branching-API","page":"Branching","title":"Branching API","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Coluna provides default implementations for the branching algorithm and the strong branching algorithms. Both implementations are built on top of an API that we describe here.","category":"page"},{"location":"api/branching/#Candidates-selection","page":"Branching","title":"Candidates selection","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Candidates selection is the first step (and sometimes the only step) of any branching algorithm. It chooses what are the possible branching constraints that will generate the children of the current node of the branch-and-bound tree.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Coluna provides the following function for this step:","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.select!","category":"page"},{"location":"api/branching/#Coluna.Branching.select!","page":"Branching","title":"Coluna.Branching.select!","text":"Candidates selection for branching algorithms.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"It works as follows.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"The user chooses one or several branching rules that indicate the type of branching he wants to perform. This may be on a single variable or on a linear expression of variables for instance. ","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"The branching rule must implement apply_branching_rule that generates the candidates.  The latter are the variables or expressions on which the branch-and-bound may branch with additional information that is requested by Coluna's branching implementation through the API.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Then, candidates are sorted according to a selection criterion (e.g. most fractional). The algorithm keeps a certain number of candidates (one for classic branching, and several for strong branching). It generates the children of each candidate kept. At last, it returns the candidates kept.","category":"page"},{"location":"api/branching/#Branching-rule","page":"Branching","title":"Branching rule","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.AbstractBranchingRule\nBranching.apply_branching_rule","category":"page"},{"location":"api/branching/#Coluna.Branching.AbstractBranchingRule","page":"Branching","title":"Coluna.Branching.AbstractBranchingRule","text":"Supertype of branching rules.\n\n\n\n\n\n","category":"type"},{"location":"api/branching/#Coluna.Branching.apply_branching_rule","page":"Branching","title":"Coluna.Branching.apply_branching_rule","text":"Returns all candidates that satisfy a given branching rule.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Candidate","page":"Branching","title":"Candidate","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.AbstractBranchingCandidate\nBranching.getdescription\nBranching.get_lhs\nBranching.get_local_id\nBranching.generate_children!","category":"page"},{"location":"api/branching/#Coluna.Branching.AbstractBranchingCandidate","page":"Branching","title":"Coluna.Branching.AbstractBranchingCandidate","text":"A branching candidate is a data structure that contain all information needed to generate children of a node.\n\n\n\n\n\n","category":"type"},{"location":"api/branching/#Coluna.Branching.getdescription","page":"Branching","title":"Coluna.Branching.getdescription","text":"Returns a string which serves to print the branching rule in the logs.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_lhs","page":"Branching","title":"Coluna.Branching.get_lhs","text":"Returns the left-hand side of the candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_local_id","page":"Branching","title":"Coluna.Branching.get_local_id","text":"Returns the generation id of the candidiate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.generate_children!","page":"Branching","title":"Coluna.Branching.generate_children!","text":"generate_children!(branching_context, branching_candidate, lhs, env, reform, node)\n\nThis method generates the children of a node described by branching_candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Selection-criterion","page":"Branching","title":"Selection criterion","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.AbstractSelectionCriterion\nBranching.select_candidates!","category":"page"},{"location":"api/branching/#Coluna.Branching.AbstractSelectionCriterion","page":"Branching","title":"Coluna.Branching.AbstractSelectionCriterion","text":"Supertype of selection criteria of branching candidates.\n\nA selection criterion provides a way to keep only the most promising branching candidates. To create a new selection criterion, one needs to create a subtype of AbstractSelectionCriterion and implements the method select_candidates!.\n\n\n\n\n\n","category":"type"},{"location":"api/branching/#Coluna.Branching.select_candidates!","page":"Branching","title":"Coluna.Branching.select_candidates!","text":"Sort branching candidates according to the selection criterion and remove excess ones.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Branching-API-2","page":"Branching","title":"Branching API","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.get_selection_nb_candidates\nBranching.branching_context_type\nBranching.new_context\nBranching.get_int_tol\nBranching.get_rules\nBranching.get_selection_criterion","category":"page"},{"location":"api/branching/#Coluna.Branching.get_selection_nb_candidates","page":"Branching","title":"Coluna.Branching.get_selection_nb_candidates","text":"Returns the number of candidates that the candidates selection step must return.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.branching_context_type","page":"Branching","title":"Coluna.Branching.branching_context_type","text":"Returns the type of context required by the algorithm parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.new_context","page":"Branching","title":"Coluna.Branching.new_context","text":"Creates a context.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_int_tol","page":"Branching","title":"Coluna.Branching.get_int_tol","text":"Returns integer tolerance.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_rules","page":"Branching","title":"Coluna.Branching.get_rules","text":"Returns branching rules.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_selection_criterion","page":"Branching","title":"Coluna.Branching.get_selection_criterion","text":"Returns the selection criterion.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Method advanced_select! is part of the API but presented just below.","category":"page"},{"location":"api/branching/#Advanced-candidates-selection","page":"Branching","title":"Advanced candidates selection","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"If the candidates' selection returns several candidates will all their children, advanced candidates selection must keep only one of them.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"The advanced candidates' selection is the place to evaluate the children to get relevant additional key performance indicators about each branching candidate.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Coluna provides the following function for this step.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.advanced_select!","category":"page"},{"location":"api/branching/#Coluna.Branching.advanced_select!","page":"Branching","title":"Coluna.Branching.advanced_select!","text":"Advanced candidates selection that selects candidates by evaluating their children.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Coluna has two default implementations for this method:","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"for the classic branching that does nothing because the candidates selection returns 1 candidate\nfor the strong branching that performs several evaluations of the candidates.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Let us focus on the strong branching.  Strong branching is a procedure that heuristically selects a branching constraint that potentially gives the best progress of the dual bound. The procedure selects a collection of branching candidates based on their branching rule (done in classic candidate selection)  and their score (done in advanced candidate selection). Then, the procedure evaluates the progress of the dual bound in both branches of each branching candidate by solving both potential children using a conquer algorithm. The candidate that has the largest score is chosen to be the branching constraint.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"However, the score can be difficult to compute. For instance, when the score is based on dual bound improvement produced by the branching constraint which is time-consuming to evaluate in the context of column generation Therefore, one can let the branching algorithm quickly estimate the score of each candidate  and retain the most promising branching candidates.  This is called a phase. The goal is to first evaluate a large number of candidates with a very fast conquer algorithm and retain a certain number of promising ones.  Then, over the phases, it evaluates the improvement with a more precise conquer algorithm and restricts the number of retained candidates until only one is left.","category":"page"},{"location":"api/branching/#Strong-Branching-API","page":"Branching","title":"Strong Branching API","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.get_units_to_restore_for_conquer\nBranching.get_phases\nBranching.get_score\nBranching.get_conquer\nBranching.get_max_nb_candidates","category":"page"},{"location":"api/branching/#Coluna.Branching.get_units_to_restore_for_conquer","page":"Branching","title":"Coluna.Branching.get_units_to_restore_for_conquer","text":"Returns the storage units that must be restored by the conquer algorithm called by the strong branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_phases","page":"Branching","title":"Coluna.Branching.get_phases","text":"Returns all phases context of the strong branching algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_score","page":"Branching","title":"Coluna.Branching.get_score","text":"Returns the type of score used to rank the candidates at a given strong branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_conquer","page":"Branching","title":"Coluna.Branching.get_conquer","text":"Returns the conquer algorithm used to evaluate the candidate's children at a given strong branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Coluna.Branching.get_max_nb_candidates","page":"Branching","title":"Coluna.Branching.get_max_nb_candidates","text":"Returns the maximum number of candidates kept at the end of a given strong branching phase.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"The following methods are part of the API but have a default implementation. We advise you to not change them.","category":"page"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.perform_branching_phase!\nBranching.eval_candidate!\nBranching.eval_child_of_candidate!","category":"page"},{"location":"api/branching/#Coluna.Branching.eval_child_of_candidate!","page":"Branching","title":"Coluna.Branching.eval_child_of_candidate!","text":"Evaluate children of a candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/#Score","page":"Branching","title":"Score","text":"","category":"section"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"Branching.AbstractBranchingScore\nBranching.compute_score","category":"page"},{"location":"api/branching/#Coluna.Branching.AbstractBranchingScore","page":"Branching","title":"Coluna.Branching.AbstractBranchingScore","text":"Supertype of branching scores.\n\n\n\n\n\n","category":"type"},{"location":"api/branching/#Coluna.Branching.compute_score","page":"Branching","title":"Coluna.Branching.compute_score","text":"Returns the score of a candidate.\n\n\n\n\n\n","category":"function"},{"location":"api/branching/","page":"Branching","title":"Branching","text":"","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"EditURL = \"storage.jl\"","category":"page"},{"location":"api/storage/#Storage-API","page":"Storage","title":"Storage API","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"      CurrentModule = Coluna","category":"page"},{"location":"api/storage/#API","page":"Storage","title":"API","text":"","category":"section"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"To summarize from a developer's point of view, there is a one-to-one correspondence between storage unit types and record types. This correspondence is implemented by methods record_type(StorageUnitType) and storage_unit_type(RecordType).","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"The developer must also implement methods storage_unit(StorageUnitType) and record(RecordType, id, model, storage_unit) that must call constructors of the custom storage unit and one of its associated records. Arguments of record allow the developer to record the state of entities from both the storage unit and the model.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"At last, he must implement restore_from_record!(storage_unit, model, record) to restore the state of the entities represented by the storage unit. Entities can be in the storage unit, the model, or both of them.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"    ColunaBase.record_type\n    ColunaBase.storage_unit_type\n    ColunaBase.storage_unit\n    ColunaBase.record\n    ColunaBase.restore_from_record!","category":"page"},{"location":"api/storage/#Coluna.ColunaBase.record_type","page":"Storage","title":"Coluna.ColunaBase.record_type","text":"Returns the type of record stored in a type of storage unit.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Coluna.ColunaBase.storage_unit_type","page":"Storage","title":"Coluna.ColunaBase.storage_unit_type","text":"Returns the type of storage unit that stores a type of record.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Coluna.ColunaBase.storage_unit","page":"Storage","title":"Coluna.ColunaBase.storage_unit","text":"Returns a storage unit from a given type.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Coluna.ColunaBase.record","page":"Storage","title":"Coluna.ColunaBase.record","text":"Creates a record of information from the model or a storage unit.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/#Coluna.ColunaBase.restore_from_record!","page":"Storage","title":"Coluna.ColunaBase.restore_from_record!","text":"Restore information from the model or the storage unit that is recorded in a record.\n\n\n\n\n\n","category":"function"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/storage/","page":"Storage","title":"Storage","text":"","category":"page"},{"location":"start/other_pbs/","page":"Other classic problems","title":"Other classic problems","text":"Here is a non-exhaustive list of classic problems tackled with Coluna:","category":"page"},{"location":"start/other_pbs/","page":"Other classic problems","title":"Other classic problems","text":"Generalized Assignement and some variants using pricing callback and cut callback\nBin Packing","category":"page"},{"location":"start/other_pbs/","page":"Other classic problems","title":"Other classic problems","text":"","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"EditURL = \"start.jl\"","category":"page"},{"location":"start/start/#tuto_gen_assignement","page":"Column generation","title":"Column generation with the Generalized Assignment Problem","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This quick start guide introduces the main features of Coluna through the example of the Generalized Assignment Problem.","category":"page"},{"location":"start/start/#Classic-model-solved-with-MIP-solver","page":"Column generation","title":"Classic model solved with MIP solver","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Consider a set of machines M and a set of jobs J. A machine m has a resource capacity Q_m . A job j assigned to a machine m has a cost c_mj and consumes w_mj resource units of the machine m. The goal is to minimize the sum of job costs while assigning each job to a machine and not exceeding the capacity of each machine.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Let x_mj equal to one if job j is assigned to machine m; 0 otherwise. The problem has the original formulation:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"beginalignedat4\ntextGAP equiv min mathrlapsum_m in Msum_j in J c_mj x_mj  \ntextst  sum_m in M x_mj = 1  quad j in J \n sum_j in J w_mj x_mj leq Q_m  quad  quad m in M  \n x_mj  in 01  m in M j in J\nendalignedat","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Let us consider the following instance.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"M = 1:3;\nJ = 1:15;\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5; 19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7; 13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2];\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91;91 81 66 63 59 81 87 90 65 55 57 68 92 91 86; 62 79 73 60 75 66 68 99 69 60 56 100 67 68 54];\nQ = [1020 1460 1530];\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"We write the model with JuMP, a domain-specific modeling language for mathematical optimization embedded in Julia. We optimize with GLPK. If you are not familiar with the JuMP package, you may want to check its documentation.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"using JuMP, GLPK;\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"A JuMP model for the original formulation is:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"model = Model(GLPK.Optimizer)\n@variable(model, x[m in M, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M) >= 1);\n@constraint(model, knp[m in M], sum(w[m, j] * x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M, j in J));\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"We optimize the instance and retrieve the objective value.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"optimize!(model);\nobjective_value(model)","category":"page"},{"location":"start/start/#Try-column-generation-easily-with-Coluna-and-BlockDecomposition","page":"Column generation","title":"Try column generation easily with Coluna and BlockDecomposition","text":"","category":"section"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This model has a block structure: each knapsack constraint defines an independent block and the set-partitioning constraints couple these independent blocks. By applying the Dantzig-Wolfe reformulation, each knapsack constraint forms a tractable subproblem and the set-partitioning constraints are handled in a master problem.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"To write the model, you need JuMP and BlockDecomposition. The latter is an extension built on top of JuMP to model Dantzig-Wolfe and Benders decompositions. You will find more documentation about BlockDecomposition in the Decomposition & reformulation To optimize the problem, you need Coluna and a Julia package that provides a MIP solver such as GLPK.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Since we have already loaded JuMP and GLPK, we just need:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"using BlockDecomposition, Coluna;\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Next, you instantiate the solver and define the algorithm that you use to optimize the problem. In this case, the algorithm is a classic branch-and-price provided by Coluna.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default branch-cut-and-price\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In BlockDecomposition, an axis is an index set of subproblems. Let M_axis be the index set of machines; it defines an axis along which we can implement the desired decomposition.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@axis(M_axis, M);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In this example, the axis M_axis defines one knapsack subproblem for each machine. For instance, the first machine index is 1 and is of type BlockDecomposition.AxisId:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"M_axis[1]\n\ntypeof(M_axis[1])","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Jobs are not involved in the decomposition, set J of jobs thus stays as a classic range.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The model takes the form:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"model = BlockModel(coluna);\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You can write BlockModel(coluna; direct_model = true) to pass names of variables and constraints to Coluna.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M_axis) >= 1);\n@constraint(model, knp[m in M_axis], sum(w[m, j] * x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M_axis, j in J));\nnothing #hide","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This is the same model as above except that we use a BlockModel instead of a Model and M_axis as the set of machines instead of M. Therefore, BlockDecomposition will know which variables and constraints are involved in subproblems because one of their indices is a BlockDecomposition.AxisId.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You then apply a Dantzig-Wolfe decomposition along M_axis:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"@dantzig_wolfe_decomposition(model, decomposition, M_axis)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"where decomposition is a variable that contains information about the decomposition.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"decomposition","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Once the decomposition is defined, you can retrieve the master and the subproblems to give additional information to the solver.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"master = getmaster(decomposition)\nsubproblems = getsubproblems(decomposition)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The multiplicity of a subproblem is the number of times that the same independent block shaped by the subproblem appears in the model. This multiplicity also specifies the number of solutions to the subproblem that can appear in the solution to the original problem.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"In this GAP instance, the upper multiplicity is 1 because every subproblem is different, i.e., every machine is different and used at most once.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The lower multiplicity is 0 because a machine may stay unused. The multiplicity specifications take the form:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"specify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)\ngetsubproblems(decomposition)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"The model is now fully defined. To solve it, you need to call:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"optimize!(model)","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"You can find more information about the output of the column generation algorithm ColumnGeneration.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"Finally, you can retrieve the solution to the original formulation with JuMP methods. For example, if we want to know if job 3 is assigned to machine 1:","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"value(x[1,3])","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/start/","page":"Column generation","title":"Column generation","text":"","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"CurrentModule = Coluna","category":"page"},{"location":"api/benders/#api_benders","page":"Benders","title":"Benders cut generation","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna provides an interface and generic functions to implement a Benders cut generation algorithm.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"In this section, we are first going to present the generic functions, the implementation with some theory backgrounds and then give the references of the interface. The default implementation is based on the paper of ","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"You can find the generic functions and the interface in the Benders submodule and the  default implementation in the Algorithm submodule at src/Algorithm/benders.","category":"page"},{"location":"api/benders/#Context","page":"Benders","title":"Context","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The Benders submodule provides an interface and generic functions to implement a benders cut generation algorithm. The implementation depends on an object called context.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.AbstractBendersContext","category":"page"},{"location":"api/benders/#Coluna.Benders.AbstractBendersContext","page":"Benders","title":"Coluna.Benders.AbstractBendersContext","text":"Supertype for the objects to which belongs the implementation of the Benders cut generation and that stores any kind of information during the execution of the Bender cut generation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Benders provides two types of context:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Algorithm.BendersContext\nColuna.Algorithm.BendersPrinterContext","category":"page"},{"location":"api/benders/#Coluna.Algorithm.BendersContext","page":"Benders","title":"Coluna.Algorithm.BendersContext","text":"BendersContext(reformulation, algo_params) -> BendersContext\n\nDefault implementation of the Benders algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/#Coluna.Algorithm.BendersPrinterContext","page":"Benders","title":"Coluna.Algorithm.BendersPrinterContext","text":"BendersPrinterContext(reformulation, algo_params) -> BendersPrinterContext\n\nCreates a context to run the default implementation of the Benders algorithm together with a printer that prints information about the algorithm execution.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/#Generic-functions","page":"Benders","title":"Generic functions","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Generic functions are the core of the Benders cut generation algorithm. There are three generic functions:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.run_benders_loop!","category":"page"},{"location":"api/benders/#Coluna.Benders.run_benders_loop!","page":"Benders","title":"Coluna.Benders.run_benders_loop!","text":"Main loop of the Benders cut generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"See ...","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.run_benders_iteration!","category":"page"},{"location":"api/benders/#Coluna.Benders.run_benders_iteration!","page":"Benders","title":"Coluna.Benders.run_benders_iteration!","text":"Runs one iteration of a Benders cut generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"See ...","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"These functions are independent of any other submodule of Coluna. You can use them to implement your own Benders cut generation algorithm.","category":"page"},{"location":"api/benders/#Reformulation","page":"Benders","title":"Reformulation","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The default implementation works with a reformulated problem contained in  MathProg.Reformulation where master and subproblems are MathProg.Formulation objects.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The master has the following form:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"beginaligned\nmin        quad cx + sum_k in K eta_k  \ntextst quad Ax geq a   (1) \n                  text benders cuts   (2) \n                  l_1 leq x leq u_1   (3) \n                  eta_k in mathbbR  forall k in K quad (4)\nendaligned","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"where x are first-stage variables,  eta_k is the second-stage cost variable for the subproblem k, constraints (1) are the first-stage constraints, constraints (2) are the Benders cuts, constraints (3) are the bounds on the first-stage variables, and expression (4) shows that second-stage variables are free.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The subproblems have the following form:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"beginaligned\nmin        quad fy  + colorgray mathbf1z + mathbf1z                \ntextst quad Dy colorgray + z geq d  - Bbarx  (5)  quad colorblue(pi) \n                         Ey colorgray + z geq e                   (6)  quad colorblue(rho) \n                         l_2 leq y leq u_2      (7)  quad colorblue(sigma)\nendaligned","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"where y are second-stage variables, z and z are artificial variables (in grey because they are deactivated by default), constraints (5) are the reformulation of linking constraints using the first-stage solution barx, constraints (6) are the second-stage constraints, and constraints (7) are the bounds on the second-stage variables. In blue, we define the dual variables associated to these constraints.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.is_minimization\nColuna.Benders.get_reform\nColuna.Benders.get_master\nColuna.Benders.get_benders_subprobs","category":"page"},{"location":"api/benders/#Coluna.Benders.is_minimization","page":"Benders","title":"Coluna.Benders.is_minimization","text":"Returns true if the objective sense is minimization, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.get_reform","page":"Benders","title":"Coluna.Benders.get_reform","text":"Returns Benders reformulation.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.get_master","page":"Benders","title":"Coluna.Benders.get_master","text":"Returns the master problem.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.get_benders_subprobs","page":"Benders","title":"Coluna.Benders.get_benders_subprobs","text":"Returns the separation subproblems.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Main-loop","page":"Benders","title":"Main loop","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"This is a description of how the Coluna.Benders.run_benders_loop! generic function behaves with the default implementation.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The loop stops if one of the following conditions is met:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"the master is infeasible\na separation subproblem is infeasible\nthe time limit is reached\nthe maximum number of iterations is reached\nno new cut is generated","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The default implementation returns:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Algorithm.BendersOutput","category":"page"},{"location":"api/benders/#Coluna.Algorithm.BendersOutput","page":"Benders","title":"Coluna.Algorithm.BendersOutput","text":"Output of the default implementation of the Benders algorithm.\n\nIt contains:\n\ninfeasible: the original problem is infeasible\ntime_limit_reached: the time limit was reached\nmlp: the final bound obtained with the Benders cut algorithm\nip_primal_sol: the best primal solution to the original problem found by the Benders cut algorithm\n\n\n\n\n\n","category":"type"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.setup_reformulation!\nColuna.Benders.stop_benders\nColuna.Benders.after_benders_iteration\nColuna.Benders.AbstractBendersOutput\nColuna.Benders.benders_output_type\nColuna.Benders.new_output","category":"page"},{"location":"api/benders/#Coluna.Benders.setup_reformulation!","page":"Benders","title":"Coluna.Benders.setup_reformulation!","text":"Prepares the reformulation before starting the Benders cut generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.stop_benders","page":"Benders","title":"Coluna.Benders.stop_benders","text":"Returns true if the Benders cut generation algorithm must stop, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.after_benders_iteration","page":"Benders","title":"Coluna.Benders.after_benders_iteration","text":"Placeholder method called after each iteration of the Benders cut generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.AbstractBendersOutput","page":"Benders","title":"Coluna.Benders.AbstractBendersOutput","text":"Supertype for the custom objects that will store the output of the Benders cut generation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/#Coluna.Benders.benders_output_type","page":"Benders","title":"Coluna.Benders.benders_output_type","text":"benders_output_type(context) -> Type{<:AbstractBendersOutput}\n\nReturns the type of the custom object that will store the output of the Benders cut generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.new_output","page":"Benders","title":"Coluna.Benders.new_output","text":"Returns a new instance of the custom object that stores the output of the Benders cut generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Benders-cut-generation-iteration","page":"Benders","title":"Benders cut generation iteration","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"This is a description of how the Coluna.Benders.run_benders_iteration! generic function behaves with the default implementation.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"These are the main steps of a Benders cut generation iteration without stabilization. Click on the step to go to the corresponding section.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"flowchart TB;\n    id1(Optimize master)\n    id2(Treat unbounded master)\n    id3(Setup separation subproblems)\n    id4(Separation subproblem iterator)\n    id5(Optimize separation subproblem)\n    id6(Push cut into set)\n    id9(Master is unbounded?)\n    id10(Error)\n    id7(Insert cuts)\n    id11(Build primal solution)\n    id8(Iteration output)\n    id1 --unbounded--> id2\n    id2 --certificate--> id3\n    id1 -- optimal --> id3\n    id3 --> id4\n    id4 -- subproblem --> id5\n    id5 --> id6\n    id6 --> id4\n    id4 -- end --> id9\n    id9 -- yes --> id10\n    id9 -- no --> id7\n    id7 --> id11\n    id11 --> id8\n    click id1 href \"#Master-optimization\" \"Link to doc\"\n    click id2 href \"#Unbounded-master-case\" \"Link to doc\"\n    click id3 href \"#Setup-separation-subproblems\" \"Link to doc\"\n    click id4 href \"#Subproblem-iterator\" \"Link to doc\"\n    click id5 href \"#Separation-subproblem-optimization\" \"Link to doc\"\n    click id6 href \"#Set-of-generated-cuts\" \"Link to doc\"\n    click id9 href \"#Unboundedness-check\" \"Link to doc\"\n    click id11 href \"#Current-primal-solution\" \"Link to doc\"\n    click id7 href \"#Cuts-insertion\" \"Link to doc\"\n    click id8 href \"#Iteration-output\" \"Link to doc\"","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"In the default implementation, some sections may have different behaviors depending on the  result of previous steps.","category":"page"},{"location":"api/benders/#Master-optimization","page":"Benders","title":"Master optimization","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"This operation consists in optimizing the master problem in order to find a first-level solution barx.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"In the default implementation, master optimization can be performed using SolveLpForm (LP solver) or SolveIpForm (MILP solver). When getting the solution, we store the current value of second stage variables bareta_k as incumbent value (see Coluna.MathProg.getcurincval).","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"It returns an object of the following type:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Algorithm.BendersMasterResult","category":"page"},{"location":"api/benders/#Coluna.Algorithm.BendersMasterResult","page":"Benders","title":"Coluna.Algorithm.BendersMasterResult","text":"Output of the default implementation of the Benders.optimize_master_problem! method.\n\nIt contains:\n\nip_solver: true if the master problem is solved with a MIP solver and involves integral variables, false otherwise.\nresult: the result of the master problem optimization stored in an OptimizationState object.\ninfeasible: true if the master at the current iteration is infeasible; false otherwise.\nunbounded: true if the master at the current iteration is unbounded; false otherwise.\ncertificate: true if the master at the current iteration is unbounded and if the current result is a dual infeasibility certificate, false otherwise.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.optimize_master_problem!","category":"page"},{"location":"api/benders/#Coluna.Benders.optimize_master_problem!","page":"Benders","title":"Coluna.Benders.optimize_master_problem!","text":"optimize_master_problem!(master, context, env) -> MasterResult\n\nReturns an instance of a custom object MasterResult that implements the following methods:\n\nis_unbounded(res::MasterResult) -> Bool\nis_infeasible(res::MasterResult) -> Bool\nis_certificate(res::MasterResult) -> Bool\nget_primal_sol(res::MasterResult) -> Union{Nothing, PrimalSolution}\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Go back to the cut generation iteration diagram.","category":"page"},{"location":"api/benders/#Unbounded-master-case","page":"Benders","title":"Unbounded master case","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Second stage cost eta_k variables are free. As a consequence, the master problem is unbounded when there is no optimality Benders cuts.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"In this case, Coluna.Benders.treat_unbounded_master_problem_case! is called. The main goal of the default implementation of this method is to get the dual infeasibility certificate of the master problem.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"If the master has been solved with a MIP solver at the previous step, we need to relax the integrality constraints to get a dual infeasibility certificate.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"If the solver does not provide a dual infeasibility certificate, the implementation has an \"emergency\" routine to provide a first-stage feasible solution by solving the master LP with cost of second stage variables set to zero. We recommend using a solver that provides a dual infeasibility certificate and avoiding the \"emergency\" routine.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.treat_unbounded_master_problem_case!","category":"page"},{"location":"api/benders/#Coluna.Benders.treat_unbounded_master_problem_case!","page":"Benders","title":"Coluna.Benders.treat_unbounded_master_problem_case!","text":"treat_unbounded_master_problem_case!(master, context, env) -> MasterResult\n\nWhen after a call to optimize_master_problem!, the master is unbounded, this method is called. Returns an instance of a custom object MasterResult.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Go back to the cut generation iteration diagram.","category":"page"},{"location":"api/benders/#Setup-separation-subproblems","page":"Benders","title":"Setup separation subproblems","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"info: Info\nThe separation subproblems differs depending on whether the restricted master is unbounded or not:if the restricted master is optimal, the generic function calls Coluna.Benders.update_sp_rhs!\nif the restricted master is unbounded, the generic function calls Coluna.Benders.setup_separation_for_unbounded_master_case!","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Default implementation of Coluna.Benders.update_sp_rhs! updates the right-hand side of the linking constraints (5).","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Reference:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.update_sp_rhs!","category":"page"},{"location":"api/benders/#Coluna.Benders.update_sp_rhs!","page":"Benders","title":"Coluna.Benders.update_sp_rhs!","text":"update_sp_rhs!(context, sp, mast_primal_sol)\n\nUpdates the right-hand side of the separation problem sp by fixing the first-level solution obtained by solving the master problem mast_primal_sol.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Default implementation of Coluna.Benders.setup_separation_for_unbounded_master_case! gives rise to the formulation proposed in Lemma 2 of Bonami et al:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"beginaligned\n(SepB) equiv min        quad fy  + colorgray mathbf1z + mathbf1z                \ntextst quad Dy colorgray + z geq -Bbarx  (5a)  quad colorblue(pi) \n                         Ey colorgray + z geq 0                   (6a)  quad colorblue(rho) \n                         y geq 0      (7a)  quad colorblue(sigma)\nendaligned","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"where y are second-stage variables, z and z are artificial variables (in grey because they are deactivated by default), and barx is an unbounded ray of the restricted master.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Reference:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.setup_separation_for_unbounded_master_case!","category":"page"},{"location":"api/benders/#Coluna.Benders.setup_separation_for_unbounded_master_case!","page":"Benders","title":"Coluna.Benders.setup_separation_for_unbounded_master_case!","text":"setup_separation_for_unbounded_master_case!(context, sp, mast_primal_sol)\n\nUpdates the separation problem to derive a cut when the master problem is unbounded.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Subproblem-iterator","page":"Benders","title":"Subproblem iterator","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Not implemented yet.","category":"page"},{"location":"api/benders/#Separation-subproblem-optimization","page":"Benders","title":"Separation subproblem optimization","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The default implementation first optimize the subproblem without the artificial variables z and z. In the case where it finds (barpi barrho barsigma) an optimal dual solution to the subproblem, the following cut is generated:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"eta_k + barpiBx geq dbarpi + barrhoe + barsigma_leq l_2 + barsigma_geq u_2","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"with barsigma_leq l_2 (respectively barsigma_geq u_2) the dual of the left part (respectively the right part) of constraint l_2 leq y leq u_2 of the subproblem. ","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"In the case where it finds the subproblem infeasible, it calls Coluna.Benders.treat_infeasible_separation_problem_case!. The default implementation of this method activates the artificial variables z and z, sets the cost of second stage variables to 0, and optimizes the subproblem again.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"If a solution with no artificial variables is found, the following cut is generated:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"barpiBx geq dbarpi + barrhoe + barsigma_leq l_2 + barsigma_geq u_2","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Both methods return an object of the following type:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Algorithm.BendersSeparationResult","category":"page"},{"location":"api/benders/#Coluna.Algorithm.BendersSeparationResult","page":"Benders","title":"Coluna.Algorithm.BendersSeparationResult","text":"Output of the default implementation of the Benders.optimize_separation_problem! and Benders.treat_infeasible_separation_problem_case! methods.\n\nIt contains:\n\nsecond_stage_estimation_in_master: the value of the second stage cost variable in the solution to the master problem.\nsecond_stage_cost: the value of the second stage cost variable in the solution to the separation problem.\nlp_primal_sol: the primal solution to the separation problem.\ninfeasible: true if the current separation problem is infeasible; false otherwise.\nunbounded: true if the current separation problem is unbounded; false otherwise.\ncut: the cut generated by the separation problem.\ninfeasible_treatment: true if this object is an output of the Benders.treat_infeasible_separation_problem_case! method; false otherwise.\nunbounded_master: true if the separation subproblem has the form of Lemma 2 to separate a cut to truncate an unbounded ray of the restricted master problem; false otherwise.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.optimize_separation_problem!\nColuna.Benders.treat_infeasible_separation_problem_case!","category":"page"},{"location":"api/benders/#Coluna.Benders.optimize_separation_problem!","page":"Benders","title":"Coluna.Benders.optimize_separation_problem!","text":"optimize_separation_problem!(context, sp_to_solve, env, unbounded_master) -> SeparationResult\n\nReturns an instance of a custom object SeparationResult that implements the following methods:\n\nis_unbounded(res::SeparationResult) -> Bool\nis_infeasible(res::SeparationResult) -> Bool\nget_obj_val(res::SeparationResult) -> Float64\nget_primal_sol(res::SeparationResult) -> Union{Nothing, PrimalSolution}\nget_dual_sp_sol(res::SeparationResult) -> Union{Nothing, DualSolution}\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.treat_infeasible_separation_problem_case!","page":"Benders","title":"Coluna.Benders.treat_infeasible_separation_problem_case!","text":"treat_infeasible_separation_problem_case!(context, sp_to_solve, env, unbounded_master) -> SeparationResult\n\nWhen after a call to optimize_separation_problem!, the separation problem is infeasible, this method is called. Returns an instance of a custom object SeparationResult.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Go back to the cut generation iteration diagram.","category":"page"},{"location":"api/benders/#Set-of-generated-cuts","page":"Benders","title":"Set of generated cuts","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"You can define your data structure to manage the cuts generated at a given iteration. Columns are inserted after the optimization of all the separation subproblems to allow the parallelization of the latter.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"In the default implementation, cuts are represented by the following data structure:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Algorithm.GeneratedCut","category":"page"},{"location":"api/benders/#Coluna.Algorithm.GeneratedCut","page":"Benders","title":"Coluna.Algorithm.GeneratedCut","text":"Solution to the separation problem together with its corresponding benders cut.\n\nIt contains:\n\nmin_sense: true if it's a minimization problem; false otherwise.\nlhs: the left-hand side of the cut.\nrhs: the right-hand side of the cut.\ndual_sol: an optimal dual solution to the separation problem.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"We use the following data structures to store the cuts and the primal solutions to the subproblems:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Algorithm.CutsSet\nColuna.Algorithm.SepSolSet","category":"page"},{"location":"api/benders/#Coluna.Algorithm.CutsSet","page":"Benders","title":"Coluna.Algorithm.CutsSet","text":"Stores a collection of cuts.\n\nIt contains cuts a vector of GeneratedCut objects.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/#Coluna.Algorithm.SepSolSet","page":"Benders","title":"Coluna.Algorithm.SepSolSet","text":"Primal solutions to the separation problems optimized at the current iteration. This is used to build a primal solution.\n\nIt contains sols a vector of primal solutions. \n\n\n\n\n\n","category":"type"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The default implementation of push_in_set! has the responsibility to check if the cut is violated. Given bareta_k solution to the restricted master and bary solution to the separation problem, the cut is considered as violated when:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"the separation subproblem was infeasible\nor bareta_k geq fbary ","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.set_of_cuts\nColuna.Benders.set_of_sep_sols\nColuna.Benders.push_in_set!","category":"page"},{"location":"api/benders/#Coluna.Benders.set_of_cuts","page":"Benders","title":"Coluna.Benders.set_of_cuts","text":"Returns an empty container that will store all the cuts generated by the separation problems during an iteration of the Benders cut generation algorithm. One must be able to iterate on this container to insert the cuts in the master problem.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.set_of_sep_sols","page":"Benders","title":"Coluna.Benders.set_of_sep_sols","text":"Returns an empty container that will store the primal solutions to the separation problems at a given iteration of the Benders cut generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.push_in_set!","page":"Benders","title":"Coluna.Benders.push_in_set!","text":"push_in_set!(context, cut_pool, sep_result) -> Bool\n\nInserts a cut in the set of cuts generated at a given iteration of the Benders cut generation algorithm. The cut_pool structure is generated by set_of_cuts(context).\n\npush_in_set!(context, sep_sp_sols, sep_result) -> Bool\n\nInserts a primal solution to a separation problem in the set of primal solutions generated at a given iteration of the Benders cut generation algorithm. The sep_sp_sols structure is generated by set_of_sep_sols(context).\n\nReturns true if the cut or the primal solution was inserted in the set, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Go back to the cut generation iteration diagram.","category":"page"},{"location":"api/benders/#Unboundedness-check","page":"Benders","title":"Unboundedness check","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"info: Info\nThis check is performed only when the restricted master is unbounded.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"To perform this check, we need a solution to each separation problem.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Let (bareta_k)_k in K be the value of second stage variables in the dual infeasibility certificate of the restricted master. Let bary be an optimal solution to the separation problem (SepB).","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"As indicated by Bonami et al., if fbary leq sumlimits_k in K bareta_k, then the  original problem is unbounded (by definition of an unbounded ray of the original problem).","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.master_is_unbounded","category":"page"},{"location":"api/benders/#Coluna.Benders.master_is_unbounded","page":"Benders","title":"Coluna.Benders.master_is_unbounded","text":"Returns true if the master has been proven unbounded, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Cuts-insertion","page":"Benders","title":"Cuts insertion","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"The default implementation inserts into the master all the cuts stored in the CutsSet object.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Reference:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.insert_cuts!","category":"page"},{"location":"api/benders/#Coluna.Benders.insert_cuts!","page":"Benders","title":"Coluna.Benders.insert_cuts!","text":"Inserts the cuts into the master.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Go back to the cut generation iteration diagram.","category":"page"},{"location":"api/benders/#Current-primal-solution","page":"Benders","title":"Current primal solution","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Lorem ipsum.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.build_primal_solution","category":"page"},{"location":"api/benders/#Coluna.Benders.build_primal_solution","page":"Benders","title":"Coluna.Benders.build_primal_solution","text":"Builds a primal solution to the original problem from the primal solution to the master  problem and the primal solutions to the separation problems.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Iteration-output","page":"Benders","title":"Iteration output","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Algorithm.BendersIterationOutput","category":"page"},{"location":"api/benders/#Coluna.Algorithm.BendersIterationOutput","page":"Benders","title":"Coluna.Algorithm.BendersIterationOutput","text":"Output of the default implementation of an iteration of the Benders algorithm.\n\nIt contains:\n\nmin_sense: the original problem is a minimization problem\nnb_new_cuts: the number of new cuts added to the master problem\nip_primal_sol: the primal solution to the original problem found during this iteration\ninfeasible: the original problem is infeasible\ntime_limit_reached: the time limit was reached\nmaster: the solution value to the master problem\n\n\n\n\n\n","category":"type"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"References:","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.AbstractBendersIterationOutput\nColuna.Benders.benders_iteration_output_type\nColuna.Benders.new_iteration_output","category":"page"},{"location":"api/benders/#Coluna.Benders.AbstractBendersIterationOutput","page":"Benders","title":"Coluna.Benders.AbstractBendersIterationOutput","text":"Supertype for the custom objects that will store the output of a Benders iteration.\n\n\n\n\n\n","category":"type"},{"location":"api/benders/#Coluna.Benders.benders_iteration_output_type","page":"Benders","title":"Coluna.Benders.benders_iteration_output_type","text":"benders_iteration_output_type(context) -> Type{<:AbstractBendersIterationOutput}\n\nReturns the type of the custom object that will store the output of a Benders iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.new_iteration_output","page":"Benders","title":"Coluna.Benders.new_iteration_output","text":"Returns a new instance of the custom object that stores the output of a Benders iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Go back to the cut generation iteration diagram.","category":"page"},{"location":"api/benders/#Getters-for-Result-data-structures","page":"Benders","title":"Getters for Result data structures","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Method name Master Separation\nis_unbounded X X\nis_infeasible X X\nis_certificate X \nget_primal_sol X X\nget_dual_sol X \nget_obj_val X X","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Coluna.Benders.is_unbounded\nColuna.Benders.is_infeasible\nColuna.Benders.is_certificate\nColuna.Benders.get_primal_sol\nColuna.Benders.get_dual_sol\nColuna.Benders.get_obj_val","category":"page"},{"location":"api/benders/#Coluna.Benders.is_unbounded","page":"Benders","title":"Coluna.Benders.is_unbounded","text":"Returns true if the problem is unbounded, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.is_infeasible","page":"Benders","title":"Coluna.Benders.is_infeasible","text":"Returns true if the master is infeasible, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.is_certificate","page":"Benders","title":"Coluna.Benders.is_certificate","text":"Returns the certificate of dual infeasibility if the master is unbounded, nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.get_primal_sol","page":"Benders","title":"Coluna.Benders.get_primal_sol","text":"Returns the primal solution of the master problem if it exists, nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.get_dual_sol","page":"Benders","title":"Coluna.Benders.get_dual_sol","text":"Returns the dual solution of the separation problem if it exists; nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/#Coluna.Benders.get_obj_val","page":"Benders","title":"Coluna.Benders.get_obj_val","text":"Returns the objective value of the master or separation problem.\n\n\n\n\n\n","category":"function"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Go back to the cut generation iteration diagram.","category":"page"},{"location":"api/benders/#Stabilization","page":"Benders","title":"Stabilization","text":"","category":"section"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"Not implemented yet.","category":"page"},{"location":"api/benders/","page":"Benders","title":"Benders","text":"","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"EditURL = \"identical_sp.jl\"","category":"page"},{"location":"start/identical_sp/#tuto_identical_sp","page":"Identical subproblems","title":"Identical subproblems","text":"","category":"section"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"Let us see an example of resolution using the advantage of identical subproblems with Dantzig-Wolfe and a variant of the Generalized Assignment Problem.","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"Consider a set of machine type T = 1:nb_machine_types and a set of jobs J = 1:nb_jobs. A machine type t has a resource capacity Q[t] and the factory contains U[t] machines of type t. A job j assigned to a machine of type t has a cost c[t,j] and consumes w[t,j] resource units of the machine of type t.","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"Consider the following instance :","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"nb_machine_types = 2;\nnb_jobs = 8;\nJ = 1:nb_jobs;\nQ = [10, 15];\nU = [3, 2];  # 3 machines of type 1 & 2 machines of type 2\nc = [10 11 13 11 12 14 15 8; 20 21 23 21 22 24 25 18];\nw = [4 4 5 4 4 3 4 5; 5 5 6 5 5 4 5 6];\n\n\n#Here is the JuMP model to optimize this instance with a classic solver :\n\nusing JuMP, GLPK;\n\nT1 = [1, 2, 3]; # U[1] machines\nT2 = [4, 5]; # U[2] machines\nM = union(T1, T2);\nm2t = [1, 1, 1, 2, 2]; # machine id -> type id\n\nmodel = Model(GLPK.Optimizer);\n@variable(model, x[M, J], Bin); # 1 if job j assigned to machine m\n@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1);\n@constraint(model, knp[m in M], sum(w[m2t[m],j] * x[m,j] for j in J) <= Q[m2t[m]]);\n@objective(model, Min, sum(c[m2t[m],j] * x[m,j] for m in M, j in J));\n\noptimize!(model);\nobjective_value(model)","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"You can decompose over the machines by defining an axis on M. However, if you want to take advantage of the identical subproblems, you must define the formulation as follows :","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"using BlockDecomposition, Coluna, JuMP, GLPK;\nconst BD = BlockDecomposition\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\n\n@axis(T, 1:nb_machine_types);\n\nmodel = BlockModel(coluna);\n@variable(model, x[T, J], Bin); # 1 if job j assigned to machine m\n@constraint(model, cov[j in J], sum(x[t,j] for t in T) == 1);\n@constraint(model, knp[t in T], sum(w[t] * x[t,j] for j in J) <= Q[t]);\n@objective(model, Min, sum(c[t,j] * x[t,j] for t in T, j in J));\nnothing #hide","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"We assign jobs to a type of machine and we define one knapsack constraint for each type. This formulation cannot be solved as it stands with a commercial solver.","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"Then, we decompose and specify the multiplicity of each knapsack subproblem :","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"@dantzig_wolfe_decomposition(model, dec_on_types, T);\nsps = getsubproblems(dec_on_types)\nfor t in T\n    specify!(sps[t], lower_multiplicity = 0, upper_multiplicity = U[t]);\nend\ngetsubproblems(dec_on_types)","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"We see that subproblem for machine type 1 has an upper multiplicity equals to 3, and the second subproblem for machine type 2 has an upper multiplicity equals to 2. It means that we can use at most 3 machines of type 1 and at most 2 machines of type 2.","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"We can then optimize","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"optimize!(model);\nnothing #hide","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"and retrieve the disaggregated solution","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"for t in T\n    assignment_patterns = BD.getsolutions(model, t);\n    for pattern in assignment_patterns\n        nb_times_pattern_used = BD.value(pattern);\n        jobs_in_pattern = [];\n        for j in J\n            if BD.value(pattern, x[t, j]) ≈ 1\n                push!(jobs_in_pattern, j);\n            end\n        end\n        println(\"Pattern of machine type $t used $nb_times_pattern_used times : $jobs_in_pattern\");\n    end\nend","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/identical_sp/","page":"Identical subproblems","title":"Identical subproblems","text":"","category":"page"},{"location":"qa/#Question-and-Answer","page":"Q&A","title":"Question & Answer","text":"","category":"section"},{"location":"qa/#Default-algorithms-of-Coluna-do-not-beat-the-commercial-solver-I-usually-use.-Is-it-normal-?","page":"Q&A","title":"Default algorithms of Coluna do not beat the commercial solver I usually use. Is it normal ?","text":"","category":"section"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Yes it is.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Solvers such as Gurobi, Cplex ... are handy powerful black-box tools.  They can run a very efficient presolve step to simplify the formulation, automatically apply lots of valid inequalities (such as MIR or cover cuts),  choose good branching strategies, or also run heuristics. However, when your formulation reaches a certain size, commercial solvers may run for hours without finding anything. This is the point where you may want to decompose your formulation.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"Coluna is a framework, not a solver. It provides algorithms to try column generation on your problem very easily. Then, you can devise your own branch-cut-and-price algorithm on top of Coluna's algorithms. to scale up and hopefully beats the commercial solver.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"To start customizing Coluna for your own problem,  you can separate valid inequalities  or call your own algorithm that optimizes subproblems.","category":"page"},{"location":"qa/#I'm-using-Gurobi-as-a-subsolver","page":"Q&A","title":"I'm using Gurobi as a subsolver","text":"","category":"section"},{"location":"qa/#My-license-prevents-me-from-running-several-environments-at-the-same-time.-How-can-I-use-a-single-environment-for-the-master-and-all-subproblems?","page":"Q&A","title":"My license prevents me from running several environments at the same time. How can I use a single environment for the master and all subproblems?","text":"","category":"section"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"You can use the Gurobi.Env constructor to create a single environment and pass it to the optimizers.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"const GRB_ENV = Gurobi.Env()\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default branch-cut-and-price\n    ),\n    \"default_optimizer\" => () -> Gurobi.Optimizer(GRB_ENV)\n);","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"If you get a Gurobi error 10002, you should wrap the Gurobi environment as a reference to initialize it during runtime instead of compile time (reference).","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"const GRB_ENV_REF = Ref{Gurobi.Env}()\n\nfunction __init__()\n    GRB_ENV_REF[] = Gurobi.Env()\n    return nothing\nend\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default branch-cut-and-price\n    ),\n    \"default_optimizer\" => () -> Gurobi.Optimizer(GRB_ENV_REF[])\n);","category":"page"},{"location":"qa/#How-to-disable-all-outputs-from-Gurobi?","page":"Q&A","title":"How to disable all outputs from Gurobi?","text":"","category":"section"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"You can refer to the following article from Gurobi's knowledge base.","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"We confirm that adding the following entry in the gurobi.env file works with Gurobi 10+:","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"LogToConsole 0","category":"page"},{"location":"qa/","page":"Q&A","title":"Q&A","text":"","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"EditURL = \"cuts.jl\"","category":"page"},{"location":"start/cuts/#tuto_cut_callback","page":"Cut Generation","title":"Valid inequalities","text":"","category":"section"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"Now let us consider a variant of the Generalized Assignment Problem in which we have to pay f[m] to use machine m.","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"Consider the following instance:","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"J = 1:10\nM = 1:5\nc = [10.13 15.6 15.54 13.41 17.08;19.58 16.83 10.75 15.8 14.89;14.23 17.36 16.05 14.49 18.96;16.47 16.38 18.14 15.46 11.64;17.87 18.25 13.12 19.16 16.33;11.09 16.76 15.5 12.08 13.06;15.19 13.86 16.08 19.47 15.79;10.79 18.96 16.11 19.78 15.55;12.03 19.03 16.01 14.46 12.77;14.48 11.75 16.97 19.95 18.32];\nw = [5, 4, 5, 6, 8, 9, 5, 8, 10, 7];\nQ = [25,  24,  31,  28,  24];\nf = [105, 103, 109, 112, 100];\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"We define the dependencies:","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"using JuMP, BlockDecomposition, Coluna, GLPK;\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"We parametrize the solver. We solve only the root node of the branch-and-bound tree and we use a column and cut generation algorithm to conquer (optimize) this node.","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"coluna = JuMP.optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm(\n            conqueralg = Coluna.Algorithm.ColCutGenConquer(\n                max_nb_cut_rounds = 20\n            ),\n            branchingtreefile = \"tree2.dot\",\n            maxnumnodes = 1\n        )\n    ),\n    \"default_optimizer\" => GLPK.Optimizer\n);\nnothing #hide","category":"page"},{"location":"start/cuts/#Column-generation","page":"Cut Generation","title":"Column generation","text":"","category":"section"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"We write the model:","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"model = BlockModel(coluna; direct_model = true);\n@axis(M_axis, M)\n@variable(model, x[j in J, m in M_axis], Bin);\n@variable(model, y[m in M_axis], Bin);\n@constraint(model, setpartitioning[j in J], sum(x[j,m] for m in M_axis) == 1);\n@constraint(model, knp[m in M_axis], sum(w[j]*x[j,m] for j in J) <= Q[m] * y[m]);\n@objective(model, Min, sum(c[j,m] * x[j,m] for m in M_axis, j in J) + sum(f[m] * y[m] for m in M_axis));\n\n@dantzig_wolfe_decomposition(model, dec, M_axis);\nsp = getsubproblems(dec);\nspecify!.(sp, lower_multiplicity = 0);\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"We optimize:","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"optimize!(model)","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"The final dual bound is:","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"db1 = objective_bound(model)","category":"page"},{"location":"start/cuts/#Strengthen-with-valid-inequalities","page":"Cut Generation","title":"Strengthen with valid inequalities","text":"","category":"section"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"Let H be the set of configurations of open machines (h[m] = 1 if machine m open; 0 otherwise) such that all jobs can be assigned : sum(h'Q) >= sum(w) i.e. the total capacity of the open machines must exceed the total weight of the jobs.","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"H = Vector{Int}[]\nfor h in digits.(1:(2^length(M) - 1), base=2, pad=length(M))\n    if sum(h'Q) >= sum(w)\n        push!(H, h)\n    end\nend\nH","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"Let ȳ be the solution to the linear relaxation of the problem. Let us try to express ȳ as a linear expression of the configurations. If ȳ ∈ conv H, we can derive a cut because the optimal integer solution to the problem uses one of the configurations of H.","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"We need MathOptInterface to define the cut callback:","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"using MathOptInterface","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"The separation algorithm looks for the non-negative coefficients χ[k], k = 1:length(H),  : max sum(χ[k] for k in 1:length(H)) such that sum(χ[k]* h for (k,h) in enumerate(H)) <= ̄ȳ. If the objective value is less than 1, we must add a cut.","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"Since the separation algorithm is a linear program, strong duality applies. So we separate these cuts with the dual.","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"fc_sep_m = Model(GLPK.Optimizer)\n@variable(fc_sep_m, ψ[m in M] >= 0) # one variable for each constraint\n@constraint(fc_sep_m, config_dual[h in H], ψ'h >= 1) # one constraint for each χ[k]\nMathOptInterface.set(fc_sep_m, MathOptInterface.Silent(), true)","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"The objective is min ȳ'ψ = sum(χ[k] for k in 1:length(H)). Let ψ* be an optimal solution to the dual. If ȳ'ψ* < 1, then ψ*'y >= 1 is a valid inequality.","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"function fenchel_cuts_separation(cbdata)\n    println(\"Fenchel cuts separation callback...\")\n    ȳ = [callback_value(cbdata, y[m]) for m in M_axis]\n    @objective(fc_sep_m, Min, ȳ'ψ) # update objective\n    optimize!(fc_sep_m)\n    if objective_value(fc_sep_m) < 1\n        con = @build_constraint(value.(ψ)'y >= 1) # valid inequality.\n        MathOptInterface.submit(model, MathOptInterface.UserCut(cbdata), con)\n    end\nend\n\nMathOptInterface.set(model, MathOptInterface.UserCutCallback(), fenchel_cuts_separation);\nnothing #hide","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"We optimize:","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"optimize!(model)","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"Valid inequalities significantly improve the previous dual bound:","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"db2 = objective_bound(model)\n\n\ndb2","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/cuts/","page":"Cut Generation","title":"Cut Generation","text":"","category":"page"},{"location":"man/config/#Coluna-Configuration","page":"Configuration","title":"Coluna Configuration","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#Raw-Parameters","page":"Configuration","title":"Raw Parameters","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#params","page":"Configuration","title":"params","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = Coluna","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"Params","category":"page"},{"location":"man/config/#Coluna.Params","page":"Configuration","title":"Coluna.Params","text":"Coluna.Params(\n    solver = Coluna.Algorithm.TreeSearchAlgorithm(),\n    global_art_var_cost = 10e6,\n    local_art_var_cost = 10e4\n)\n\nParameters of Coluna :\n\nsolver is the algorithm used to optimize the reformulation.\nglobal_art_var_cost is the cost of the global artificial variables in the master\nlocal_art_var_cost is the cost of the local artificial variables in the master\n\n\n\n\n\n","category":"type"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = nothing","category":"page"},{"location":"man/config/#default_optimizer","page":"Configuration","title":"default_optimizer","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/#Other-Supported-Parameters","page":"Configuration","title":"Other Supported Parameters","text":"","category":"section"},{"location":"man/config/#From-BlockDecomposition","page":"Configuration","title":"From BlockDecomposition","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = BlockDecomposition","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"objectiveprimalbound!\nobjectivedualbound!","category":"page"},{"location":"man/config/#BlockDecomposition.objectiveprimalbound!","page":"Configuration","title":"BlockDecomposition.objectiveprimalbound!","text":"objectiveprimalbound!(model, pb)\n\nDefine a primal bound on the optimal objective value  (upper bound for a minimisation, lower bound for a maximisation).\n\n\n\n\n\n","category":"function"},{"location":"man/config/#BlockDecomposition.objectivedualbound!","page":"Configuration","title":"BlockDecomposition.objectivedualbound!","text":"objectivedualbound!(model, db)\n\nDefine a dual bound on the optimal objective value. (lower bound for a minimisation, upper bound for a maximisation)\n\n\n\n\n\n","category":"function"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = nothing","category":"page"},{"location":"man/config/#From-MathOptInterface","page":"Configuration","title":"From MathOptInterface","text":"","category":"section"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"todo","category":"page"},{"location":"man/config/","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"EditURL = \"custom_data.jl\"","category":"page"},{"location":"start/custom_data/#tuto_custom_data","page":"Custom data","title":"Custom Variables and Cuts","text":"","category":"section"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"Coluna allows users to attach custom data to variables and constraints. This data is useful to store information about the variables or constraints in a custom format much easier to process than extracted information from the formulation (coefficient matrix, bounds, costs, and right-hand side).","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"In this example, we will show how to attach custom data to variables and constraints and use them to separate non-robust cuts. We will use the Bin Packing problem as an example.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"Let us consider a Bin Packing problem with only 3 items such that any pair of items fits into one bin but the 3 items do not. The objective function is to minimize the number of bins being used. Pricing is done by inspection over the 6 combinations of items (3 pairs and 3 singletons). The master LP solution has 1.5 bins at the root node, each 0.5 corresponding to a bin with one of the possible pairs of items.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"In this example, we will show you how to use non-robust cuts to improve the master LP solution at the root node. Obviously, Coluna is able to solve this instance by branching on the number of bins but the limit one on the number of nodes prevents it to be solved without cuts.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We define the dependencies:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"using JuMP, BlockDecomposition, Coluna, GLPK;\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We define the solver.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"coluna = JuMP.optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"default_optimizer\" => GLPK.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm(\n            conqueralg = Coluna.Algorithm.ColCutGenConquer(\n                colgen = Coluna.Algorithm.ColumnGeneration(\n                            pricing_prob_solve_alg = Coluna.Algorithm.SolveIpForm(\n                                optimizer_id = 1\n                            ))\n            ),\n            maxnumnodes = 1 # we only treat the root node.\n        )\n    )\n);\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"Let's define the model. Let's B the set of bins and I the set of items. We introduce variable y_b that is equal to 1 if a bin b is used and 0 otherwise. We introduce variable x_bi that is equal to 1 if item i is put in a bin b and 0 otherwise.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"model = BlockModel(coluna);\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We must assign three items:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"I = [1, 2, 3];\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"And we have three bins:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"B = [1, 2, 3];\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"Each bin is defining a subproblem, we declare our axis:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"@axis(axis, collect(B));\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We declare subproblem variables y[b]:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"@variable(model, y[b in axis], Bin);\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"And x[b,i]:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"@variable(model, x[b in axis, i in I], Bin);\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"Each item must be assigned to one bin:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"@constraint(model, sp[i in I], sum(x[b,i] for b in axis) == 1);\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We minimize the number of bins and we declare the decomposition:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"@objective(model, Min, sum(y[b] for b in axis))\n@dantzig_wolfe_decomposition(model, dec, axis);\nnothing #hide","category":"page"},{"location":"start/custom_data/#Custom-data-for-non-robust-cuts","page":"Custom data","title":"Custom data for non-robust cuts","text":"","category":"section"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"As said previously, at the end of the column generation at the root node, the master LP solution has 1.5 bins. It corresponds to three bins, each of them used 0.5 times containing one pair (1,2), (1, 3), or (2, 3) of items. We are going to introduce the following non-robust cut to make the master LP solution integral:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"sumlimits_s in Siflength(s) geq 2 λ_s leq 1","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"where :","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"S is the set of possible bin assignments generated by the pricing problem.\nlength(s) the number of items in bin assignment s in S.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"This cut means that we cannot have more than one bin with at least two items.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"But the problem is that the cut is expressed over the master column and we don't have access to these variables from the JuMP model. To address this problem, Coluna offers a way to compute the coefficient of a column in a constraint by implementing the following method:","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":" Coluna.MathProg.computecoeff","category":"page"},{"location":"start/custom_data/#Coluna.MathProg.computecoeff","page":"Custom data","title":"Coluna.MathProg.computecoeff","text":"computecoeff(var_custom_data, constr_custom_data) -> Float64\n\nDispatches on the type of custom data attached to the variable and the constraint to compute the coefficient of the variable in the constraint.\n\n\n\n\n\n","category":"function"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We therefore need to attach custom data to the master columns and the non-robust cut to use the method compute_coeff.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"For every subproblem solution s, we define custom data with the number of items in the bin.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"struct MyCustomVarData <: BlockDecomposition.AbstractCustomData\n    nb_items::Int\nend\nBlockDecomposition.customvars!(model, MyCustomVarData);\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We define custom data for the cut that will contain the minimum number of items in a bin that can be used. The value will be 2 in this example.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"struct MyCustomCutData <: BlockDecomposition.AbstractCustomData\n    min_items::Int\nend\nBlockDecomposition.customconstrs!(model, MyCustomCutData);\nnothing #hide","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We implement the computecoeff method for the custom data we defined.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"function Coluna.MathProg.computecoeff(\n    var_custom_data::MyCustomVarData, constr_custom_data::MyCustomCutData\n)\n    return (var_custom_data.nb_items >= constr_custom_data.min_items) ? 1.0 : 0.0\nend","category":"page"},{"location":"start/custom_data/#Pricing-callback","page":"Custom data","title":"Pricing callback","text":"","category":"section"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We define the pricing callback that will generate the bin with best-reduced cost. Be careful, when using non-robust cuts, you must take into account the contribution of the non-robust cuts to the reduced cost of your solution.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"function my_pricing_callback(cbdata)\n    # Get the reduced costs of the original variables.\n    I = [1, 2, 3]\n    b = BlockDecomposition.callback_spid(cbdata, model)\n\n    rc_y = BlockDecomposition.callback_reduced_cost(cbdata, y[b])\n    rc_x = [BlockDecomposition.callback_reduced_cost(cbdata, x[b, i]) for i in I]\n\n    # Get the dual values of the custom cuts (to calculate contributions of\n    # non-robust cuts to the cost of the solution).\n    custduals = Tuple{Int, Float64}[]\n    for (_, constr) in Coluna.MathProg.getconstrs(cbdata.form.parent_formulation)\n        if typeof(constr.custom_data) == MyCustomCutData\n            push!(custduals, (\n                constr.custom_data.min_items,\n                Coluna.MathProg.getcurincval(cbdata.form.parent_formulation, constr)\n            ))\n        end\n    end\n\n    # Pricing by inspection.\n    sols = [[1], [2], [3], [1, 2], [1, 3], [2, 3]]\n    best_s = Int[]\n    best_rc = Inf\n    for s in sols\n        rc_s = rc_y + sum(rc_x[i] for i in s) # reduced cost of the subproblem variables\n        if !isempty(custduals)\n            # contribution of the non-robust cuts\n            rc_s -= sum((length(s) >= minits) ? dual : 0.0 for (minits, dual) in custduals)\n        end\n        if rc_s < best_rc\n            best_rc = rc_s\n            best_s = s\n        end\n    end\n    @show best_s\n    # build the best one and submit\n    solcost = best_rc\n    solvars = JuMP.VariableRef[]\n    solvarvals = Float64[]\n    for i in best_s\n        push!(solvars, x[b, i])\n        push!(solvarvals, 1.0)\n    end\n    push!(solvars, y[b])\n    push!(solvarvals, 1.0)\n    # submit the solution\n    MOI.submit(\n        model, BlockDecomposition.PricingSolution(cbdata),\n        solcost,\n        solvars,\n        solvarvals,\n        MyCustomVarData(length(best_s)) # attach a custom data to the column\n    )\n\n    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), solcost)\n    return\nend","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"The pricing callback is done, we define it as the solver of our pricing problem.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"subproblems = BlockDecomposition.getsubproblems(dec)\nBlockDecomposition.specify!.(\n    subproblems,\n    solver = my_pricing_callback\n);\nnothing #hide","category":"page"},{"location":"start/custom_data/#Non-robust-cut-separation-callback.","page":"Custom data","title":"Non-robust cut separation callback.","text":"","category":"section"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We now define the cut separation callback for our non-robust cut. This is the same callback as the one used for robust cuts. There is just one slight difference when you submit the non-robust cut. Since cuts are expressed over the master variables and these variables are inaccessible from the JuMP model, you'll submit a constraint with an empty left-hand side and you'll leave Coluna populate the left-hand side with the values returned by Coluna.MathProg.computecoeff.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"So let's define the callback. Basically, if the solution uses more than one bin with two items, The cut is added to the model.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"function custom_cut_sep(cbdata)\n    # Compute the constraint violation by iterating over the master solution.\n    viol = -1.0\n    for (varid, varval) in cbdata.orig_sol\n        var = Coluna.MathProg.getvar(cbdata.form, varid)\n        if !isnothing(var.custom_data)\n            if var.custom_data.nb_items >= 2\n                viol += varval\n            end\n        end\n    end\n    # Add the cut (at most one variable with 2 or more of the 3 items) if violated.\n    if viol > 0.001\n        MOI.submit(\n            model, MOI.UserCut(cbdata),\n            JuMP.ScalarConstraint(\n                JuMP.AffExpr(0.0), # We cannot express the left-hand side so we push 0.\n                MOI.LessThan(1.0)\n            ),\n            MyCustomCutData(2) # Cut custom data.\n        )\n    end\n    return\nend\n\nMOI.set(model, MOI.UserCutCallback(), custom_cut_sep)\nJuMP.optimize!(model)","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"We see on the output that the algorithm has converged a first time before a cut is added. Coluna then starts a new iteration taking into account the cut. We notice here an improvement of the value of the dual bound: before the cut, we converge towards 1.5. After the cut, we reach 2.0.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/custom_data/","page":"Custom data","title":"Custom data","text":"","category":"page"},{"location":"api/algorithm/#Algorithm-API","page":"Algorithm API","title":"Algorithm API","text":"","category":"section"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"danger: Danger\nThis is WIP. The API will change in future releases.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"An algorithm is a procedure that given a model and and input performs some operations and  returns an output.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"run!","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"Parameters of an algorithm may contain its child algorithms which used by it. Therefore,  the algoirthm tree is formed, in which the root is the algorithm called to solver the model  (root algorithm should be an optimization algorithm, see below). ","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"TODO: explain why the parent algorithm must manage the records/storages of child algorithm.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"Algorithms are divided into two types : \"manager algorithms\" and \"worker algorithms\".  Worker algorithms just continue the calculation. They do not store and restore units  as they suppose it is done by their master algorithms. Manager algorithms may divide  the calculation flow into parts. Therefore, they store and restore units to make sure  that their child worker algorithms have units prepared.  A worker algorithm cannot have child manager algorithms. ","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"Examples of manager algorithms : TreeSearchAlgorithm (which covers both BCP algorithm and  diving algorithm), conquer algorithms, strong branching, branching rule algorithms  (which create child nodes). Examples of worker algorithms : column generation, SolveIpForm,  SolveLpForm, cut separation, pricing algorithms, etc.","category":"page"},{"location":"api/algorithm/#Optimization-algorithms","page":"Algorithm API","title":"Optimization algorithms","text":"","category":"section"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"Optimization algorithms return an OptimizationState.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"OptimizationState","category":"page"},{"location":"api/algorithm/#Conventions","page":"Algorithm API","title":"Conventions","text":"","category":"section"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"TODO: WIP","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"infeasible: infinite bounds, no solution, infeasible termination status.","category":"page"},{"location":"api/algorithm/","page":"Algorithm API","title":"Algorithm API","text":"","category":"page"},{"location":"api/treesearch/#Tree-search-API","page":"TreeSearch","title":"Tree search API","text":"","category":"section"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"danger: Danger\nUpdate needed.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Now, we define the two concepts we'll use in the tree search algorithms: the node and the search space. The third concept is the explore strategy and implemented in Coluna.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Every tree search algorithm must be associated to a search space.","category":"page"},{"location":"api/treesearch/#Implementing-tree-search-interface","page":"TreeSearch","title":"Implementing tree search interface","text":"","category":"section"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"First, we indicate the type of search space used by our algorithms. Note that the type of the search space can depends on the configuration of the algorithm. So there is a 1-to-n relation between tree search algorithm configurations and search space. because one search space can be used by several tree search algorithms configuration.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Now, we implement the method that calls the constructor of a search space. The type of the search space is known from above method. A search space may receive information from the tree-search algorithm. The model, and input arguments are the same than those received by the tree search algorithm.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"We implement the method that returns the root node. The definition of the root node depends on the search space.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Then, we implement the method that converts the branching rules into nodes for the tree search algorithm.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"We implement the node_change method to update the search space called by the tree search algorithm just after it finishes to evaluate a node and chooses the next one. Be careful, this method is not called after the evaluation of a node when there is no more unevaluated nodes (i.e. tree exploration is finished).","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"There are two ways to store the state of a formulation at a given node. We can distribute information across the nodes or store the whole state at each node. We follow the second way (so we don't need previous).","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Method after_conquer is a callback to do some operations after the conquer of a node and before the divide. Here, we update the best solution found after the conquer algorithm. We implement one method for each search space.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"We implement getters to retrieve the input from the search space and the node. The input is passed to the conquer and the divide algorithms.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"At last, we implement methods that will return the output of the tree search algorithms. We return the cost of the best solution found. We write one method for each search space.","category":"page"},{"location":"api/treesearch/#API","page":"TreeSearch","title":"API","text":"","category":"section"},{"location":"api/treesearch/#Search-space","page":"TreeSearch","title":"Search space","text":"","category":"section"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Coluna.TreeSearch.AbstractSearchSpace\nColuna.TreeSearch.search_space_type\nColuna.TreeSearch.new_space","category":"page"},{"location":"api/treesearch/#Coluna.TreeSearch.AbstractSearchSpace","page":"TreeSearch","title":"Coluna.TreeSearch.AbstractSearchSpace","text":"Contains the definition of the problem tackled by the tree search algorithm and how the nodes and transitions of the tree search space will be explored.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.TreeSearch.search_space_type","page":"TreeSearch","title":"Coluna.TreeSearch.search_space_type","text":"Returns the type of search space depending on the tree-search algorithm and its parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.TreeSearch.new_space","page":"TreeSearch","title":"Coluna.TreeSearch.new_space","text":"Creates and returns the search space of a tree search algorithm, its model, and its input.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Node","page":"TreeSearch","title":"Node","text":"","category":"section"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Coluna.TreeSearch.AbstractNode\nColuna.TreeSearch.new_root\nColuna.TreeSearch.get_parent\nColuna.TreeSearch.get_priority","category":"page"},{"location":"api/treesearch/#Coluna.TreeSearch.AbstractNode","page":"TreeSearch","title":"Coluna.TreeSearch.AbstractNode","text":"A subspace obtained by successive divisions of the search space.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.TreeSearch.new_root","page":"TreeSearch","title":"Coluna.TreeSearch.new_root","text":"Creates and returns the root node of a search space.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.TreeSearch.get_parent","page":"TreeSearch","title":"Coluna.TreeSearch.get_parent","text":"Returns the parent of a node; nothing if the node is the root.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.TreeSearch.get_priority","page":"TreeSearch","title":"Coluna.TreeSearch.get_priority","text":"Returns the priority of the node depending on the explore strategy.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Additional methods needed for Coluna's algorithms:","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Coluna.TreeSearch.get_opt_state\nColuna.TreeSearch.get_records\nColuna.TreeSearch.get_branch_description\nColuna.TreeSearch.isroot","category":"page"},{"location":"api/treesearch/#Coluna.TreeSearch.get_branch_description","page":"TreeSearch","title":"Coluna.TreeSearch.get_branch_description","text":"Returns a String to display the branching constraint.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.TreeSearch.isroot","page":"TreeSearch","title":"Coluna.TreeSearch.isroot","text":"Returns true is the node is root; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Tree-search-algorithm","page":"TreeSearch","title":"Tree search algorithm","text":"","category":"section"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Coluna.TreeSearch.AbstractExploreStrategy\nColuna.TreeSearch.tree_search\nColuna.TreeSearch.children\nColuna.TreeSearch.stop\nColuna.TreeSearch.tree_search_output","category":"page"},{"location":"api/treesearch/#Coluna.TreeSearch.AbstractExploreStrategy","page":"TreeSearch","title":"Coluna.TreeSearch.AbstractExploreStrategy","text":"Algorithm that chooses next node to evaluated in the tree search algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/#Coluna.TreeSearch.tree_search","page":"TreeSearch","title":"Coluna.TreeSearch.tree_search","text":"Generic implementation of the tree search algorithm for a given explore strategy.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.TreeSearch.children","page":"TreeSearch","title":"Coluna.TreeSearch.children","text":"Evaluate and generate children. This method has a specific implementation for Coluna.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.TreeSearch.stop","page":"TreeSearch","title":"Coluna.TreeSearch.stop","text":"Returns true if stopping criteria are met; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.TreeSearch.tree_search_output","page":"TreeSearch","title":"Coluna.TreeSearch.tree_search_output","text":"Returns the output of the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Tree-search-algorithm-for-Coluna","page":"TreeSearch","title":"Tree search algorithm for Coluna","text":"","category":"section"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Coluna.Algorithm.AbstractColunaSearchSpace","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.AbstractColunaSearchSpace","page":"TreeSearch","title":"Coluna.Algorithm.AbstractColunaSearchSpace","text":"Search space for tree search algorithms in Coluna.\n\n\n\n\n\n","category":"type"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"The children method has a specific implementation for AbstractColunaSearchSpace` that involves following methods:","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"Coluna.Algorithm.get_previous\nColuna.Algorithm.set_previous!\nColuna.Algorithm.node_change!\nColuna.Algorithm.get_divide\nColuna.Algorithm.get_reformulation\nColuna.Algorithm.get_input\nColuna.Algorithm.after_conquer!\nColuna.Algorithm.new_children","category":"page"},{"location":"api/treesearch/#Coluna.Algorithm.get_previous","page":"TreeSearch","title":"Coluna.Algorithm.get_previous","text":"Returns the previous node explored by the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.set_previous!","page":"TreeSearch","title":"Coluna.Algorithm.set_previous!","text":"Sets the previous node explored by the tree search algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.node_change!","page":"TreeSearch","title":"Coluna.Algorithm.node_change!","text":"Methods to perform operations before the tree search algorithm evaluates a node (current). This is useful to restore the state of the formulation for instance.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_divide","page":"TreeSearch","title":"Coluna.Algorithm.get_divide","text":"Returns the divide algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_reformulation","page":"TreeSearch","title":"Coluna.Algorithm.get_reformulation","text":"Returns the reformulation that will be passed to an algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.get_input","page":"TreeSearch","title":"Coluna.Algorithm.get_input","text":"Returns the input that will be passed to an algorithm. The input can be built from information contained in a search space and a node.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.after_conquer!","page":"TreeSearch","title":"Coluna.Algorithm.after_conquer!","text":"Methods to perform operations after the conquer algorithms. It receives the output of the conquer algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/#Coluna.Algorithm.new_children","page":"TreeSearch","title":"Coluna.Algorithm.new_children","text":"Creates and returns the children of a node associated to a search space.\n\n\n\n\n\n","category":"function"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/treesearch/","page":"TreeSearch","title":"TreeSearch","text":"","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"EditURL = \"pricing.jl\"","category":"page"},{"location":"start/pricing/#tuto_pricing_callback","page":"Pricing callback","title":"Pricing callback","text":"","category":"section"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback lets you define how to solve the subproblems of a Dantzig-Wolfe decomposition to generate a new entering column in the master program. This callback is useful when you know an efficient algorithm to solve the subproblems, i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"First, we load the packages and define aliases :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"using Coluna, BlockDecomposition, JuMP, MathOptInterface, GLPK;\nconst BD = BlockDecomposition;\nconst MOI = MathOptInterface;\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"Let us see an example with the following generalized assignment problem :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"M = 1:3;\nJ = 1:15;\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5; 19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7; 13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2];\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91;91 81 66 63 59 81 87 90 65 55 57 68 92 91 86; 62 79 73 60 75 66 68 99 69 60 56 100 67 68 54];\nQ = [1020 1460 1530];\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"with the following Coluna configuration","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"for which the JuMP model takes the form:","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"model = BlockModel(coluna);\n\n@axis(M_axis, M);\n\n@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m,j] for m in M_axis) == 1);\n@objective(model, Min, sum(c[m,j]*x[m,j] for m in M_axis, j in J));\n@dantzig_wolfe_decomposition(model, dwdec, M_axis);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"where, as you can see, we omitted the knapsack constraints. These constraints are implicitly defined by the algorithm called in the pricing callback.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"Let's use a knapsack algorithm defined by the following function to solve the knapsack subproblems:","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"function solve_knapsack(cost, weight, capacity)\n    sp_model = Model(GLPK.Optimizer)\n    items = 1:length(weight)\n    @variable(sp_model, x[i in items], Bin)\n    @constraint(sp_model, weight' * x <= capacity)\n    @objective(sp_model, Min, cost' * x)\n    optimize!(sp_model)\n    x_val = value.(x)\n    return filter(i -> x_val[i] ≈ 1, collect(items))\nend","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"You can replace the content of the function with any algorithm that solves the knapsack problem (such as algorithms provided by the unregistered package Knapsacks).","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with Coluna within the pricing callback.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"function my_pricing_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M_axis)\n    cur_machine = BD.callback_spid(cbdata, model)\n\n    # Uncomment to see that the pricing callback is called.\n    # println(\"Pricing callback for machine $(cur_machine).\")\n\n    # Retrieve reduced costs of subproblem variables\n    red_costs = [BD.callback_reduced_cost(cbdata, x[cur_machine, j]) for j in J]\n\n    # Run the knapsack algorithm\n    jobs_assigned_to_cur_machine = solve_knapsack(red_costs, w[cur_machine, :], Q[cur_machine])\n\n    # Create the solution (send only variables with non-zero values)\n    sol_vars = [x[cur_machine, j] for j in jobs_assigned_to_cur_machine]\n    sol_vals = [1.0 for _ in jobs_assigned_to_cur_machine]\n    sol_cost = sum(red_costs[j] for j in jobs_assigned_to_cur_machine)\n\n    # Submit the solution to the subproblem to Coluna\n    MOI.submit(model, BD.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)\n\n    # Submit the dual bound to the solution of the subproblem\n    # This bound is used to compute the contribution of the subproblem to the lagrangian\n    # bound in column generation.\n    MOI.submit(model, BD.PricingDualBound(cbdata), sol_cost) # optimal solution\n    return\nend","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"The pricing callback is provided to Coluna using the keyword solver in the method specify!.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"subproblems = BD.getsubproblems(dwdec);\nBD.specify!.(subproblems, lower_multiplicity = 0, solver = my_pricing_callback);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"You can then optimize :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"optimize!(model);\nnothing #hide","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"and retrieve the information you need as usual :","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"objective_value(model)","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/pricing/","page":"Pricing callback","title":"Pricing callback","text":"","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"EditURL = \"initial_columns.jl\"","category":"page"},{"location":"start/initial_columns/#Initial-columns","page":"Initial columns callback","title":"Initial columns","text":"","category":"section"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"The initial columns callback let you provide initial columns associated to each problem ahead the optimization. This callback is useful when you have an efficient heuristic that finds feasible solutions to the problem. You can then extract columns from the solutions and give them to Coluna through the callback. You have to make sure the columns you provide are feasible because Coluna won't check their feasibility. The cost of the columns will be computed using the perennial cost of subproblem variables.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"Let us see an example with the following generalized assignment problem :","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"M = 1:3;\nJ = 1:5;\nc = [1 1 1 1 1; 1.2 1.2 1.1 1.1 1; 1.3 1.3 1.1 1.2 1.4];\nQ = [3, 2, 3];\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"with the following Coluna configuration","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"using JuMP, GLPK, BlockDecomposition, Coluna;\n\ncoluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default branch-cut-and-price\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"for which the JuMP model takes the form:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"@axis(M_axis, M);\nmodel = BlockModel(coluna);\n\n@variable(model, x[m in M_axis, j in J], Bin);\n@constraint(model, cov[j in J], sum(x[m, j] for m in M_axis) >= 1);\n@constraint(model, knp[m in M_axis], sum(x[m, j] for j in J) <= Q[m]);\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M_axis, j in J));\n\n@dantzig_wolfe_decomposition(model, decomposition, M_axis)\n\nsubproblems = getsubproblems(decomposition)\nspecify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"Let's consider that the following assignment patterns are good candidates:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"machine1 = [[1,2,4], [1,3,4], [2,3,4], [2,3,5]];\nmachine2 = [[1,2], [1,5], [2,5], [3,4]];\nmachine3 = [[1,2,3], [1,3,4], [1,3,5], [2,3,4]];\n\ninitial_columns = [machine1, machine2, machine3];\nnothing #hide","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"We can write the initial columns callback:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"function initial_columns_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M_axis)\n    spid = BlockDecomposition.callback_spid(cbdata, model)\n    println(\"initial columns callback $spid\")\n\n    # Retrieve assignment patterns of a given machine\n    for col in initial_columns[spid]\n        # Create the column in the good representation\n        vars = [x[spid, j] for j in col]\n        vals = [1.0 for _ in col]\n\n        # Submit the column\n        MOI.submit(model, BlockDecomposition.InitialColumn(cbdata), vars, vals)\n    end\nend","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"The initial columns callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with Coluna within the callback.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"We provide the initial columns callback to Coluna through the following method:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"MOI.set(model, BlockDecomposition.InitialColumnsCallback(), initial_columns_callback)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"You can then optimize:","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"optimize!(model)","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/initial_columns/","page":"Initial columns callback","title":"Initial columns callback","text":"","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"EditURL = \"advanced_demo.jl\"","category":"page"},{"location":"start/advanced_demo/#Advanced-tutorial-Location-Routing","page":"Column Generation and Benders on Location Routing","title":"Advanced tutorial - Location Routing","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We demonstrate the main features of Coluna on a variant of the Location Routing problem. In the Location Routing Problem, we are given a set of facilities and a set of customers. Each customer must be delivered by a route starting from one facility. Each facility has a setup cost, while the cost of a route is the distance traveled.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"A route is defined as a vector of locations that satisfies the following rules:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"it must start from an open facility location\nit can finish at any customer (open route variant)\nits length is limited (the maximum number of visited locations is equal to a constant nb_positions)","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Our objective is to minimize the sum of fixed costs for opening facilities and the total traveled distance while ensuring that each customer is covered by a route.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"In this tutorial, we will show you how to solve this problem by applying:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"a direct approach with JuMP and a MILP solver (without Coluna)\na branch-and-price algorithm provided by Coluna, which uses a custom pricing callback to optimize pricing subproblems\na robust branch-cut-and-price algorithm, which separates valid inequalities on the original arc variables (so-called \"robust\" cuts)\na non-robust branch-cut-and-price algorithm, which separates valid inequalities on the route variables of the Dantzig-Wolfe reformulation (so-called \"non-robust\" cuts)\na multi-stage column generation algorithm using two different pricing solvers\na classic Benders decomposition approach, which uses the LP relaxation of the subproblem","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"For illustration purposes, we use a small instance with 2 facilities and 7 customers. The maximum length of a route is fixed to 4. We also provide a larger instance in the last section of the tutorial.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"nb_positions = 4\nfacilities_fixed_costs = [120, 150]\nfacilities = [1, 2]\ncustomers = [3, 4, 5, 6, 7, 8, 9]\narc_costs =\n    [\n        0.0 25.3 25.4 25.4 35.4 37.4 31.9 24.6 34.2;\n        25.3 0.0 21.2 16.2 27.1 26.8 17.8 16.7 23.2;\n        25.4 21.2 0.0 14.2 23.4 23.8 18.3 17.0 21.6;\n        25.4 16.2 14.2 0.0 28.6 28.8 22.6 15.6 29.5;\n        35.4 27.1 23.4 28.6 0.0 42.1 30.4 24.9 39.1;\n        37.4 26.8 23.8 28.8 42.1 0.0 32.4 29.5 38.2;\n        31.9 17.8 18.3 22.6 30.4 32.4 0.0 22.5 30.7;\n        24.6 16.7 17.0 15.6 24.9 29.5 22.5 0.0 21.4;\n        34.2 23.2 21.6 29.5 39.1 38.2 30.7 21.4 0.0;\n    ]\nlocations = vcat(facilities, customers)\nnb_customers = length(customers)\nnb_facilities = length(facilities)\npositions = 1:nb_positions;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"In this tutorial, we will use the following packages:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"using JuMP, HiGHS, GLPK, BlockDecomposition, Coluna;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We want to set an upper bound nb_routes_per_facility on the number of routes starting from a facility. This limit is computed as follows:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"# We compute the minimum number of routes needed to visit all customers:\nnb_routes = Int(ceil(nb_customers / nb_positions))\n# We define the upper bound `nb_routes_per_facility`:\nnb_routes_per_facility = min(Int(ceil(nb_routes / nb_facilities)) * 2, nb_routes)\nroutes_per_facility = 1:nb_routes_per_facility;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/#Direct-model","page":"Column Generation and Benders on Location Routing","title":"Direct model","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"First, we solve the problem by a direct approach, using the HiGHS solver. We start by creating a JuMP model:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"model = JuMP.Model(HiGHS.Optimizer);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We declare 3 types of binary variables:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"# y[j] equals 1 if facility j is open; 0 otherwise.\n@variable(model, y[j in facilities], Bin)\n\n# z[u,v] equals 1 if a vehicle travels from u to v; 0 otherwise\n@variable(model, z[u in locations, v in locations], Bin)\n\n# x[i,j,k,p] equals 1 if customer i is delivered from facility j at position p of route k; 0 otherwise\n@variable(model, x[i in customers, j in facilities, k in routes_per_facility, p in positions], Bin);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We define the constraints:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"# each customer is visited once\n@constraint(model, cov[i in customers],\n    sum(x[i, j, k, p] for j in facilities, k in routes_per_facility, p in positions) == 1)\n\n# a facility is open if there is a route starting from it\n@constraint(model, setup[j in facilities, k in routes_per_facility],\n    sum(x[i, j, k, 1] for i in customers) <= y[j])\n\n# flow conservation\n@constraint(model, flow_conservation[j in facilities, k in routes_per_facility, p in positions; p > 1],\n    sum(x[i, j, k, p] for i in customers) <= sum(x[i, j, k, p-1] for i in customers))\n\n# there is an arc between two customers whose demand is satisfied by the same route at consecutive positions\n@constraint(model, route_arc[i in customers, l in customers, j in facilities, k in routes_per_facility, p in positions; p > 1 && i != l],\n    z[i, l] >= x[l, j, k, p] + x[i, j, k, p-1] - 1)\n\n# there is an arc between facility `j` and the first customer visited by route `k` from facility `j`\n@constraint(model, start_arc[i in customers, j in facilities, k in routes_per_facility],\n    z[j, i] >= x[i, j, k, 1]);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We set the objective function:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"@objective(model, Min,\n    sum(arc_costs[u, v] * z[u, v] for u in locations, v in locations)\n    +\n    sum(facilities_fixed_costs[j] * y[j] for j in facilities));\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"and we optimize the model:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"optimize!(model)\nobjective_value(model)","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We find an optimal solution involving two routes starting from facility 1:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"1 -> 8 -> 9 -> 3 -> 6\n1 -> 4 -> 5 -> 7","category":"page"},{"location":"start/advanced_demo/#Dantzig-Wolfe-decomposition-and-Branch-and-Price","page":"Column Generation and Benders on Location Routing","title":"Dantzig-Wolfe decomposition and Branch-and-Price","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"One can solve the problem by exploiting its structure with a Dantzig-Wolfe decomposition approach. The subproblem induced by such decomposition amounts to generate routes starting from each facility. A possible decomposition is to consider a subproblem associated with each vehicle, generating the vehicle route. However, for a given facility, the vehicles that are identical will give rise to the same subproblem and route solutions. So instead of this decomposition with several identical subproblems for each facility, we define below a single subproblem per facility. For each subproblem, we define its multiplicity, i.e. we bound the number of solutions of this subproblem that can be used in a master solution.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"The following method creates the model according to the decomposition described:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function create_model(optimizer, pricing_algorithms)\n    # A user should resort to axes to communicate to Coluna how to decompose a formulation.\n    # For our problem, we declare an axis over the facilities, thus `facilities_axis` contain subproblem indices.\n    # We must use `facilities_axis` instead of `facilities` in the declaration of the\n    # variables and constraints that belong to pricing subproblems.\n    @axis(facilities_axis, collect(facilities))\n\n    # We declare a `BlockModel` instead of `Model`.\n    model = BlockModel(optimizer)\n\n    # `y[j]` is a master variable equal to 1 if the facility j is open; 0 otherwise\n    @variable(model, y[j in facilities], Bin)\n\n    # `x[i,j]` is a subproblem variable equal to 1 if customer i is delivered from facility j; 0 otherwise.\n    @variable(model, x[i in customers, j in facilities_axis], Bin)\n    # `z[u,v]` is assimilated to a subproblem variable equal to 1 if a vehicle travels from u to v; 0 otherwise.\n    # we don't use the `facilities_axis` axis here because the `z` variables are defined as\n    # representatives of the subproblem variables later in the model.\n    @variable(model, z[u in locations, v in locations], Bin)\n\n    # `cov` constraints are master constraints ensuring that each customer is visited once.\n    @constraint(model, cov[i in customers],\n        sum(x[i, j] for j in facilities) >= 1)\n\n    # `open_facilities` are master constraints ensuring that the depot is open if one vehicle\n    # leaves it.\n    @constraint(model, open_facility[j in facilities],\n        sum(z[j, i] for i in customers) <= y[j] * nb_routes_per_facility)\n\n    # We don't need to describe the subproblem constraints because we use a pricing callback.\n\n    # We set the objective function:\n    @objective(model, Min,\n        sum(arc_costs[u, v] * z[u, v] for u in locations, v in locations) +\n        sum(facilities_fixed_costs[j] * y[j] for j in facilities)\n    )\n\n    # We perform decomposition over the facilities.\n    @dantzig_wolfe_decomposition(model, dec, facilities_axis)\n\n    # Subproblems generate routes starting from each facility.\n    # The number of routes from each facility is at most `nb_routes_per_facility`.\n    subproblems = BlockDecomposition.getsubproblems(dec)\n    specify!.(subproblems, lower_multiplicity=0, upper_multiplicity=nb_routes_per_facility, solver=pricing_algorithms)\n\n    # We define `z` as a subproblem variable common to all subproblems.\n    # Each implicit variable `z` replaces a sum of explicit `z'` variables: `z[u,v] = sum(z'[j,u,v] for j in facilities_axis)`\n    # This way the model is simplified, and column generation is accelerated as the reduced cost for pair `z[u,v]` is calculated only once\n    # instead of performing the same reduced cost calculation for variables `z'[j,u,v]`, `j in facilities_axis`.\n    subproblemrepresentative.(z, Ref(subproblems))\n\n    return model, x, y, z, cov\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Contrary to the direct model, we do not add constraints to ensure the feasibility of the routes because we solve our subproblems in a pricing callback. The user who implements the pricing callback has the responsibility to create only feasible routes.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We setup Coluna:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver=Coluna.Algorithm.TreeSearchAlgorithm( ## default branch-and-bound of Coluna\n            maxnumnodes=100,\n            conqueralg=Coluna.ColCutGenConquer() ## default column and cut generation of Coluna\n        ) ## default branch-cut-and-price\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/#Pricing-callback","page":"Column Generation and Benders on Location Routing","title":"Pricing callback","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"If the user declares all the necessary subproblem constraints and possibly additional subproblem variables to describe the set of feasible subproblem solutions, Coluna may perform automatic Dantzig-Wolfe decomposition in which the pricing subproblems are solved by applying a (default) MIP solver. In our case, applying a MIP solver is not the most efficient way to solve the pricing problem. Therefore, we implement an ad-hoc algorithm for solving the pricing subproblems and declare it as a pricing callback. In our pricing callback for a given facility, we inspect all feasible routes enumerated before calling the branch-cut-and-price algorithm. The inspection algorithm calculates the reduced cost for each enumerated route and returns a route with the minimum reduced cost.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We first define a structure to store the routes:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"mutable struct Route\n    length::Int # record the length of the route (number of visited customers + 1)\n    path::Vector{Int} # record the sequence of visited customers\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We can reduce the number of enumerated routes by exploiting the following property. Consider two routes starting from the same facility and visiting the same subset of locations (customers). These two routes correspond to columns with the same vector of coefficients in master constraints. A solution containing the route with a larger traveled distance (i.e., larger route original cost) is dominated: this dominated route can be replaced by the other route without increasing the total solution cost. Therefore, for each subset of locations of a size not exceeding the maximum one, the enumeration procedure keeps only one route visiting this subset, the one with the smallest cost.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"A method that computes the cost of a route:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function route_original_cost(arc_costs, route::Route)\n    route_cost = 0.0\n    path = route.path\n    path_length = route.length\n    for i in 1:(path_length-1)\n        route_cost += arc_costs[path[i], path[i+1]]\n    end\n    return route_cost\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"This procedure finds a least-cost sequence of visiting the given set of customers starting from a given facility.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function best_visit_sequence(arc_costs, cust_subset, facility_id)\n    # generate all the possible visit orders\n    set_size = size(cust_subset)[1]\n    all_paths = collect(multiset_permutations(cust_subset, set_size))\n    all_routes = Vector{Route}()\n    for path in all_paths\n        # add the first index i.e. the facility id\n        enpath = vcat([facility_id], path)\n        # length of the route = 1 + number of visited customers\n        route = Route(set_size + 1, enpath)\n        push!(all_routes, route)\n    end\n    # compute each route original cost\n    routes_costs = map(r ->\n            (r, route_original_cost(arc_costs, r)), all_routes)\n    # keep only the best visit sequence\n    tmp = argmin([c for (_, c) in routes_costs])\n    (best_order, _) = routes_costs[tmp]\n    return best_order\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We are now able to compute a dominating route for all the possible customers' subsets, given a facility id:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"using Combinatorics\n\nfunction best_route_forall_cust_subsets(arc_costs, customers, facility_id, max_size)\n    best_routes = Vector{Route}()\n    all_subsets = Vector{Vector{Int}}()\n    for subset_size in 1:max_size\n        subsets = collect(combinations(customers, subset_size))\n        for s in subsets\n            push!(all_subsets, s)\n        end\n    end\n    for s in all_subsets\n        route_s = best_visit_sequence(arc_costs, s, facility_id)\n        push!(best_routes, route_s)\n    end\n    return best_routes\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We store all the information given by the enumeration phase in a dictionary. For each facility id, we match a vector of routes that are the best visiting sequences for each possible subset of customers.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"routes_per_facility = Dict(\n    j => best_route_forall_cust_subsets(arc_costs, customers, j, nb_positions) for j in facilities\n)","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Our pricing callback must compute the reduced cost of each route, given the reduced cost of the subproblem variables x and z. Remember that subproblem variables z are implicitly defined by master representative variables z. We remark that z variables participate only in the objective function. Thus their reduced costs are initially equal to the original costs (i.e., objective coefficients) This is not true anymore after adding branching constraints and robust cuts involving variables z.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We need methods to compute the contributions to the reduced cost of the x and z variables:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function x_contribution(route::Route, j::Int, x_red_costs)\n    x = 0.0\n    visited_customers = route.path[2:route.length]\n    for i in visited_customers\n        x += x_red_costs[\"x_$(i)_$(j)\"]\n    end\n    return x\nend;\n\nfunction z_contribution(route::Route, z_red_costs)\n    z = 0.0\n    for i in 1:(route.length-1)\n        current_position = route.path[i]\n        next_position = route.path[i+1]\n        z += z_red_costs[\"z_$(current_position)_$(next_position)\"]\n    end\n    return z\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We are now able to write our pricing callback:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function pricing_callback(cbdata)\n    # Get the id of the facility.\n    j = BlockDecomposition.indice(BlockDecomposition.callback_spid(cbdata, model))\n\n    # Retrieve variables reduced costs.\n    z_red_costs = Dict(\n        \"z_$(u)_$(v)\" => BlockDecomposition.callback_reduced_cost(cbdata, z[u, v]) for u in locations, v in locations)\n    x_red_costs = Dict(\n        \"x_$(i)_$(j)\" => BlockDecomposition.callback_reduced_cost(cbdata, x[i, j]) for i in customers\n    )\n\n    # Keep route with minimum reduced cost.\n    red_costs_j = map(r -> (\n            r,\n            x_contribution(r, j, x_red_costs) + z_contribution(r, z_red_costs) # the reduced cost of a route is the sum of the contribution of the variables\n        ), routes_per_facility[j]\n    )\n    min_index = argmin([x for (_, x) in red_costs_j])\n    (best_route, min_reduced_cost) = red_costs_j[min_index]\n\n    # Retrieve the route's arcs.\n    best_route_arcs = Vector{Tuple{Int,Int}}()\n    for i in 1:(best_route.length-1)\n        push!(best_route_arcs, (best_route.path[i], best_route.path[i+1]))\n    end\n    best_route_customers = best_route.path[2:best_route.length]\n\n    # Create the solution (send only variables with non-zero values).\n    z_vars = [z[u, v] for (u, v) in best_route_arcs]\n    x_vars = [x[i, j] for i in best_route_customers]\n    sol_vars = vcat(z_vars, x_vars)\n    sol_vals = ones(Float64, length(z_vars) + length(x_vars))\n    sol_cost = min_reduced_cost\n\n    # Submit the solution to the subproblem to Coluna.\n    MOI.submit(model, BlockDecomposition.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)\n\n    # Submit the dual bound to the solution of the subproblem.\n    # This bound is used to compute the contribution of the subproblem to the lagrangian\n    # bound in column generation.\n    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), sol_cost) ## optimal solution\n\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Create the model:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"model, x, y, z, _ = create_model(coluna, pricing_callback);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Solve:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"JuMP.optimize!(model)","category":"page"},{"location":"start/advanced_demo/#Strengthening-the-master-with-linear-valid-inequalities-on-the-original-variables-(so-called-\"robust\"-cuts)","page":"Column Generation and Benders on Location Routing","title":"Strengthening the master with linear valid inequalities on the original variables (so-called \"robust\" cuts)","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"To improve the quality of the linear relaxation, a family of classic facility location valid inequalities can be used:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"x_ij leq y_j forall i in I forall j in J","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"where I is the set of customers and J the set of facilities.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We declare a structure representing an inequality in this family:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"struct OpenFacilityInequality\n    facility_id::Int\n    customer_id::Int\nend","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"To identify violated valid inequalities from a current master LP solution, we proceed by enumeration (i.e. iterating over all pairs of customer and facility). Enumeration separation procedure is implemented in the following callback.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function valid_inequalities_callback(cbdata)\n    # Get variables valuations and store them in dictionaries.\n    x_vals = Dict(\n        \"x_$(i)_$(j)\" => BlockDecomposition.callback_value(cbdata, x[i, j]) for i in customers, j in facilities\n    )\n    y_vals = Dict(\n        \"y_$(j)\" => BlockDecomposition.callback_value(cbdata, y[j]) for j in facilities\n    )\n\n    # Separate the valid inequalities (i.e. retrieve the inequalities that are violated by\n    # the current solution) by enumeration.\n    inequalities = OpenFacilityInequality[]\n\n    for j in facilities\n        y_j = y_vals[\"y_$(j)\"]\n        for i in customers\n            x_i_j = x_vals[\"x_$(i)_$(j)\"]\n            if x_i_j > y_j\n                push!(inequalities, OpenFacilityInequality(j, i))\n            end\n        end\n    end\n\n    # Add the valid inequalities to the model.\n    for ineq in inequalities\n        constr = JuMP.@build_constraint(x[ineq.customer_id, ineq.facility_id] <= y[ineq.facility_id])\n        MOI.submit(model, MOI.UserCut(cbdata), constr)\n    end\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We re-declare the model and optimize it with these valid inequalities:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"model, x, y, z, _ = create_model(coluna, pricing_callback);\nMOI.set(model, MOI.UserCutCallback(), valid_inequalities_callback);\nJuMP.optimize!(model)","category":"page"},{"location":"start/advanced_demo/#Strengthening-the-master-with-valid-inequalities-on-the-column-generation-variables-(so-called-\"non-robust\"-cuts)","page":"Column Generation and Benders on Location Routing","title":"Strengthening the master with valid inequalities on the column generation variables (so-called \"non-robust\" cuts)","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"In order to further strengthen the linear relaxation of the Dantzig-Wolfe reformulation, we separate a family of subset-row cuts, which is a subfamily of Chvátal-Gomory rank-1 cuts (R1C), obtained from the set-partitioning constraints. These cuts cannot be expressed as a linear combination of the original variables of the model. Instead, they are expressed with the master columns variables λ_k, k in K, where K is the set of generated columns or set of solutions returned by the pricing subproblems. Subset-row cuts are \"non-robust\" in the sense that they modify the structure of the pricing subproblems, and not just the reduced cost of subproblem variables. Thus, the implementation of the pricing callback should be updated to take into account dual costs associated with non-robust cutting planes.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Each Chvátal-Gomory rank-1 cut is characterized by a subset of set-partitioning constraints, or equivalently by a subset C of customers, and a multiplier alpha_i for each customer iin C:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"sum_k in K lfloor sum_i in C alpha_i tildex^k_ij lambda_k rfloor leq lfloor sum_iin C alpha_i rfloor   C subseteq I","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"where tildex^k_ij is the value of the variable x_ij in the k-th column generated. For subset-row cuts, C=3, and alpha_i=frac12, iin C.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Since we obtain subset-row cuts based on set-partitioning constraints, we must be able to differentiate them from the other constraints of the model. To do this, we exploit a feature of Coluna that allows us to attach custom data to the constraints and variables of a model, via the add-ons of BlockDecomposition package.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"First, we create special custom data with the only information we need to characterize our cover constraints: the customer id that corresponds to this constraint.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"struct CoverConstrData <: BlockDecomposition.AbstractCustomData\n    customer::Int\nend","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We re-create the model:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"(model, x, y, z, cov) = create_model(coluna, pricing_callback);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We declare our custom data to Coluna and we attach one custom data to each cover constraint","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"BlockDecomposition.customconstrs!(model, CoverConstrData);\n\nfor i in customers\n    customdata!(cov[i], CoverConstrData(i))\nend","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We perform the separation by enumeration (i.e. iterating over all subsets of customers of size three).","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"The subset-row cut has the following form:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"sum_k in K tildealpha(C k) lambda_k leq 1 C subseteq I C = 3","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"where coefficient tildealpha(C k) equals 1 if route k visits at least two customers of C; 0 otherwise.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"For instance, if we consider separating a cut over constraints cov[3], cov[6] and cov[8], then the route 1->4->6->7 has a zero coefficient while the route 1->4->6->3 has a coefficient equal to one.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Since columns are generated dynamically, we cannot pre-compute the coefficients of columns in the subset-row cuts. Instead, coefficients are computed dynamically via a user-defined computecoeff method which takes a cut and a column as arguments. To recognize which cut and which column are passed to the method, custom data structures are attached to the cut constraints and the master variables. When a new column is generated, Coluna computes its coefficients in the original constraints and robust cuts using coefficients of subproblem variables in the master constraints. Coluna retrieves coefficients of the new column in the non-robust cuts by calling the computecoeff method for the column and each such cut. When a new non-robust cut is generated, Coluna retrieves the coefficients of columns in this cut by calling the computecoeff method for the cut and all existing columns.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We now proceed to the implementation of necessary data structures and methods needed to support the subset-row cuts. First, we attach a custom data structure to master columns λ_k associated with a given route k. They record the set of customers that are visited by the given route k.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Thus, to each λ_k, we associate a R1cVarData structure that carries the customers it visits.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"struct R1cVarData <: BlockDecomposition.AbstractCustomData\n    visited_locations::Vector{Int}\nend","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Then, we attach a R1cCutData custom data structure to the subset-row cuts. It contains the set C of customers characterizing the cut.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"struct R1cCutData <: BlockDecomposition.AbstractCustomData\n    cov_constrs::Vector{Int}\nend","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We declare our custom data to Coluna via BlockDecomposition add-ons:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"BlockDecomposition.customvars!(model, R1cVarData)\nBlockDecomposition.customconstrs!(model, [CoverConstrData, R1cCutData]);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"The next method calculates the coefficients of a column λ_k in a subset-row cut:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function Coluna.MathProg.computecoeff(\n    var_custom_data::R1cVarData, constr_custom_data::R1cCutData\n)\n    return floor(1 / 2 * length(var_custom_data.visited_locations ∩ constr_custom_data.cov_constrs))\nend","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We also need to define a second method for the case of the cover constraints. Indeed, we use custom data to know the customer attached to each cover constraint There is no contribution of the non-robust part of the coefficient of the λ_k, so the method returns 0.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function Coluna.MathProg.computecoeff(::R1cVarData, ::CoverConstrData)\n    return 0\nend","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We are now able to write our rank-one cut callback completely:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function r1c_callback(cbdata)\n    original_sol = cbdata.orig_sol\n    master = Coluna.MathProg.getmodel(original_sol)\n    # Retrieve the cover constraints.\n    cov_constrs = Int[]\n    for constr in values(Coluna.MathProg.getconstrs(master))\n        constr_custom_data = Coluna.MathProg.getcustomdata(master, constr)\n        if typeof(constr_custom_data) <: CoverConstrData\n            push!(cov_constrs, constr_custom_data.customer)\n        end\n    end\n\n    # Retrieve the master columns λ and their values in the current fractional solution\n    lambdas = Tuple{Float64,Coluna.MathProg.Variable}[]\n    for (var_id, val) in original_sol\n        if Coluna.MathProg.getduty(var_id) <= Coluna.MathProg.MasterCol\n            push!(lambdas, (val, Coluna.MathProg.getvar(master, var_id)))\n        end\n    end\n\n    # Separate the valid subset-row cuts violated by the current solution.\n    # For a fixed subset of customers of size three, iterate on the master columns\n    # and check if lhs > 1:\n    for cov_constr_subset in collect(combinations(cov_constrs, 3))\n        lhs = 0\n        for lambda in lambdas\n            (val, var) = lambda\n            var_custom_data = Coluna.MathProg.getcustomdata(master, var)\n            if !isnothing(var_custom_data)\n                coeff = floor(1 / 2 * length(var_custom_data.visited_locations ∩ cov_constr_subset))\n                lhs += coeff * val\n            end\n        end\n        if lhs > 1\n            # Create the constraint and add it to the model.\n            MOI.submit(model,\n                MOI.UserCut(cbdata),\n                JuMP.ScalarConstraint(JuMP.AffExpr(0.0), MOI.LessThan(1.0)),\n                R1cCutData(cov_constr_subset)\n            )\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"When creating non-robust constraints, only the linear (i.e., robust) part is passed to the model. In our case, the constraint 0 <= 1 is passed. As explained above, the non-robust part is computed by calling the computecoeff method using the structure of type R1cCutData provided.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Finally, we need to update our pricing callback to take into account the active non-robust cuts. The contribution of these cuts to the reduced cost of a column is not captured by the reduced cost of subproblem variables. We must therefore take this contribution into account manually, by inquiring the set of existing non-robust cuts and their values in the current dual solution.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"The contribution of a subset-row cut to the reduced cost of a route is managed by the following method:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function r1c_contrib(route::Route, custduals)\n    cost = 0\n    if !isempty(custduals)\n        for (r1c_cov_constrs, dual) in custduals\n            coeff = floor(1 / 2 * length(route.path ∩ r1c_cov_constrs))\n            cost += coeff * dual\n        end\n    end\n    return cost\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We re-write our pricing callback to:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"retrieve the dual cost of the subset-row cuts\ntake into account the contribution of the subset-row cuts in the reduced cost of the route\nattach custom data to the route so that its coefficient in the existing non-robust cuts can be computed","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function pricing_callback(cbdata)\n    j = BlockDecomposition.indice(BlockDecomposition.callback_spid(cbdata, model))\n    z_red_costs = Dict(\n        \"z_$(u)_$(v)\" => BlockDecomposition.callback_reduced_cost(cbdata, z[u, v]) for u in locations, v in locations\n    )\n    x_red_costs = Dict(\n        \"x_$(i)_$(j)\" => BlockDecomposition.callback_reduced_cost(cbdata, x[i, j]) for i in customers\n    )\n\n    # FIRST CHANGE HERE:\n    # Get the dual values of the constraints of the specific type to compute the contributions of\n    # non-robust cuts to the cost of the solution:\n    master = cbdata.form.parent_formulation\n    custduals = Tuple{Vector{Int},Float64}[]\n    for (_, constr) in Coluna.MathProg.getconstrs(master)\n        constr_custom_data = Coluna.MathProg.getcustomdata(master, constr)\n        if typeof(constr_custom_data) == R1cCutData\n            push!(custduals, (\n                constr_custom_data.cov_constrs,\n                Coluna.MathProg.getcurincval(master, constr)\n            ))\n        end\n    end\n    # END OF FIRST CHANGE\n\n    # SECOND CHANGE HERE:\n    # Keep route with the minimum reduced cost: contribution of the subproblem variables and\n    # the non-robust cuts.\n    red_costs_j = map(r -> (\n            r,\n            x_contribution(r, j, x_red_costs) + z_contribution(r, z_red_costs) - r1c_contrib(r, custduals)\n        ), routes_per_facility[j]\n    )\n    # END OF SECOND CHANGE\n    min_index = argmin([x for (_, x) in red_costs_j])\n    best_route, min_reduced_cost = red_costs_j[min_index]\n\n    best_route_arcs = Tuple{Int,Int}[]\n    for i in 1:(best_route.length-1)\n        push!(best_route_arcs, (best_route.path[i], best_route.path[i+1]))\n    end\n    best_route_customers = best_route.path[2:best_route.length]\n    z_vars = [z[u, v] for (u, v) in best_route_arcs]\n    x_vars = [x[i, j] for i in best_route_customers]\n    sol_vars = vcat(z_vars, x_vars)\n    sol_vals = ones(Float64, length(z_vars) + length(x_vars))\n    sol_cost = min_reduced_cost\n\n    # Submit the solution of the subproblem to Coluna\n    # THIRD CHANGE HERE:\n    # You must attach the visited customers in the structure of type `R1cVarData` to the solution of the subproblem\n    MOI.submit(\n        model, BlockDecomposition.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals,\n        R1cVarData(best_route.path)\n    )\n    # END OF THIRD CHANGE\n    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), sol_cost)\nend\n\nMOI.set(model, MOI.UserCutCallback(), r1c_callback);\nJuMP.optimize!(model)","category":"page"},{"location":"start/advanced_demo/#Multi-stage-pricing-callback","page":"Column Generation and Benders on Location Routing","title":"Multi-stage pricing callback","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"In this section, we implement a pricing heuristic that can be used together with the exact pricing callback to generate subproblems solutions.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"The idea of the heuristic is very simple:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Given a facility j, the heuristic finds the closest customer to j and adds it to the route.\nThen, while the reduced cost keeps improving and the maximum length of the route is not reached, the heuristic computes and adds to the route the nearest neighbor to the last customer of the route.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We first define an auxiliary function used to compute the route tail's nearest neighbor at each step:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function add_nearest_neighbor(route::Route, customers, costs)\n    # Get the last customer of the route.\n    loc = last(route.path)\n    # Initialize its nearest neighbor to zero and mincost to infinity.\n    (nearest, mincost) = (0, Inf)\n    # Compute nearest and mincost.\n    for i in customers\n        if !(i in route.path) # implying in particular (i != loc)\n            if (costs[loc, i] < mincost)\n                nearest = i\n                mincost = costs[loc, i]\n            end\n        end\n    end\n    # Add the last customer's nearest neighbor to the route.\n    if nearest != 0\n        push!(route.path, nearest)\n        route.length += 1\n    end\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We then define our heuristic for the enumeration of the routes, the method returns the best route found by the heuristic together with its cost:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function enumeration_heuristic(x_red_costs, z_red_costs, j)\n    # Initialize our \"greedy best route\".\n    best_route = Route(1, [j])\n    # Initialize the route's cost to zero.\n    current_redcost = 0.0\n    old_redcost = Inf\n\n    # main loop\n    while (current_redcost < old_redcost)\n        add_nearest_neighbor(best_route, customers, arc_costs)\n        old_redcost = current_redcost\n        current_redcost = x_contribution(best_route, j, x_red_costs) +\n                          z_contribution(best_route, z_red_costs)\n        # Max length is reached.\n        if best_route.length == nb_positions\n            break\n        end\n    end\n    return (best_route, current_redcost)\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We can now define our heuristic pricing callback:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function approx_pricing(cbdata)\n\n    j = BlockDecomposition.indice(BlockDecomposition.callback_spid(cbdata, model))\n    z_red_costs = Dict(\n        \"z_$(u)_$(v)\" => BlockDecomposition.callback_reduced_cost(cbdata, z[u, v]) for u in locations, v in locations\n    )\n    x_red_costs = Dict(\n        \"x_$(i)_$(j)\" => BlockDecomposition.callback_reduced_cost(cbdata, x[i, j]) for i in customers\n    )\n\n    # Call the heuristic to elect the \"greedy best route\":\n    best_route, sol_cost = enumeration_heuristic(x_red_costs, z_red_costs, j)\n\n    # Build the solution:\n    best_route_arcs = Vector{Tuple{Int,Int}}()\n    for i in 1:(best_route.length-1)\n        push!(best_route_arcs, (best_route.path[i], best_route.path[i+1]))\n    end\n    best_route_customers = best_route.path[2:length(best_route.path)]\n\n    z_vars = [z[u, v] for (u, v) in best_route_arcs]\n    x_vars = [x[i, j] for i in best_route_customers]\n    sol_vars = vcat(z_vars, x_vars)\n    sol_vals = ones(Float64, length(z_vars) + length(x_vars))\n\n    MOI.submit(model, BlockDecomposition.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)\n    # As the procedure is inexact, no dual bound can be computed, we set it to -Inf.\n    MOI.submit(model, BlockDecomposition.PricingDualBound(cbdata), -Inf)\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We set the solver; colgen_stages_pricing_solvers indicates which solver to use first (here it is approx_pricing)","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"coluna = JuMP.optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"default_optimizer\" => GLPK.Optimizer,\n    \"params\" => Coluna.Params(\n        solver=Coluna.Algorithm.BranchCutAndPriceAlgorithm(\n            maxnumnodes=100,\n            colgen_stages_pricing_solvers=[2, 1]\n        )\n    )\n);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We add the two pricing algorithms to our model:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"model, x, y, z, cov = create_model(coluna, [approx_pricing, pricing_callback]);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We declare our custom data to Coluna:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"BlockDecomposition.customvars!(model, R1cVarData)\nBlockDecomposition.customconstrs!(model, [CoverConstrData, R1cCutData]);\nfor i in customers\n    customdata!(cov[i], CoverConstrData(i))\nend","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Optimize:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"JuMP.optimize!(model)","category":"page"},{"location":"start/advanced_demo/#Benders-decomposition","page":"Column Generation and Benders on Location Routing","title":"Benders decomposition","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"In this section, we show how one can solve the linear relaxation of the master program of a Benders Decomposition approach to this facility location demo problem.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"The first-stage decisions consist in choosing a subset of facilities to open. The second-stage decisions consist in choosing the routes that are assigned to each facility. The second stage problem is an integer program, so for simplicity, we use its linear relaxation instead. To improve the quality of this relaxation, we enumerate the routes and use one variable per route. As this approach is practical only for small instances, we use it only for illustration purposes. For larger instances, we would have to implement a column generation approach to solve the subproblem, i.e., the Benders cut separation problem.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"In the same spirit as the above models, we use the variables. Let y[j] equal 1 if the facility j is open and 0 otherwise. Let λ[j,k] equal 1 if route k starting from facility j is selected and 0 otherwise.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Since there is only one subproblem in the second stage, we introduce a fake axis that contains only one element. This approach can be generalized to the case where customer demand uncertainty is expressed with scenarios. In this case, we would have one subproblem for each scenario, and the axis would have been defined for the set of scenarios. In our case, the set of scenarios consists of one \"fake\" scenario.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"fake = 1\n@axis(axis, collect(fake:fake))\n\ncoluna = JuMP.optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(solver=Coluna.Algorithm.BendersCutGeneration()\n    ),\n    \"default_optimizer\" => GLPK.Optimizer\n)\n\nmodel = BlockModel(coluna);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We introduce auxiliary structures to improve the clarity of the code.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"# routes covering customer i from facility j.\ncovering_routes = Dict(\n    (j, i) => findall(r -> (i in r.path), routes_per_facility[j]) for i in customers, j in facilities\n);\n# routes costs from facility j.\nroutes_costs = Dict(\n    j => [route_original_cost(arc_costs, r) for r in routes_per_facility[j]] for j in facilities\n);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We declare the variables.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"@variable(model, 0 <= y[j in facilities] <= 1) ## 1st stage\n@variable(model, 0 <= λ[f in axis, j in facilities, k in 1:length(routes_per_facility[j])] <= 1); ## 2nd stage\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We declare the constraints.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"# Linking constraints\n@constraint(model, open[fake in axis, j in facilities, k in 1:length(routes_per_facility[j])],\n    y[j] >= λ[fake, j, k])\n\n# Second-stage constraints\n@constraint(model, cover[fake in axis, i in customers],\n    sum(λ[fake, j, k] for j in facilities, k in covering_routes[(j, i)]) >= 1)\n\n# Second-stage constraints\n@constraint(model, limit_nb_routes[fake in axis, j in facilities],\n    sum(λ[fake, j, q] for q in 1:length(routes_per_facility[j])) <= nb_routes_per_facility\n)\n\n# First-stage constraint\n# This constraint is redundant, we add it in order not to start with an empty master problem\n@constraint(model, min_opening,\n    sum(y[j] for j in facilities) >= 1)\n\n@objective(model, Min,\n    sum(facilities_fixed_costs[j] * y[j] for j in facilities) +\n    sum(routes_costs[j][k] * λ[fake, j, k] for j in facilities, k in 1:length(routes_per_facility[j])));\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We perform the decomposition over the axis and we optimize the problem.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"@benders_decomposition(model, dec, axis)\nJuMP.optimize!(model)","category":"page"},{"location":"start/advanced_demo/#Example-of-comparison-of-the-dual-bounds","page":"Column Generation and Benders on Location Routing","title":"Example of comparison of the dual bounds","text":"","category":"section"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"In this section, we use a larger instance with 3 facilities and 13 customers. We solve only the root node and look at the dual bound:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"with the standard column generation (without cut separation)\nby adding robust cuts\nby adding non-robust cuts\nby adding both robust and non-robust cuts","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"nb_positions = 6\nfacilities_fixed_costs = [120, 150, 110]\nfacilities = [1, 2, 3]\ncustomers = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\narc_costs = [\n    0.0 125.6 148.9 182.2 174.9 126.2 158.6 172.9 127.4 133.1 152.6 183.8 182.4 176.9 120.7 129.5;\n    123.6 0.0 175.0 146.7 191.0 130.4 142.5 139.3 130.1 133.3 163.8 127.8 139.3 128.4 186.4 115.6;\n    101.5 189.6 0.0 198.2 150.5 159.6 128.3 133.0 195.1 167.3 187.3 178.1 171.7 161.5 142.9 142.1;\n    159.4 188.4 124.7 0.0 174.5 174.0 142.6 102.5 135.5 184.4 121.6 112.1 139.9 105.5 190.9 140.7;\n    157.7 160.3 184.2 196.1 0.0 115.5 175.2 153.5 137.7 141.3 109.5 107.7 125.3 151.0 133.1 140.6;\n    145.2 120.4 106.7 138.8 157.3 0.0 153.6 192.2 153.2 184.4 133.6 164.9 163.6 126.3 121.3 161.4;\n    182.6 152.1 178.8 184.1 150.8 163.5 0.0 164.1 104.0 100.5 117.3 156.1 115.1 168.6 186.5 100.2;\n    144.9 193.8 146.1 191.4 136.8 172.7 108.1 0.0 131.0 166.3 116.4 187.0 161.3 148.2 162.1 116.0;\n    173.4 199.1 132.9 133.2 139.8 112.7 138.1 118.8 0.0 173.4 131.8 180.6 191.0 133.9 178.7 108.7;\n    150.5 171.0 163.8 171.5 116.3 149.1 124.0 192.5 188.8 0.0 112.2 188.7 197.3 144.9 110.7 186.6;\n    153.6 104.4 141.1 124.7 121.1 137.5 190.3 177.1 194.4 135.3 0.0 146.4 132.7 103.2 150.3 118.4;\n    112.5 133.7 187.1 170.0 130.2 177.7 159.2 169.9 183.8 101.6 156.2 0.0 114.7 169.3 149.9 125.3;\n    151.5 165.6 162.1 133.4 159.4 200.5 132.7 199.9 136.8 121.3 118.1 123.4 0.0 104.8 197.1 134.4;\n    195.0 101.1 194.1 160.1 147.1 164.6 137.2 138.6 166.7 191.2 169.2 186.0 171.2 0.0 106.8 150.9;\n    158.2 152.7 104.0 136.0 168.9 175.7 139.2 163.2 102.7 153.3 185.9 164.0 113.2 200.7 0.0 127.4;\n    136.6 174.3 103.2 131.4 107.8 191.6 115.1 127.6 163.2 123.2 173.3 133.0 120.5 176.9 173.8 0.0;\n]\n\nlocations = vcat(facilities, customers)\nnb_customers = length(customers)\nnb_facilities = length(facilities)\npositions = 1:nb_positions;\n\nroutes_per_facility = Dict(\n    j => best_route_forall_cust_subsets(arc_costs, customers, j, nb_positions) for j in facilities\n);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We set maxnumnodes to zero to optimize only the root node:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver=Coluna.Algorithm.TreeSearchAlgorithm(\n            maxnumnodes=0,\n            conqueralg=Coluna.ColCutGenConquer()\n        )\n    ),\n    \"default_optimizer\" => GLPK.Optimizer\n);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"We define a method to call both valid_inequalities_callback and r1c_callback:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"function cuts_callback(cbdata)\n    valid_inequalities_callback(cbdata)\n    r1c_callback(cbdata)\nend\n\nfunction attach_data(model, cov)\n    BlockDecomposition.customvars!(model, R1cVarData)\n    BlockDecomposition.customconstrs!(model, [CoverConstrData, R1cCutData])\n    for i in customers\n        customdata!(cov[i], CoverConstrData(i))\n    end\nend;\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"First, we solve the root node with the \"raw\" decomposition model:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"model, x, y, z, cov = create_model(coluna, pricing_callback)\nattach_data(model, cov)","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"dual bound found after optimization = 1588.00","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Then, we re-solve it with the robust cuts:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"model, x, y, z, cov = create_model(coluna, pricing_callback)\nattach_data(model, cov)\nMOI.set(model, MOI.UserCutCallback(), valid_inequalities_callback);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"dual bound found after optimization = 1591.55","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"And with non-robust cuts:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"model, x, y, z, cov = create_model(coluna, pricing_callback)\nattach_data(model, cov)\nMOI.set(model, MOI.UserCutCallback(), r1c_callback);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"dual bound found after optimization = 1598.26","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"Finally we add both robust and non-robust cuts:","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"model, x, y, z, cov = create_model(coluna, pricing_callback)\nattach_data(model, cov)\nMOI.set(model, MOI.UserCutCallback(), cuts_callback);\nnothing #hide","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"dual bound found after optimization =  1600.63","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"start/advanced_demo/","page":"Column Generation and Benders on Location Routing","title":"Column Generation and Benders on Location Routing","text":"","category":"page"},{"location":"man/callbacks/#User-defined-Callbacks","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"Callbacks are functions defined by the user that allow him to take over part of the default conquer  algorithm. The more classical callbacks in Branch-and-Cut and Branch-and-Price solvers are:","category":"page"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"Pricing callback (only in Branch-and-Price solvers) that takes over the procedure to determine whether the current master LP   solution is optimum or produces an entering variable with negative reduced cost by solving subproblems\nSeparation callback that takes over the procedure to determine whether the current master   LP solution is feasible or produces a valid problem constraint that is violated\nBranching callback that takes over the procedure to determine whether the current master   LP solution is integer or produces a valid branching disjunctive constraint that rules out   the current fractional solution.","category":"page"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"note: Note\nYou can't change the original formulation in a callback because Coluna does not propagate the changes into the reformulation and does not check if the solutions found are still feasible.","category":"page"},{"location":"man/callbacks/#Pricing-callbacks","page":"User-defined Callbacks","title":"Pricing callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"Pricing callbacks let you define how to solve the subproblems of a Dantzig-Wolfe decomposition to generate a new entering column in the master program. This callback is useful when you know an efficient algorithm to solve the subproblems, i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"See the example in the tutorial section.","category":"page"},{"location":"man/callbacks/#Errors-and-Warnings","page":"User-defined Callbacks","title":"Errors and Warnings","text":"","category":"section"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"Algorithm.IncorrectPricingDualBound\nAlgorithm.MissingPricingDualBound\nAlgorithm.MultiplePricingDualBounds","category":"page"},{"location":"man/callbacks/#Coluna.Algorithm.IncorrectPricingDualBound","page":"User-defined Callbacks","title":"Coluna.Algorithm.IncorrectPricingDualBound","text":"IncorrectPricingDualBound\n\nError thrown when transmitting a dual bound larger than the primal bound of the  best solution to the pricing subproblem found in a run of the pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/#Coluna.Algorithm.MissingPricingDualBound","page":"User-defined Callbacks","title":"Coluna.Algorithm.MissingPricingDualBound","text":"MissingPricingDualBound\n\nError thrown when the pricing callback does not transmit any dual bound. Make sure you call MOI.submit(model, BD.PricingDualBound(cbdata), db) in your pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/#Coluna.Algorithm.MultiplePricingDualBounds","page":"User-defined Callbacks","title":"Coluna.Algorithm.MultiplePricingDualBounds","text":"MultiplePricingDualBounds\n\nError thrown when the pricing transmits multiple dual bound. Make sure you call MOI.submit(model, BD.PricingDualBound(cbdata), db) only once in your  pricing callback.\n\n\n\n\n\n","category":"type"},{"location":"man/callbacks/#Separation-callbacks","page":"User-defined Callbacks","title":"Separation callbacks","text":"","category":"section"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"Separation callbacks let you define how to separate cuts or constraints.","category":"page"},{"location":"man/callbacks/#Facultative-and-essential-cuts-(user-cut-and-lazy-constraint)","page":"User-defined Callbacks","title":"Facultative & essential cuts (user cut & lazy constraint)","text":"","category":"section"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"This callback allows you to add cuts to the master problem. The cuts must be expressed in terms of the original variables. Then, Coluna expresses them over the master variables. You can find an example of essential cut separation and facultative cut separation in the JuMP documentation.","category":"page"},{"location":"man/callbacks/","page":"User-defined Callbacks","title":"User-defined Callbacks","text":"","category":"page"},{"location":"man/blockdecomposition/#Setup-decomposition-with-BlockDecomposition","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition with BlockDecomposition","text":"","category":"section"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"BlockDecomposition allows the user to perform two types of decomposition using BlockDecomposition.@dantzig_wolfe_decomposition and BlockDecomposition.@benders_decomposition.","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"For both decompositions, the index-set of the subproblems is declared through an BlockDecomposition.@axis.  It returns an array. Each value of the array is a subproblem index wrapped into a BlockDecomposition.AxisId. Each time BlockDecomposition finds an AxisId in the indices of a variable and a constraint, it knows to which subproblem the variable or the constraint belongs.","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"The macro creates a decomposition tree where the root is the master and the depth is the number of nested decompositions. A classic Dantzig-Wolfe or Benders decomposition produces a decomposition tree of depth 1. At the moment, nested decomposition is not supported.","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"You can get the subproblem membership of all variables and constraints using the method BlockDecomposition.annotation.","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"BlockDecomposition does not change the JuMP model. It decorates the model with additional information. All this information is stored in the ext field of the JuMP model.","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"CurrentModule = BlockDecomposition","category":"page"},{"location":"man/blockdecomposition/#Errors-and-warnings","page":"Setup decomposition using BlockDecomposition","title":"Errors and warnings","text":"","category":"section"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"MasterVarInDwSp\nVarsOfSameDwSpInMaster","category":"page"},{"location":"man/blockdecomposition/#BlockDecomposition.MasterVarInDwSp","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.MasterVarInDwSp","text":"Error thrown when a master variable is in a constraint that belongs to a Dantzig-Wolfe subproblem.\n\nYou can retrieve the JuMP variable and the JuMP constraint where the error occurs:\n\nerror.variable\nerror.constraint\n\n\n\n\n\n","category":"type"},{"location":"man/blockdecomposition/#BlockDecomposition.VarsOfSameDwSpInMaster","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.VarsOfSameDwSpInMaster","text":"Warning when a master constraint involves variables that belong to the same Dantzig-Wolfe subproblem. It means you can move the constraint in a subproblem.\n\n\n\n\n\n","category":"type"},{"location":"man/blockdecomposition/#References","page":"Setup decomposition using BlockDecomposition","title":"References","text":"","category":"section"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"BlockModel","category":"page"},{"location":"man/blockdecomposition/#BlockDecomposition.BlockModel","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.BlockModel","text":"BlockModel(optimizer [, direct_model = false])\n\nReturn a JuMP model which BlockDecomposition will decompose using instructions given by the user.\n\nIf you define direct_model = true, the method creates the model with JuMP.direct_model, otherwise it uses JuMP.Model.\n\n\n\n\n\n","category":"function"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"These are the methods to decompose a JuMP model :","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"@axis\n@benders_decomposition\n@dantzig_wolfe_decomposition","category":"page"},{"location":"man/blockdecomposition/#BlockDecomposition.@axis","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.@axis","text":"@axis(name, collection)\n\nDeclare collection as an index-set of subproblems.  You can access the axis using the variable name.\n\nExamples\n\nConsider a formulation that has a decomposition which gives raise to 5 subproblems. Let {1,2,3,4,5} be the index-set of the subproblems.\n\nTo perform this decomposition with BlockDecomposition, we must declare an axis that contains the index-set of the subproblems :\n\njulia> L = 1:5\n1:5\n\njulia> @axis(K, L)\nBlockDecomposition.Axis{:K, Int64}(:K, BlockDecomposition.AxisId{:K, Int64}[1, 2, 3, 4, 5])\n\njulia> K[1]\n1\n\njulia> typeof(K[1])\nBlockDecomposition.AxisId{:K, Int64}\n\nThe elements of the axis are AxisId. You must use AxisId in the indices of the variables and the constraints that you declare otherwise BlockDecomposition assign them to the master problem.\n\n@variable(model, x[l in L]) # x[l] belongs to the master for any l ∈ L\n@variable(model, y[k in K]) # y[k], k ∈ K, belongs to subproblem k (because K is an axis)\n\n\n\n\n\n","category":"macro"},{"location":"man/blockdecomposition/#BlockDecomposition.@benders_decomposition","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.@benders_decomposition","text":"@benders_decomposition(model, name, axis)\n\nRegister a Benders decomposition on the JuMP model model where the index-set of the subproblems is defined by the axis axis.\n\nCreate a variable name from which the user can access decomposition tree.\n\n\n\n\n\n","category":"macro"},{"location":"man/blockdecomposition/#BlockDecomposition.@dantzig_wolfe_decomposition","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.@dantzig_wolfe_decomposition","text":"@dantzig_wolfe_decomposition(model, name, axis)\n\nRegister a Dantzig-Wolfe decomposition on the JuMP model model where the index-set of the subproblems is defined by the axis axis.\n\nCreate a variable name from which the user can access the decomposition tree.\n\n\n\n\n\n","category":"macro"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"These are the methods to set additional information to the decomposition (multiplicity and optimizers) :","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"getmaster\ngetsubproblems\nspecify!","category":"page"},{"location":"man/blockdecomposition/#BlockDecomposition.getmaster","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.getmaster","text":"getmaster(node) -> MasterForm\n\nReturn an object that wraps the annotation that describes the master formulation of a decomposition stored at the node of the decomposition tree.\n\nThis method is not defined if the node is a leaf of the decomposition tree.\n\n\n\n\n\n","category":"function"},{"location":"man/blockdecomposition/#BlockDecomposition.getsubproblems","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.getsubproblems","text":"getsubproblems(node) -> Vector{SubproblemForm}\n\nReturn a vector of objects that wrap the annotations that describe subproblem formulations of a decomposition stored at node of the decomposition tree.\n\nThis method is not defined if the node is a leaf of the decomposition tree.\n\n\n\n\n\n","category":"function"},{"location":"man/blockdecomposition/#BlockDecomposition.specify!","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.specify!","text":"specify!(\n    subproblem, \n    lower_multiplicity = 1,\n    upper_multiplicity = 1,\n    solver = nothing\n)\n\nMethod that allows the user to specify additional property of the subproblems.\n\nThe multiplicity of subproblem is the number of times that the same independant block shaped by the subproblem in the coefficient matrix appears in the model. It is equivalent to the number of solutions to the subproblem that can appear in the solution  of the original problem.\n\nThe solver of the subproblem is the way the subproblem will be optimized. It can be either a function (pricing callback), an optimizer of MathOptInterface  (e.g. Gurobi.Optimizer, CPLEX.Optimizer, Glpk.Optimizer... with attributes),  or nothing. In the latter case, the solver will use a default optimizer that  should be defined in the parameters of the main solver.\n\nAdvanced usage :  The user can use several solvers to optimize a subproblem : \n\nspecify!(subproblem, solver = [Gurobi.Optimizer, my_callback, my_second_callback])\n\nColuna always uses the first solver by default. Be cautious because changes are always buffered to all solvers. So you may degrade performances if you use a lot of solvers.\n\n\n\n\n\n","category":"function"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"This method helps you to check your decomposition :","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"annotation","category":"page"},{"location":"man/blockdecomposition/#BlockDecomposition.annotation","page":"Setup decomposition using BlockDecomposition","title":"BlockDecomposition.annotation","text":"annotation(node)\n\nReturn the annotation that describes the master/subproblem of a given node of the decomposition tree.\n\nannotation(model, variable)\nannotation(model, constraint)\n\nReturn the subproblem to which a variable or a constraint belongs.\n\n\n\n\n\n","category":"function"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"CurrentModule = nothing","category":"page"},{"location":"man/blockdecomposition/","page":"Setup decomposition using BlockDecomposition","title":"Setup decomposition using BlockDecomposition","text":"","category":"page"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"CurrentModule = Coluna","category":"page"},{"location":"man/algorithm/#Built-in-Algorithms","page":"Built-in algorithms","title":"Built-in Algorithms","text":"","category":"section"},{"location":"man/algorithm/#Branch-and-Bound","page":"Built-in algorithms","title":"Branch-and-Bound","text":"","category":"section"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Branch-and-Bound algorithm aims to find an optimal solution of a MIP by successive divisions of the search space. An introduction to the Branch-and-Bound algorithm can be found here. ","category":"page"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Coluna provides a generic Branch-and-Bound algorithm whose three main elements can be easily modified:","category":"page"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.TreeSearchAlgorithm","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.TreeSearchAlgorithm","page":"Built-in algorithms","title":"Coluna.Algorithm.TreeSearchAlgorithm","text":"Coluna.Algorithm.TreeSearchAlgorithm(\n    conqueralg::AbstractConquerAlgorithm = ColCutGenConquer(),\n    dividealg::AbstractDivideAlgorithm = Branching(),\n    explorestrategy::AbstractExploreStrategy = DepthFirstStrategy(),\n    maxnumnodes = 100000,\n    opennodeslimit = 100,\n    timelimit = -1, # -1 means no time limit\n    opt_atol::Float64 = DEF_OPTIMALITY_ATOL,\n    opt_rtol::Float64 = DEF_OPTIMALITY_RTOL,\n    branchingtreefile = \"\",\n    jsonfile = \"\",\n    print_node_info = true\n)\n\nThis algorithm is a branch and bound that uses a search tree to optimize the reformulation. At each node in the tree, it applies conqueralg to evaluate the node and improve the bounds,  dividealg to generate branching constraints, and explorestrategy to select the next node to treat.\n\nThe three main elements of the algorithm are:\n\nthe conquer strategy (conqueralg): evaluation of the problem at a node of the Branch-and-Bound tree. Depending on the type of decomposition used ahead of the Branch-and-Bound, you can use either Column Generation (if your problem is decomposed following Dantzig-Wolfe transformation) and/or Cut Generation (for Dantzig-Wolfe and Benders decompositions). \nthe branching strategy (dividealg): how to create new branches i.e. how to divide the search space\nthe explore strategy (explorestrategy): the evaluation order of your nodes \n\nParameters: \n\nmaxnumnodes : maximum number of nodes explored by the algorithm\nopennodeslimit : maximum number of nodes waiting to be explored\ntimelimit : time limit in seconds of the algorithm\nopt_atol : optimality absolute tolerance (alpha)\nopt_rtol : optimality relative tolerance (alpha)\n\nOptions:\n\nbranchingtreefile : name of the file in which the algorithm writes an overview of the branching tree\njsonfile : name of the file in which the algorithm writes the solution in JSON format\nprint_node_info : log the tree into the console\n\nWarning: if you set a name for the branchingtreefile AND the jsonfile, the algorithm will only write in the json file.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Conquer, divide algorithms and the explore strategy available with the TreeSearchAlgorithm are listed in the following mind map. ","category":"page"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"mindmap\n    TreeSearchAlgorithm\n        (conquer)\n            BendersConquer\n            ColCutGenConquer\n            RestrMasterLpConquer\n        (divide)\n            NoBranching\n            ClassicBranching\n            StrongBranching\n        (explore)\n            DepthFirstStrategy\n            BestDualBoundStrategy","category":"page"},{"location":"man/algorithm/#Conquer-algorithms","page":"Built-in algorithms","title":"Conquer algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.BendersConquer\nAlgorithm.ColCutGenConquer\nAlgorithm.RestrMasterLpConquer","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.ColCutGenConquer","page":"Built-in algorithms","title":"Coluna.Algorithm.ColCutGenConquer","text":"Coluna.Algorithm.ColCutGenConquer(\n    colgen = ColumnGeneration(),\n    cutgen = CutCallbacks(),\n    primal_heuristics = ParameterizedHeuristic[ParamRestrictedMasterHeuristic()],\n    max_nb_cut_rounds = 3\n)\n\nColumn-and-cut-generation based algorithm to find primal and dual bounds for a  problem decomposed using Dantzig-Wolfe paradigm.\n\nParameters :\n\ncolgen: column generation algorithm\ncutgen: cut generation algorithm\nprimal_heuristics: heuristics to find a feasible solution\nmax_nb_cut_rounds : number of cut generation done by the algorithm\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Divide-algorithms","page":"Built-in algorithms","title":"Divide algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.NoBranching\nAlgorithm.ClassicBranching","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.NoBranching","page":"Built-in algorithms","title":"Coluna.Algorithm.NoBranching","text":"Divide algorithm that does nothing. It does not generate any child.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.ClassicBranching","page":"Built-in algorithms","title":"Coluna.Algorithm.ClassicBranching","text":"ClassicBranching(\n    selection_criterion = MostFractionalCriterion()\n    rules = [Branching.PrioritisedBranchingRule(SingleVarBranchingRule(), 1.0, 1.0)]\n    int_tol = 1e-6\n)\n\nChooses the best candidate according to a selection criterion and generates the two children.\n\nParameters\n\nselection_criterion: selection criterion to choose the best candidate\nrules: branching rules to generate the candidates\nint_tol: tolerance to determine if a variable is integer\n\nIt is implemented as a specific case of the strong branching algorithm.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Strong branching is the main algorithm that we provide and it is the default implementation of the Branching submodule. You can have more information about the algorithm by reading the Branching submodule documentation.","category":"page"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.StrongBranching","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.StrongBranching","page":"Built-in algorithms","title":"Coluna.Algorithm.StrongBranching","text":"StrongBranching(\n    phases = [],\n    rules = [Branching.PrioritisedBranchingRule(SingleVarBranchingRule(), 1.0, 1.0)],\n    selection_criterion = MostFractionalCriterion(),\n    verbose = true,\n    int_tol = 1e-6\n)\n\nThe algorithm that performs a (multi-phase) (strong) branching in a tree search algorithm.\n\nStrong branching is a procedure that heuristically selects a branching constraint that potentially gives the best progress of the dual bound. The procedure selects a collection  of branching candidates based on their branching rule and their score. Then, the procedure evaluates the progress of the dual bound in both branches of each branching candidate by solving both potential children using a conquer algorithm. The candidate that has the largest product of dual bound improvements in the branches  is chosen to be the branching constraint.\n\nWhen the dual bound improvement produced by the branching constraint is difficult to compute (e.g. time-consuming in the context of column generation), one can let the branching algorithm quickly estimate the dual bound improvement of each candidate and retain the most promising branching candidates. This is called a phase. The goal is to first evaluate a large number of candidates with a very fast conquer algorithm and retain a certain number of promising ones.  Then, over the phases, it evaluates the improvement with a more precise conquer algorithm and restrict the number of retained candidates until only one is left.\n\nParameters:\n\nphases: a vector of Coluna.Algorithm.BranchingPhase\nrules: a vector of Coluna.Algorithm.Branching.PrioritisedBranchingRule\nselection_criterion: a selection criterion to choose the initial candidates\nverbose: if true, print the progress of the strong branching procedure\nint_tol: tolerance to determine if a variable is integer\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"All the possible algorithms that can be used within the strong branching are listed in the following mind map.","category":"page"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"mindmap\n    StrongBranching\n        (phases)\n            (conquer)\n                BendersConquer\n                ColCutGenConquer\n                RestrMasterLpConquer\n            (score)\n                ProductScore\n                TreeDepthScore\n        (rules)\n            SingleVarBranchingRule\n        (selection_criterion)\n            FirstFoundCriterion\n            MostFractionalCriterion","category":"page"},{"location":"man/algorithm/#Explore-strategies","page":"Built-in algorithms","title":"Explore strategies","text":"","category":"section"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"TreeSearch.DepthFirstStrategy\nTreeSearch.BestDualBoundStrategy","category":"page"},{"location":"man/algorithm/#Coluna.TreeSearch.DepthFirstStrategy","page":"Built-in algorithms","title":"Coluna.TreeSearch.DepthFirstStrategy","text":"Explore the tree search space with a depth-first strategy. The next visited node is the last one pushed in the stack of unexplored nodes.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.TreeSearch.BestDualBoundStrategy","page":"Built-in algorithms","title":"Coluna.TreeSearch.BestDualBoundStrategy","text":"Explore the tree search space with a best-first strategy. The next visited node is the one with the highest local dual bound.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Cut-generation-algorithms","page":"Built-in algorithms","title":"Cut generation algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.BendersCutGeneration","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.BendersCutGeneration","page":"Built-in algorithms","title":"Coluna.Algorithm.BendersCutGeneration","text":"Coluna.Algorithm.BendersCutGeneration(\n    restr_master_solve_alg = SolveLpForm(get_dual_sol = true, relax_integrality = true),\n    restr_master_optimizer_id = 1,\n    separation_solve_alg = SolveLpForm(get_dual_sol = true, relax_integrality = true)\n    max_nb_iterations::Int = 100,\n)\n\nBenders cut generation algorithm that can be applied to a formulation reformulated using Benders decomposition.\n\nThis algorithm is an implementation of the generic algorithm provided by the Benders submodule.\n\nParameters:\n\nrestr_master_solve_alg: algorithm to solve the restricted master problem\nrestr_master_optimizer_id: optimizer id to use to solve the restricted master problem\nseparation_solve_alg: algorithm to solve the separation problem (must be a LP solver that returns a dual solution)\n\nOption:\n\nmax_nb_iterations: maximum number of iterations\n\nAbout the output\n\nAt each iteration, the Benders cut generation algorithm show following statistics:\n\n<it=  6> <et= 0.05> <mst= 0.00> <sp= 0.00> <cuts= 0> <master=  293.5000>\n\nwhere:\n\nit stands for the current number of iterations of the algorithm\net is the elapsed time in seconds since Coluna has started the optimisation\nmst is the time in seconds spent solving the master problem at the current iteration\nsp is the time in seconds spent solving the separation problem at the current iteration\ncuts is the number of cuts generated at the current iteration\nmaster is the objective value of the master problem at the current iteration\n\nDebug options (print at each iteration):\n\ndebug_print_master: print the master problem\ndebug_print_master_primal_solution: print the master problem with the primal solution\ndebug_print_master_dual_solution: print the master problem with the dual solution (make sure the restr_master_solve_alg returns a dual solution)\ndebug_print_subproblem: print the subproblem\ndebug_print_subproblem_primal_solution: print the subproblem with the primal solution\ndebug_print_subproblem_dual_solution: print the subproblem with the dual solution\ndebug_print_generated_cuts: print the generated cuts\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.CutCallbacks","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.CutCallbacks","page":"Built-in algorithms","title":"Coluna.Algorithm.CutCallbacks","text":"CutCallbacks(\n    call_robust_facultative = true,\n    call_robust_essential = true,\n    tol::Float64 = 1e-6\n)\n\nRuns the cut user callbacks attached to a formulation.\n\nParameters:\n\ncall_robust_facultative: if true, call all the robust facultative cut user callbacks (i.e. user cut callbacks)\ncall_robust_essential: if true, call all the robust essential cut user callbacks (i.e. lazy constraint callbacks)\ntol: tolerance used to determine if a cut is violated\n\nSee the JuMP documentation for more information about user callbacks and the tutorials in the Coluna documentation for examples of user callbacks.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Column-generation-algorithms","page":"Built-in algorithms","title":"Column generation algorithms","text":"","category":"section"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.ColumnGeneration","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.ColumnGeneration","page":"Built-in algorithms","title":"Coluna.Algorithm.ColumnGeneration","text":"Coluna.Algorithm.ColumnGeneration(\n    restr_master_solve_alg = SolveLpForm(get_dual_sol = true),\n    pricing_prob_solve_alg = SolveIpForm(\n        moi_params = MoiOptimize(\n            deactivate_artificial_vars = false,\n            enforce_integrality = false\n        )\n    ),\n    essential_cut_gen_alg = CutCallbacks(call_robust_facultative = false),\n    max_nb_iterations = 1000,\n    log_print_frequency = 1,\n    redcost_tol = 1e-4,\n    show_column_already_inserted_warning = true,\n    cleanup_threshold = 10000,\n    cleanup_ratio = 0.66,\n    smoothing_stabilization = 0.0 # should be in [0, 1],\n)\n\nColumn generation algorithm that can be applied to formulation reformulated using Dantzig-Wolfe decomposition. \n\nThis algorithm first solves the linear relaxation of the master (master LP) using restr_master_solve_alg. Then, it solves the subproblems by calling pricing_prob_solve_alg to get the columns that have the best reduced costs and that hence, may improve the master LP's objective the most.\n\nIn order for the algorithm to converge towards the optimal solution of the master LP, it suffices that the pricing oracle returns, at each iteration, a negative reduced cost solution if one exists.  The algorithm stops when all subproblems fail to generate a column with negative (positive) reduced cost in the case of a minimization (maximization) problem or when it reaches the maximum number of iterations.\n\nParameters: \n\nrestr_master_solve_alg: algorithm to optimize the master LP\npricing_prob_solve_alg: algorithm to optimize the subproblems\nessential_cut_gen_alg: algorithm to generate essential cuts which is run when the solution of the master LP is integer.\n\nOptions:\n\nmax_nb_iterations: maximum number of iterations\nlog_print_frequency: display frequency of iterations statistics\n\nUndocumented parameters are in alpha version.\n\nAbout the ouput\n\nAt each iteration (depending on log_print_frequency),  the column generation algorithm can display following statistics.\n\n<it= 90> <et=15.62> <mst= 0.02> <sp= 0.05> <cols= 4> <al= 0.00> <DB=  300.2921> <mlp=  310.3000> <PB=310.3000>\n\nHere are their meanings :\n\nit stands for the current number of iterations of the algorithm\net is the elapsed time in seconds since Coluna has started the optimisation\nmst is the time in seconds spent solving the master LP at the current iteration\nsp is the time in seconds spent solving the subproblems at the current iteration\ncols is the number of column generated by the subproblems at the current iteration\nal is the smoothing factor of the stabilisation at the current iteration (alpha version)\nDB is the dual bound of the master LP at the current iteration\nmlp is the objective value of the master LP at the current iteration\nPB is the objective value of the best primal solution found by Coluna at the current iteration\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#External-call-to-optimize-a-linear-program","page":"Built-in algorithms","title":"External call to optimize a linear program","text":"","category":"section"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.SolveLpForm","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.SolveLpForm","page":"Built-in algorithms","title":"Coluna.Algorithm.SolveLpForm","text":"Coluna.Algorithm.SolveLpForm(\n    get_ip_primal_sol = false,\n    get_dual_sol = false,\n    relax_integrality = false,\n    get_dual_bound = false,\n    silent = true\n)\n\nSolve a linear program stored in a formulation using its first optimizer. This algorithm works only if the optimizer is interfaced with MathOptInterface.\n\nYou can define the optimizer using the default_optimizer attribute of Coluna or with the method specify! from BlockDecomposition\n\nParameters:\n\nget_ip_primal_sol: update the primal solution of the formulation if equals true\nget_dual_sol: retrieve the dual solution and store it in the ouput if equals true\nrelax_integrality: relax integer variables of the formulation before optimization if equals true\nget_dual_bound: store the dual objective value in the output if equals true\nsilent: set MOI.Silent() to its value\n\nUndocumented parameters are alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#External-call-to-optimize-a-mixed-integer-program-/-combinatorial-problem","page":"Built-in algorithms","title":"External call to optimize a mixed-integer program / combinatorial problem","text":"","category":"section"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"Algorithm.SolveIpForm\nAlgorithm.MoiOptimize\nAlgorithm.UserOptimize\nAlgorithm.CustomOptimize","category":"page"},{"location":"man/algorithm/#Coluna.Algorithm.SolveIpForm","page":"Built-in algorithms","title":"Coluna.Algorithm.SolveIpForm","text":"Coluna.Algorithm.SolveIpForm(\n    optimizer_id = 1\n    moi_params = MoiOptimize()\n    user_params = UserOptimize()\n    custom_params = CustomOptimize()\n)\n\nSolve an optimization problem. This algorithm can call different type of optimizers :\n\nsubsolver interfaced with MathOptInterface to optimize a mixed integer program\npricing callback defined by the user\ncustom optimizer to solve a custom model\n\nYou can specify an optimizer using the default_optimizer attribute of Coluna or with the method specify! from BlockDecomposition. If you want to define several optimizers for a given subproblem, you must use specify!:\n\nspecify!(subproblem, optimizers = [optimizer1, optimizer2, optimizer3])\n\nValue of optimizer_id is the position of the optimizer you want to use. For example, if optimizer_id is equal to 2, the algorithm will use optimizer2.\n\nBy default, the algorihm uses the first optimizer or the default optimizer if no optimizer has been specified through specify!.\n\nDepending on the type of the optimizer chosen, the algorithm will use one the  three configurations : \n\nmoi_params for subsolver interfaced with MathOptInterface\nuser_params for pricing callbacks\ncustom_params for custom solvers\n\nCustom solver is undocumented because alpha.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.MoiOptimize","page":"Built-in algorithms","title":"Coluna.Algorithm.MoiOptimize","text":"MoiOptimize(\n    time_limit = 600\n    deactivate_artificial_vars = false\n    enforce_integrality = false\n    get_dual_bound = true\n)\n\nConfiguration for an optimizer that calls a subsolver through MathOptInterface.\n\nParameters:\n\ntime_limit: in seconds\ndeactivate_artificial_vars: deactivate all artificial variables of the formulation if equals true\nenforce_integrality: enforce integer variables that are relaxed if equals true\nget_dual_bound: store the dual objective value in the output if equals true\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.UserOptimize","page":"Built-in algorithms","title":"Coluna.Algorithm.UserOptimize","text":"UserOptimize(\n    max_nb_ip_primal_sols = 50\n)\n\nConfiguration for an optimizer that calls a pricing callback to solve the problem.\n\nParameters:\n\nmax_nb_ip_primal_sols: maximum number of solutions returned by the callback kept\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/#Coluna.Algorithm.CustomOptimize","page":"Built-in algorithms","title":"Coluna.Algorithm.CustomOptimize","text":"CustomOptimize()\n\nConfiguration for an optimizer that calls a custom solver to solve a custom model.\n\n\n\n\n\n","category":"type"},{"location":"man/algorithm/","page":"Built-in algorithms","title":"Built-in algorithms","text":"","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"CurrentModule = Coluna","category":"page"},{"location":"api/colgen/#Column-generation","page":"ColGen","title":"Column generation","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna provides an interface and generic functions to implement a multi-stage column  generation algorithm together with a default implementation of this algorithm.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"In this section, we are first going to present the generic functions, the implementation  with some theory backgrounds and then give the references of the interface.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"You can find the generic functions and the interface in the ColGen submodule and the default  implementation in the Algorithm submodule at src/Algorithm/colgen.","category":"page"},{"location":"api/colgen/#Context","page":"ColGen","title":"Context","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The ColGen submodule provides an interface and generic functions to implement a column generation algorithm. The implementation depends on  an object called context.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.AbstractColGenContext","category":"page"},{"location":"api/colgen/#Coluna.ColGen.AbstractColGenContext","page":"ColGen","title":"Coluna.ColGen.AbstractColGenContext","text":"Supertype for the objects to which belongs the implementation of the column generation and  that stores any kind of information during the execution of the column generation algorithm.\n\nIMPORTANT: implementation of the column generation mainly depends on the context type.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna provides two types of context:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColGenContext\nColuna.Algorithm.ColGenPrinterContext","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColGenContext","page":"ColGen","title":"Coluna.Algorithm.ColGenContext","text":"ColGenContext(reformulation, algo_params) -> ColGenContext\n\nCreates a context to run the default implementation of the column generation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.Algorithm.ColGenPrinterContext","page":"ColGen","title":"Coluna.Algorithm.ColGenPrinterContext","text":"ColGenPrinterContext(reformulation, algo_params) -> ColGenPrinterContext\n\nCreates a context to run the default implementation of the column generation algorithm together with a printer that prints information about the algorithm execution.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Generic-functions","page":"ColGen","title":"Generic functions","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Generic functions are the core of the column generation algorithm. There are three generic functions:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.run!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.run!","page":"ColGen","title":"Coluna.ColGen.run!","text":"run!(ctx, env, ip_primal_sol; iter = 1) -> AbstractColGenOutput\n\nRuns the column generation algorithm.\n\nArguments are:\n\nctx: column generation context\nenv: Coluna environment\nip_primal_sol: current best primal solution to the master problem\niter: iteration number (default: 1)\n\nThis function is responsible for initializing the column generation context, the reformulation, and the stabilization. We iterate on the loop each time the phase or the stage changes.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"See the main loop section for more details.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.run_colgen_phase!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.run_colgen_phase!","page":"ColGen","title":"Coluna.ColGen.run_colgen_phase!","text":"run_colgen_phase!(ctx, phase, stage, env, ip_primal_sol, stab; iter = 1) -> AbstractColGenPhaseOutput\n\nRuns a phase of the column generation algorithm.\n\nArguments are:\n\nctx: column generation context\nphase: current column generation phase\nstage: current column generation stage\nenv: Coluna environment\nip_primal_sol: current best primal solution to the master problem\nstab: stabilization\niter: iteration number (default: 1)\n\nThis function is responsible for running the column generation iterations until the phase is finished.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"See the phase loop section for more details.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.run_colgen_iteration!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.run_colgen_iteration!","page":"ColGen","title":"Coluna.ColGen.run_colgen_iteration!","text":"run_colgen_iteration!(context, phase, stage, env, ip_primal_sol, stab) -> AbstractColGenIterationOutput\n\nRuns an iteration of column generation.\n\nArguments are:\n\ncontext: column generation context\nphase: current column generation phase\nstage: current column generation stage\nenv: Coluna environment\nip_primal_sol: current best primal solution to the master problem\nstab: stabilization\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"See the column generation iteration section for more details.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"They are independent of any other submodule of Coluna. You can use them to implement your own column generation algorithm.","category":"page"},{"location":"api/colgen/#Reformulation","page":"ColGen","title":"Reformulation","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The default implementation works with a reformulated problem contained in  MathProg.Reformulation where master and subproblems are MathProg.Formulation objects.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The master has the following form:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"beginaligned\nmin quad sum_k in K c^k lambda^k+barc y  \ntextst quad sum_k in K A^k lambda^k+barA y geq a   (1)\n l_k leq mathbf1 lambda^k leq u_k  (2) \n barl leq y leq baru  (3)\nendaligned","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"where lambda are the master columns, y are the pure master variables, constraints (1) are the linking constraints, constraints (2) are the convexity constraints that depend on l_k and u_k (e.g. the lower and upper multiplicity of the subproblem k respectively), and constraints (3) are the bounds on the pure master variables.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The subproblems have the following form:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"beginaligned\nmin quad cx + 0z \ntextst quad Bx geq b \n 1 leq z leq 1\nendaligned","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"where x are the subproblem variables, z is a setup variable that always takes the value one in a solution to the subproblem.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The coefficients of the columns in constraints (1) and (2) of the master are computed using representative variables of the subproblems.  You can read this section (TODO Natacha) to understand how we map the subproblem solutions into master columns.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.get_reform\nColuna.ColGen.get_master\nColuna.ColGen.get_pricing_subprobs\nColuna.ColGen.is_minimization","category":"page"},{"location":"api/colgen/#Coluna.ColGen.get_reform","page":"ColGen","title":"Coluna.ColGen.get_reform","text":"Returns Dantzig-Wolfe reformulation.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_master","page":"ColGen","title":"Coluna.ColGen.get_master","text":"Returns master formulation.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_pricing_subprobs","page":"ColGen","title":"Coluna.ColGen.get_pricing_subprobs","text":"get_pricing_subprobs(ctx) -> Vector{Tuple{SuproblemId, SpFormulation}}\n\nReturns subproblem formulations.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.is_minimization","page":"ColGen","title":"Coluna.ColGen.is_minimization","text":"Returns true if the objective sense is minimization; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Main-loop","page":"ColGen","title":"Main loop","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"This is a description of how the Coluna.ColGen.run! generic function behaves in the default implementation.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The main loop stops when the Coluna.ColGen.stop_colgen method returns true. This is the case when one of the following conditions holds: ","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"the master or a pricing subproblem is infeasible\nthe time limit is reached\nthe maximum number of iterations is reached","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Otherwise, the main loop runs until there is no more phase or stage to execute.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The method returns:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColGenOutput","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColGenOutput","page":"ColGen","title":"Coluna.Algorithm.ColGenOutput","text":"Output of the default implementation of the column generation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.stop_colgen\nColuna.ColGen.setup_reformulation!\nColuna.ColGen.setup_context!\nColuna.ColGen.AbstractColGenOutput\nColuna.ColGen.colgen_output_type\nColuna.ColGen.new_output","category":"page"},{"location":"api/colgen/#Coluna.ColGen.stop_colgen","page":"ColGen","title":"Coluna.ColGen.stop_colgen","text":"Returns true when the column generation algorithm must stop; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.setup_reformulation!","page":"ColGen","title":"Coluna.ColGen.setup_reformulation!","text":"Setup the reformulation for the given phase.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.setup_context!","page":"ColGen","title":"Coluna.ColGen.setup_context!","text":"Setup the context for the given phase.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.AbstractColGenOutput","page":"ColGen","title":"Coluna.ColGen.AbstractColGenOutput","text":"Supertype for the objects that contains the output of the column generation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.ColGen.colgen_output_type","page":"ColGen","title":"Coluna.ColGen.colgen_output_type","text":"colgen_output_type(ctx) -> Type{<:AbstractColGenOutput}\n\nReturns the type of the column generation output associated to the context.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.new_output","page":"ColGen","title":"Coluna.ColGen.new_output","text":"new_output(OutputType, colgen_phase_output) -> OutputType\n\nReturns the column generation output where colgen_phase_output is the output of the last column generation phase executed.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Phase-loop","page":"ColGen","title":"Phase loop","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"This is a description of how the Coluna.ColGen.run_colgen_phase! generic function behaves in the default implementation.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"This function is responsible for maintaining the incumbent dual bound and the incumbent master IP primal solution.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The phase loop stops when the Coluna.ColGen.stop_colgen_phase method returns true. This is the case when one of the following conditions holds:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"the maximum number of iterations is reached\nthe time limit is reached\nthe master is infeasible\nthe master is unbounded\na pricing subproblem is infeasible\na pricing subproblem is unbounded\nthere is no new column generated at the last iteration\nthere is a new constraint or valid inequality in the master\nthe incumbent dual bound and the primal master LP solution value converged","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The method returns:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColGenPhaseOutput","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColGenPhaseOutput","page":"ColGen","title":"Coluna.Algorithm.ColGenPhaseOutput","text":"Output of the default implementation of a phase of the column generation algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.stop_colgen_phase\nColuna.ColGen.before_colgen_iteration\nColuna.ColGen.after_colgen_iteration\nColuna.ColGen.is_better_dual_bound","category":"page"},{"location":"api/colgen/#Coluna.ColGen.stop_colgen_phase","page":"ColGen","title":"Coluna.ColGen.stop_colgen_phase","text":"Returns true if the column generation phase must stop.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.before_colgen_iteration","page":"ColGen","title":"Coluna.ColGen.before_colgen_iteration","text":"Placeholder method called before the column generation iteration. Does nothing by default but can be redefined to print some informations for instance. We strongly advise users against the use of this method to modify the context or the reformulation.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.after_colgen_iteration","page":"ColGen","title":"Coluna.ColGen.after_colgen_iteration","text":"Placeholder method called after the column generation iteration. Does nothing by default but can be redefined to print some informations for instance. We strongly advise users against the use of this method to modify the context or the reformulation.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.is_better_dual_bound","page":"ColGen","title":"Coluna.ColGen.is_better_dual_bound","text":"Returns true if new_dual_bound is better than dual_bound; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Phase-iterator","page":"ColGen","title":"Phase iterator","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"In the first iterations, the restricted master LP contains a few columns and may be infeasible. To prevent this, we introduced artificial variables v and we activate/deactivate these variables depending on whether we want to prove the infeasibility of the master LP or find the optimal LP solution. The default implementation provides three phases:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColGenPhase0\nColuna.Algorithm.ColGenPhase1\nColuna.Algorithm.ColGenPhase2","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColGenPhase0","page":"ColGen","title":"Coluna.Algorithm.ColGenPhase0","text":"Phase 0 is a mix of phase 1 and phase 2. It sets a very large cost to artifical variables to force them to be removed from the master  LP solution. If the final master LP solution contains artifical variables either the master is infeasible or the cost of artificial variables is not large enough. Phase 1 must be run.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.Algorithm.ColGenPhase1","page":"ColGen","title":"Coluna.Algorithm.ColGenPhase1","text":"Phase 1 sets the cost of variables to 0 except for artifical variables. The goal is to find a solution to the master LP problem that has no artificial variables.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.Algorithm.ColGenPhase2","page":"ColGen","title":"Coluna.Algorithm.ColGenPhase2","text":"Phase 2 solves the master LP without artificial variables. To start, it requires a set of columns that forms a feasible solution to the LP master. This set is found with phase 1.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Column generation always starts with Phase 0.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The default implementation of the phase iterator belongs to the following type:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColunaColGenPhaseIterator","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColunaColGenPhaseIterator","page":"ColGen","title":"Coluna.Algorithm.ColunaColGenPhaseIterator","text":"Type for the default implementation of the sequence of phases.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Transitions between the phases depend on four conditions:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"(A) the presence of artificial variables in the master LP solution\n(B) the generation of new essential constraints (may happen when a new master IP solution is found)\n(C) the current stage is exact\n(D) column generation converged ","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Transitions are the following:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"flowchart TB;\n    id1(Phase 0)\n    id2(Phase 1)\n    id3(Phase 2)\n    id4(end)\n    id5(error)\n    id1 --A & !B & C--> id2\n    id1 --!A & !B & C & D--> id4\n    id1 -- otherwise --> id1\n    id2 --!A & !B--> id3\n    id2 --A & C & D--> id4\n    id2 -- otherwise --> id2\n    id3 -- !B & C & D --> id4\n    id3 -- otherwise --> id3\n    id3 -- B --> id2\n    id3 -- A --> id5\n    style id5 stroke:#f66","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.AbstractColGenPhase\nColuna.ColGen.AbstractColGenPhaseIterator\nColuna.ColGen.new_phase_iterator\nColuna.ColGen.initial_phase\nColuna.ColGen.decrease_stage\nColuna.ColGen.next_phase","category":"page"},{"location":"api/colgen/#Coluna.ColGen.AbstractColGenPhase","page":"ColGen","title":"Coluna.ColGen.AbstractColGenPhase","text":"A phase of the column generation. Each phase is associated with a specific set up of the reformulation.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.ColGen.AbstractColGenPhaseIterator","page":"ColGen","title":"Coluna.ColGen.AbstractColGenPhaseIterator","text":"An iterator that indicates how phases follow each other.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.ColGen.new_phase_iterator","page":"ColGen","title":"Coluna.ColGen.new_phase_iterator","text":"Returns a new phase iterator.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.initial_phase","page":"ColGen","title":"Coluna.ColGen.initial_phase","text":"Returns the phase with which the column generation algorithm must start.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.decrease_stage","page":"ColGen","title":"Coluna.ColGen.decrease_stage","text":"Returns the next stage involving a \"more exact solver\" than the current one. Returns nothing if the algorithm has already reached the exact phase (last phase).\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.next_phase","page":"ColGen","title":"Coluna.ColGen.next_phase","text":"Returns the next phase of the column generation algorithm. Returns nothing if the algorithm must stop.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Phase-output","page":"ColGen","title":"Phase output","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.AbstractColGenPhaseOutput\nColuna.ColGen.colgen_phase_output_type\nColuna.ColGen.new_phase_output","category":"page"},{"location":"api/colgen/#Coluna.ColGen.AbstractColGenPhaseOutput","page":"ColGen","title":"Coluna.ColGen.AbstractColGenPhaseOutput","text":"Supertype for the objects that contains the output of a column generation phase.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.ColGen.colgen_phase_output_type","page":"ColGen","title":"Coluna.ColGen.colgen_phase_output_type","text":"colgen_phase_outputype(ctx) -> Type{<:AbstractColGenPhaseOutput}\n\nReturns the type of the column generation phase output associated to the context.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.new_phase_output","page":"ColGen","title":"Coluna.ColGen.new_phase_output","text":"new_phase_output(OutputType, min_sense, phase, stage, colgen_iter_output, iter, inc_dual_bound) -> OutputType\n\nReturns the column generation phase output.\n\nArguments of this function are:\n\nOutputType: the type of the column generation phase output\nmin_sense: true if it is a minimization problem; false otherwise\nphase: the current column generation phase\nstage: the current column generation stage\ncol_gen_iter_output: the last column generation iteration output\niter: the last iteration number\ninc_dual_bound: the current incumbent dual bound\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Stages","page":"ColGen","title":"Stages","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"A stage is a set of consecutive iterations in which we use a given pricing solver. The aim is to speed up the resolution of the pricing problem by first using an approximate but fast pricing algorithm and then switching to increasingly less heuristic algorithms until the last stage where an exact solver is used. and an exact solver at the last stage. Given a pricing solver, when the column generation does not progress anymore or the pricing solver does not return any new column, the default implementation switch to a more exact pricing solver. Stages are created using the stages_pricing_solver_ids of the ColumnGenerationAlgorithm parameter object. The default implementation implements the interface around the following object:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColGenStageIterator","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColGenStageIterator","page":"ColGen","title":"Coluna.Algorithm.ColGenStageIterator","text":"Default implementation of the column generation stages works as follows.\n\nConsider a set {A,B,C} of subproblems each of them associated to the following sets of pricing solvers: {a1, a2, a3}, {b1, b2}, {c1, c2, c3, c4}. Pricing solvers a1, b1, c1 are exact solvers; others are heuristic.\n\nThe column generation algorithm will run the following stages:\n\nstage 4 with pricing solvers {a3, b2, c4}\nstage 3 with pricing solvers {a2, b1, c3}\nstage 2 with pricing solvers {a1, b1, c2}\nstage 1 with pricing solvers {a1, b1, c1} (exact stage)\n\nColumn generation moves from one stage to another when all solvers find no column.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.AbstractColGenStage\nColuna.ColGen.AbstractColGenStageIterator\nColuna.ColGen.new_stage_iterator\nColuna.ColGen.initial_stage\nColuna.ColGen.next_stage\nColuna.ColGen.get_pricing_subprob_optimizer\nColuna.ColGen.stage_id\nColuna.ColGen.is_exact_stage","category":"page"},{"location":"api/colgen/#Coluna.ColGen.AbstractColGenStage","page":"ColGen","title":"Coluna.ColGen.AbstractColGenStage","text":"A stage of the column generation algorithm. Each stage is associated to a specific solver for each pricing subproblem.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.ColGen.AbstractColGenStageIterator","page":"ColGen","title":"Coluna.ColGen.AbstractColGenStageIterator","text":"An iterator that indicates how stages follow each other.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.ColGen.new_stage_iterator","page":"ColGen","title":"Coluna.ColGen.new_stage_iterator","text":"Returns a new stage iterator.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.initial_stage","page":"ColGen","title":"Coluna.ColGen.initial_stage","text":"Returns the stage at which the column generation algorithm must start.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.next_stage","page":"ColGen","title":"Coluna.ColGen.next_stage","text":"Returns the next stage that column generation must use.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_pricing_subprob_optimizer","page":"ColGen","title":"Coluna.ColGen.get_pricing_subprob_optimizer","text":"Returns the optimizer for the pricing subproblem associated to the given stage.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.stage_id","page":"ColGen","title":"Coluna.ColGen.stage_id","text":"Returns the id of the stage.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.is_exact_stage","page":"ColGen","title":"Coluna.ColGen.is_exact_stage","text":"Returns true if the stage uses an exact solver for the pricing subproblem; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Column-generation-iteration","page":"ColGen","title":"Column generation iteration","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"This is a description of how the Coluna.ColGen.run_colgen_iteration! generic function behaves in the default implementation.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"These are the main steps of a column generation iteration without stabilization. Click on the step to go to the relevant section.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"flowchart TB;\n    id1(Optimize master LP)\n    id2{{Solution to master LP is integer?}}\n    id3(Update incumbent primal solution if better than current one)\n    id4(Compute reduced cost of subproblem variables)\n    id5{{Subproblem iterator}}\n    id6(Optimize pricing subproblem)\n    id7(Push subproblem solution into set)\n    id8(Compute dual bound)\n    id9(Insert columns)\n    id10(Iteration output)\n    id1 --> id2\n    id2 --yes--> id3\n    id2 --no--> id4\n    id3 --> id4\n    id4 --> id5\n    id5 --subproblem--> id6\n    id6 --> id7\n    id7 --> id5\n    id5 --end--> id8\n    id8 --> id9\n    id9 --> id10\n    click id1 href \"#Optimize-master-LP\" \"Link to doc\"\n    click id2 href \"#Check-integrality-of-the-master-LP-solution\" \"Link to doc\"\n    click id3 href \"#Update-incumbent-primal-solution\" \"Link to doc\"\n    click id4 href \"#Reduced-costs-calculation\" \"Link to doc\"\n    click id5 href \"#Pricing-subproblem-iterator\" \"Link to doc\"\n    click id6 href \"#Pricing-subproblem-optimization\" \"Link to doc\"\n    click id7 href \"#Set-of-generated-columns\" \"Link to doc\"\n    click id8 href \"#Dual-bound-calculation\" \"Link to doc\"\n    click id9 href \"#Columns-insertion\" \"Link to doc\"\n    click id10 href \"#Iteration-output\" \"Link to doc\"","category":"page"},{"location":"api/colgen/#Optimize-master-LP","page":"ColGen","title":"Optimize master LP","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"At each iteration, the algorithm requires a dual solution to the master LP to compute the reduced cost of subproblem variables.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The default implementation optimizes the master with an LP solver through MathOptInterface. It returns a primal and a dual solution.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"In the default implementation, the master LP output is in the following data structure:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColGenMasterResult","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColGenMasterResult","page":"ColGen","title":"Coluna.Algorithm.ColGenMasterResult","text":"Output of the ColGen.optimize_master_lp_problem! method.\n\nContains result, an OptimizationState object that is the output of the SolveLpForm algorithm called to optimize the master LP problem.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.optimize_master_lp_problem!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.optimize_master_lp_problem!","page":"ColGen","title":"Coluna.ColGen.optimize_master_lp_problem!","text":"optimize_master_lp_problem!(master, context, env) -> MasterResult\n\nReturns an instance of a custom object MasterResult that implements the following methods:\n\nget_obj_val: objective value of the master (mandatory)\nget_primal_sol: primal solution to the master (optional)\nget_dual_sol: dual solution to the master (mandatory otherwise column generation stops)\n\nIt should at least return a dual solution (obtained with LP optimization or subgradient)  otherwise column generation cannot continue.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"You can see the additional methods to implement in the result data structures section.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Check-the-integrality-of-the-master-LP-solution","page":"ColGen","title":"Check the integrality of the master LP solution","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The algorithm checks the integrality of the primal solution to the master LP to improve the global primal bound of the branch-cut-price algorithm.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"In the default implementation, the integrality check is done using the MathProg.proj_cols_is_integer method. It implements the procedure described in the paper (TODO). Basically, it sorts the column used in the master LP primal solution in lexicographic order.  It assigns a weight to each column equal to the value of the column in the master LP solution.  It then forms columns of weight one by accumulating the columns of the fractional solution.  If columns are integral, the solution is integral. This is a heuristic procedure so it can miss some integer solutions.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"If the solution is integral, the essential cut callback is called to make sure it is feasible.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.check_primal_ip_feasibility!\nColuna.ColGen.is_better_primal_sol","category":"page"},{"location":"api/colgen/#Coluna.ColGen.check_primal_ip_feasibility!","page":"ColGen","title":"Coluna.ColGen.check_primal_ip_feasibility!","text":"Returns a primal solution expressed in the original problem variables if the current master LP solution is integer feasible; nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.is_better_primal_sol","page":"ColGen","title":"Coluna.ColGen.is_better_primal_sol","text":"Returns true if the new master IP primal solution is better than the current; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Update-incumbent-primal-solution","page":"ColGen","title":"Update incumbent primal solution","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"If the solution to master LP is integral and better than the current best one,  we need to update the incumbent. This solution is then used by the tree-search algorithm in the  bounding mechanism that prunes the nodes.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.update_inc_primal_sol!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.update_inc_primal_sol!","page":"ColGen","title":"Coluna.ColGen.update_inc_primal_sol!","text":"Updates the current master IP primal solution.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Reduced-costs-calculation","page":"ColGen","title":"Reduced costs calculation","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Reduced costs calculation is written as a math operation in the run_colgen_iteration!  generic function. As a consequence, the dual solution to the master LP and the  implementation of the two following methods must return data structures that support math operations.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"To speed up this operation, we cache data in the following data structure:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ReducedCostsCalculationHelper","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ReducedCostsCalculationHelper","page":"ColGen","title":"Coluna.Algorithm.ReducedCostsCalculationHelper","text":"Extracted information to speed-up calculation of reduced costs of subproblem representatives and pure master variables. We extract from the master the information we need to compute the reduced cost of DW  subproblem variables:\n\ndw_subprob_c contains the perenial cost of DW subproblem representative variables\ndw_subprob_A is a submatrix of the master coefficient matrix that involves only DW subproblem representative variables.\n\nWe also extract from the master the information we need to compute the reduced cost of pure master variables:\n\npure_master_c contains the perenial cost of pure master variables\npure_master_A is a submatrix of the master coefficient matrix that involves only pure master variables.\n\nCalculation is c - transpose(A) * master_lp_dual_solution.\n\nThis information is given to the generic implementation of the column generation algorithm through methods:\n\nColGen.getsubprobvarorigcosts \nColGen.getorigcoefmatrix\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Reduced costs calculation also requires the implementation of the two following methods:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.update_master_constrs_dual_vals!\nColuna.ColGen.update_reduced_costs!\nColuna.ColGen.get_subprob_var_orig_costs\nColuna.ColGen.get_subprob_var_coef_matrix\nColuna.ColGen.update_sp_vars_red_costs!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.update_master_constrs_dual_vals!","page":"ColGen","title":"Coluna.ColGen.update_master_constrs_dual_vals!","text":"Updates dual value of the master constraints. Dual values of the constraints can be used when the pricing solver supports non-robust cuts.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.update_reduced_costs!","page":"ColGen","title":"Coluna.ColGen.update_reduced_costs!","text":"Method that you can implement if you want to store the reduced cost of subproblem variables in the context.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_subprob_var_orig_costs","page":"ColGen","title":"Coluna.ColGen.get_subprob_var_orig_costs","text":"Returns the original cost c of subproblems variables. to compute reduced cost ̄c = c - transpose(A) * π.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_subprob_var_coef_matrix","page":"ColGen","title":"Coluna.ColGen.get_subprob_var_coef_matrix","text":"Returns the coefficient matrix A of subproblem variables in the master to compute reduced cost ̄c = c - transpose(A) * π.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.update_sp_vars_red_costs!","page":"ColGen","title":"Coluna.ColGen.update_sp_vars_red_costs!","text":"Updates reduced costs of variables of a given subproblem.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Pricing-subproblem-iterator","page":"ColGen","title":"Pricing subproblem iterator","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The pricing strategy is basically an iterator used to iterate over the pricing subproblems to optimize at each iteration of the column generation. The context can serve as a memory of the pricing strategy to change the way we iterate over subproblems between each column generation iteration.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The default implementation iterates over all subproblems.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Here are the references for the interface:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.AbstractPricingStrategy\nColuna.ColGen.get_pricing_strategy\nColuna.ColGen.pricing_strategy_iterate","category":"page"},{"location":"api/colgen/#Coluna.ColGen.AbstractPricingStrategy","page":"ColGen","title":"Coluna.ColGen.AbstractPricingStrategy","text":"A pricing strategy defines how we iterate on pricing subproblems. A default pricing strategy consists in iterating on all pricing subproblems.\n\nBasically, this object is used like this:\n\n    pricing_strategy = ColGen.get_pricing_strategy(ctx, phase)\n    next = ColGen.pricing_strategy_iterate(pricing_strategy)\n    while !isnothing(next)\n        (sp_id, sp_to_solve), state = next\n        # Solve the subproblem `sp_to_solve`.\n        next = ColGen.pricing_strategy_iterate(pricing_strategy, state)\n    end\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.ColGen.get_pricing_strategy","page":"ColGen","title":"Coluna.ColGen.get_pricing_strategy","text":"get_pricing_strategy(ctx, phase) -> AbstractPricingStrategy\n\nReturns the pricing strategy object.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.pricing_strategy_iterate","page":"ColGen","title":"Coluna.ColGen.pricing_strategy_iterate","text":"pricing_strategy_iterate(pricing_strategy) -> ((sp_id, sp_to_solve), state)\npricing_strategy_iterate(pricing_strategy, state) -> ((sp_id, sp_to_solve), state)\n\nReturns an iterator with the first pricing subproblem that must be optimized. The next subproblem is returned by a call to Base.iterate using the information provided by this method.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Pricing-subproblem-optimization","page":"ColGen","title":"Pricing subproblem optimization","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"At each iteration, the algorithm requires primal solutions to the pricing subproblems. The generic function supports multi-column generation so you can return any number of solutions.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The default implementation supports optimization of the pricing subproblems using a MILP solver or a pricing callback. Non-robust valid inequalities are not supported by MILP solvers as they change the structure of the subproblems. When using a pricing callback, you must be aware of how Coluna calculates the reduced cost of a column:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The reduced cost of a column is split into three contributions:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"the contribution of the subproblem variables that is the primal solution cost given the reduced cost of subproblem variables\nthe contribution of the non-robust constraints (i.e. master constraints that cannot be expressed using subproblem variables except the convexity constraint) that is not supported by MILP solver but that you must take into account in the pricing callback\nthe contribution of the master convexity constraint that is automatically taken into account by Coluna once the primal solution is returned.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Therefore, when you use a pricing callback, you must not discard some columns based only on the primal solution cost because you don't know the contribution of the convexity constraint.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.GeneratedColumn    \nColuna.Algorithm.ColGenPricingResult","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.GeneratedColumn","page":"ColGen","title":"Coluna.Algorithm.GeneratedColumn","text":"Solution to a pricing subproblem after a given optimization.\n\nIt contains:\n\ncolumn: the solution stored as a PrimalSolution object\nred_cost: the reduced cost of the column\nmin_obj: a boolean indicating if the objective is to minimize or maximize\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.Algorithm.ColGenPricingResult","page":"ColGen","title":"Coluna.Algorithm.ColGenPricingResult","text":"Output of the default implementation of ColGen.optimize_pricing_problem!.\n\nIt contains:\n\nresult: the output of the SolveIpForm algorithm called to optimize the pricing subproblem\ncolumns: a vector of GeneratedColumn objects obtained by processing of the output of pricing subproblem optimization, it stores the reduced cost of each column\nbest_red_cost: the best reduced cost of the columns\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.optimize_pricing_problem!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.optimize_pricing_problem!","page":"ColGen","title":"Coluna.ColGen.optimize_pricing_problem!","text":"optimize_pricing_problem!(ctx, sp, env, optimizer, mast_dual_sol) -> PricingResult\n\nReturns a custom object PricingResult that must implement the following functions:\n\nget_primal_sols: array of primal solution to the pricing subproblem \nget_primal_bound: best reduced cost (optional ?)\nget_dual_bound: dual bound of the pricing subproblem (used to compute the master dual bound)\nmaster_dual_sol: dual solution pi^textout to the master problem used to compute the real reduced cost of the column when stabilization is active\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"You can see the additional methods to implement in the result data structures section.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Set-of-generated-columns","page":"ColGen","title":"Set of generated columns","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"You can define your data structure to manage the columns generated at a given iteration. Columns are inserted after the optimization of all pricing subproblems to allow the parallelization of the latter.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"In the default implementation, we use the following data structure:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColumnsSet\nColuna.Algorithm.SubprobPrimalSolsSet","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColumnsSet","page":"ColGen","title":"Coluna.Algorithm.ColumnsSet","text":"Stores a collection of columns.\n\nIt contains:\n\ncolumns: a vector of GeneratedColumn objects by all pricing subproblems that will be inserted into the master\nsubprob_primal_solutions: an object that stores the best columns generated by each pricing subproblem at this iteration.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.Algorithm.SubprobPrimalSolsSet","page":"ColGen","title":"Coluna.Algorithm.SubprobPrimalSolsSet","text":"Columns generated at the current iteration that forms the \"current primal solution\". This is used to compute the Lagragian dual bound.\n\nIt contains:\n\nprimal_sols a dictionary that maps a formulation id to the best primal solution found by the pricing subproblem associated to this formulation\nimprove_master a dictionary that maps a formulation id to a boolean indicating if the best primal solution found by the pricing subproblem associated to this formulation has negative reduced cost\n\nThis structure also helps to compute the subgradient of the Lagrangian function.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"In the default implementation, push_in_set! is responsible for checking if the column has improving reduced cost. Only columns with improving reduced cost are inserted in the set. The push_in_set! is also responsible to insert he best primal solution to each pricing problem into the SubprobPrimalSolsSet object.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.set_of_columns\nColuna.ColGen.push_in_set!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.set_of_columns","page":"ColGen","title":"Coluna.ColGen.set_of_columns","text":"Returns an empty container that will store all the columns generated by the pricing problems during an iteration of the column generation algorithm. One must be able to iterate on this container to insert the columns in the master problem.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.push_in_set!","page":"ColGen","title":"Coluna.ColGen.push_in_set!","text":"Pushes the column in the set of columns generated at a given iteration of the column generation algorithm. Columns stored in the set will then be considered for insertion in the master problem. Returns true if column was inserted in the set, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Dual-bound-calculation","page":"ColGen","title":"Dual bound calculation","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"In the default implementation,  given a vector pi geq 0 of dual values to the master constraints (1), the Lagrangian  dual function is given by:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"L(pi) = pi a + sum_k in K max_l_k leq mathbf1 lambda^k leq u^k (c^k - pi A^k)lambda^k + max_ barl leq y leq baru (barc - pi barA)y","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Let:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"element z_k(pi) leq min_i (c^k_i - pi A^k_i) be a lower bound on the solution value of the pricing problem\nelement barz_j(pi) = barc - pi barA be the reduced cost of pure master variable y_j","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Then, the Lagrangian dual function can be lower bounded by:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"L(pi) geq pi a + sum_k in K max z_k(pi) cdot l_k  z_k(pi) cdot u_k   + sum_j in J  max barz_j(pi) cdot barl_j  barz_j(pi) cdot baru_j","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"More precisely:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"the first term is the contribution of the master obtained by removing the contribution of the convexity constraints (computed by ColGen.Algorithm._convexity_contrib), and the pure master variables (but you should see the third term) from the master LP solution value\nthe second term is the contribution of the subproblem variables which is the sum of the best solution value of each pricing subproblem multiplied by the lower and upper multiplicity of the subproblem depending on whether the reduced cost is negative or positive (this is computed by ColGen.Algorithm._subprob_contrib)\nthe third term is the contribution of the pure master variables which is taken into account by master LP value.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Therefore, we can compute the Lagrangian dual bound as follows:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"master_lp_obj_val - convexity_contrib + sp_contrib","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"However, if the smoothing stabilization is active, we compute the dual bound at the sep-point. As a consequence, we can't use the master LP value because it corresponds to the dual solution at the out-point. We therefore need to compute the lagrangian dual bound by strictly applying the above formula.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.compute_sp_init_pb\nColuna.ColGen.compute_sp_init_db\nColuna.ColGen.compute_dual_bound","category":"page"},{"location":"api/colgen/#Coluna.ColGen.compute_sp_init_pb","page":"ColGen","title":"Coluna.ColGen.compute_sp_init_pb","text":"Returns an initial primal bound for a pricing subproblem. Default value should be +/- infinite depending on the optimization sense.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.compute_sp_init_db","page":"ColGen","title":"Coluna.ColGen.compute_sp_init_db","text":"Returns an initial dual bound for a pricing subproblem. Default value should be +/- infinite depending on the optimization sense.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.compute_dual_bound","page":"ColGen","title":"Coluna.ColGen.compute_dual_bound","text":"compute_dual_bound(ctx, phase, master_lp_obj_val, master_dbs, generated_columns, mast_dual_sol) -> Float64\n\nCaculates the dual bound at a given iteration of column generation. The dual bound is composed of:\n\nmaster_lp_obj_val: objective value of the master LP problem\nmaster_dbs: dual values of the pricing subproblems\nthe contribution of the master convexity constraints that you should compute from mast_dual_sol.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Columns-insertion","page":"ColGen","title":"Columns insertion","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"The default implementation inserts into the master all the columns stored in the ColumnsSet object.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Reference:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.insert_columns!","category":"page"},{"location":"api/colgen/#Coluna.ColGen.insert_columns!","page":"ColGen","title":"Coluna.ColGen.insert_columns!","text":"Inserts columns into the master. Returns the number of columns inserted. Implementation is responsible for checking if the column must be inserted and warn the user if something unexpected happens.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Iteration-output","page":"ColGen","title":"Iteration output","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.ColGenIterationOutput","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.ColGenIterationOutput","page":"ColGen","title":"Coluna.Algorithm.ColGenIterationOutput","text":"Object for the output of an iteration of the column generation default implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.AbstractColGenIterationOutput\nColuna.ColGen.colgen_iteration_output_type\nColuna.ColGen.new_iteration_output","category":"page"},{"location":"api/colgen/#Coluna.ColGen.AbstractColGenIterationOutput","page":"ColGen","title":"Coluna.ColGen.AbstractColGenIterationOutput","text":"Supertype for the objects that contains the output of a column generation iteration.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/#Coluna.ColGen.colgen_iteration_output_type","page":"ColGen","title":"Coluna.ColGen.colgen_iteration_output_type","text":"colgen_iteration_output_type(ctx) -> Type{<:AbstractColGenIterationOutput}\n\nReturns the type of the column generation iteration output associated to the context.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.new_iteration_output","page":"ColGen","title":"Coluna.ColGen.new_iteration_output","text":"new_iteration_output(::Type{<:AbstractColGenIterationOutput}, args...) -> AbstractColGenIterationOutput\n\nArguments (i.e. arg...) of this function are the following:\n\nmin_sense: true if the objective is a minimization function; false otherwise\nmlp: the optimal solution value of the master LP\ndb: the Lagrangian dual bound\nnb_new_cols: the number of columns inserted into the master\nnew_cut_in_master: true if valid inequalities or new constraints added into the master; false otherwise\ninfeasible_master: true if the master is proven infeasible; false otherwise\nunbounded_master: true if the master is unbounded; false otherwise\ninfeasible_subproblem: true if a pricing subproblem is proven infeasible; false otherwise\nunbounded_subproblem: true if a pricing subproblem is unbounded; false otherwise\ntime_limit_reached: true if time limit is reached; false otherwise\nmaster_primal_sol: the primal master LP solution\nip_primal_sol: the incumbent primal master solution\ndual_sol: the dual master LP solution\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Getters-for-Result-data-structures","page":"ColGen","title":"Getters for Result data structures","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Method name Master Pricing\nis_unbounded X X\nis_infeasible X X\nget_primal_sol X \nget_primal_sols  X\nget_dual_sol X \nget_obj_val X \nget_primal_bound  X\nget_dual_bound  X","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.is_unbounded\nColuna.ColGen.is_infeasible\nColuna.ColGen.get_primal_sol\nColuna.ColGen.get_primal_sols\nColuna.ColGen.get_dual_sol\nColuna.ColGen.get_obj_val\nColuna.ColGen.get_primal_bound","category":"page"},{"location":"api/colgen/#Coluna.ColGen.is_unbounded","page":"ColGen","title":"Coluna.ColGen.is_unbounded","text":"Returns true if a master or pricing problem result is unbounded; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.is_infeasible","page":"ColGen","title":"Coluna.ColGen.is_infeasible","text":"Returns true if a master or pricing problem result is infeasible; false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_primal_sol","page":"ColGen","title":"Coluna.ColGen.get_primal_sol","text":"Returns primal solution to the master LP problem.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_primal_sols","page":"ColGen","title":"Coluna.ColGen.get_primal_sols","text":"Array of primal solutions to the pricing subproblem\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_dual_sol","page":"ColGen","title":"Coluna.ColGen.get_dual_sol","text":"Returns dual solution to the master optimization problem.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_obj_val","page":"ColGen","title":"Coluna.ColGen.get_obj_val","text":"Returns the optimal objective value of the master LP problem.\" See optimize_master_lp_problem!.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_primal_bound","page":"ColGen","title":"Coluna.ColGen.get_primal_bound","text":"Returns primal bound of the pricing subproblem; nothing if no primal bound is available and the initial dual bound returned by compute_sp_init_pb will be used to compute the pseudo dual bound.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Getters-for-Output-data-structures","page":"ColGen","title":"Getters for Output data structures","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Method name ColGen Phase Iteration\nget_nb_new_cols   X\nget_master_ip_primal_sol X X X\nget_master_lp_primal_sol X  \nget_master_dual_sol X  \nget_dual_bound X  X\nget_master_lp_primal_bound X  \nis_infeasible X  ","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.get_nb_new_cols\nColuna.ColGen.get_master_ip_primal_sol\nColuna.ColGen.get_master_lp_primal_sol\nColuna.ColGen.get_master_dual_sol\nColuna.ColGen.get_master_lp_primal_bound","category":"page"},{"location":"api/colgen/#Coluna.ColGen.get_nb_new_cols","page":"ColGen","title":"Coluna.ColGen.get_nb_new_cols","text":"Returns the number of new columns inserted into the master at the end of an iteration.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_master_ip_primal_sol","page":"ColGen","title":"Coluna.ColGen.get_master_ip_primal_sol","text":"Returns the incumbent primal master IP solution at the end of an iteration or a phase.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_master_lp_primal_sol","page":"ColGen","title":"Coluna.ColGen.get_master_lp_primal_sol","text":"Returns the primal master LP solution found at the last iteration of the column generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_master_dual_sol","page":"ColGen","title":"Coluna.ColGen.get_master_dual_sol","text":"Returns the dual master LP solution found at the last iteration of the column generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_master_lp_primal_bound","page":"ColGen","title":"Coluna.ColGen.get_master_lp_primal_bound","text":"Returns the master LP solution value at the last iteration of the column generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Go back to the column generation iteration overview.","category":"page"},{"location":"api/colgen/#Stabilization","page":"ColGen","title":"Stabilization","text":"","category":"section"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna provides a default implementation of the smoothing stabilization with a self-adjusted alpha parameter, 0 leq alpha  1.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"At each iteration of the column generation algorithm, instead of generating columns for the dual solution to the master LP, we generate columns for a perturbed dual solution defined as follows:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"pi^textsep = alpha pi^textin + (1-alpha) pi^textout","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"where pi^textin is the dual solution that gives the best Lagrangian dual bound so far (also called stabilization center) and pi^textout is the dual solution to the master LP at the current iteration.  This solution is returned by the default implementation of Coluna.ColGen.get_stab_dual_sol.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Some elements of the column generation change when using stabilization.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Columns are generated using the smoothed dual solution pi^textsep but we still need to compute the reduced cost of the columns using the original dual solution pi^textout.\nThe dual bound is computed using the smoothed dual solution pi^textsep.\nThe pseudo bound is computed using the smoothed dual solution pi^textsep.\nThe smoothed dual bound can result in the generation of no improving columns. This is called a misprice. In that case, we need to move away from the stabilization center pi^textin by decreasing alpha.","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"When using self-adjusted stabilization, the smoothing coefficient alpha is adjusted to make the smoothed dual solution pi^textsep closer to the best possible dual solution on the line between pi^textin and pi^textout (i.e. where the subgradient of the current primal solution is perpendicular to the latter line). To compute the subgradient, we use the following data structure:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.Algorithm.SubgradientCalculationHelper","category":"page"},{"location":"api/colgen/#Coluna.Algorithm.SubgradientCalculationHelper","page":"ColGen","title":"Coluna.Algorithm.SubgradientCalculationHelper","text":"Precompute information to speed-up calculation of subgradient of master variables. We extract from the master follwowing information:\n\na contains the perenial rhs of all master constraints except convexity constraints;\nA is a submatrix of the master coefficient matrix that involves only representative of original variables (pure master vars + DW subproblem represtative vars) \n\nCalculation is a - A * (m .* z) where :\n\nm contains a multiplicity factor for each variable involved in the calculation     (lower or upper sp multiplicity depending on variable reduced cost);\nz is the concatenation of the solution to the master (for pure master vars) and pricing     subproblems (for DW subproblem represtative vars).\n\nOperation m .* z \"mimics\" a solution in the original space.\n\n\n\n\n\n","category":"type"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"References:","category":"page"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"Coluna.ColGen.setup_stabilization!\nColuna.ColGen.update_stabilization_after_master_optim!\nColuna.ColGen.get_stab_dual_sol\nColuna.ColGen.check_misprice\nColuna.ColGen.update_stabilization_after_pricing_optim!\nColuna.ColGen.update_stabilization_after_misprice!\nColuna.ColGen.update_stabilization_after_iter!\nColuna.ColGen.get_output_str","category":"page"},{"location":"api/colgen/#Coluna.ColGen.setup_stabilization!","page":"ColGen","title":"Coluna.ColGen.setup_stabilization!","text":"Returns an instance of a data structure that contain information about the stabilization used in the column generation algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.update_stabilization_after_master_optim!","page":"ColGen","title":"Coluna.ColGen.update_stabilization_after_master_optim!","text":"update_stabilization_after_master_optim!(stab, phase, mast_dual_sol) -> Bool\n\nUpdate stabilization after master optimization where mast_dual_sol is the dual solution to the master problem. Returns true if the stabilization will change the dual solution used for the pricing in the current  column generation iteration, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_stab_dual_sol","page":"ColGen","title":"Coluna.ColGen.get_stab_dual_sol","text":"Returns the dual solution used for the pricing in the current column generation iteration (stabilized dual solution).\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.check_misprice","page":"ColGen","title":"Coluna.ColGen.check_misprice","text":"Returns true if the stabilized dual solution leads to a misprice, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.update_stabilization_after_pricing_optim!","page":"ColGen","title":"Coluna.ColGen.update_stabilization_after_pricing_optim!","text":"Updates stabilization after pricing optimization where:\n\nmast_dual_sol is the dual solution to the master problem\npseudo_db is the pseudo dual bound of the problem after optimization of the pricing problems\nsmooth_dual_sol is the current smoothed dual solution\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.update_stabilization_after_misprice!","page":"ColGen","title":"Coluna.ColGen.update_stabilization_after_misprice!","text":"Updates stabilization after a misprice. Argument mast_dual_sol is the dual solution to the master problem.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.update_stabilization_after_iter!","page":"ColGen","title":"Coluna.ColGen.update_stabilization_after_iter!","text":"Updates stabilization after an iteration of the column generation algorithm. Arguments:\n\nstab is the stabilization data structure\nctx is the column generation context\nmaster is the master problem\ngenerated_columns is the set of generated columns\nmast_dual_sol is the dual solution to the master problem\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/#Coluna.ColGen.get_output_str","page":"ColGen","title":"Coluna.ColGen.get_output_str","text":"Returns a string with a short information about the stabilization.\n\n\n\n\n\n","category":"function"},{"location":"api/colgen/","page":"ColGen","title":"ColGen","text":"","category":"page"},{"location":"api/presolve/#Presolve","page":"Presolve","title":"Presolve","text":"","category":"section"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"Currently, the presolve algorithm supports only the Dantzig-Wolfe decomposition.","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"The presolve algorithm operates on matrix representations of the formulation. It requires two representations of the master formulation:","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"the restricted master that contains master column variables, pure master variables and artificial variables;\nthe representative master that contains subproblem representative variables and pure master variables;","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"and the representation of the pricing subproblems.","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"The current presolve operations available are the following (taxonomy of Achterberg et al. 2016):","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"model cleanup & removal of redundant constraints\nbound strengthening\nremoval of fixed variables","category":"page"},{"location":"api/presolve/#Partial-solution","page":"Presolve","title":"Partial solution","text":"","category":"section"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"The presolve algorithm has the responsibility to define and fix a partial solution when it exists. When a variable x  has a value barx  0 (resp. barx  0) in the partial solution,  it means that x has a lower (resp. upper) bounds barx that will definitely be part of the solution at the current branch-and-bound node and its successors.","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"In other words, the partial solution describes a minimal distance of the variables from zero in the all the solutions to a problem at a given branch-and-bound node. It always restricts the domain of the variables (i.e. increase distance from zero). The only way to relax the domains is to backtrack to an ancestor of the current branch-and-bound node (i.e. go back to a previous partial solution).","category":"page"},{"location":"api/presolve/#Augmenting-the-partial-solution","page":"Presolve","title":"Augmenting the partial solution","text":"","category":"section"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"Consider a local partial solution (barx^rm pure barlambda) (where barx^rm pure is the vector of values for pure master variables, and barlambda is the vector of values for master columns), which should be added to the global partial solution (bary^rm pure bartheta): ","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"augment the global partial solution: (bary^rm pure bartheta)leftarrow(barx^rm pure+bary^rm pure barlambda+bartheta). \nupdate the right-hand side values of the master constraints: rm rhs_ileftarrow rm rhs_i - A^rm purecdotbarx^rm pure - A^rm colcdotbar lambda, where A^rm pure is the matrix of coefficients of pure master constraints and A^rm col is the matrix of coefficients of master columns.\nupdate subproblem multiplicities U_kleftarrow U_k - sum_qin Q_kbarlambda_q, and L_kleftarrow maxleft0 L_k - sum_qin Q_kbarlambda_qright, where Q_k is the set of indices of columns associated with solutions from subproblem k.\nupdate the bounds of pure master variables and representative master variables using the representative local partial solution: barx^rm repr = sum_qin Qs_qcdot barlambda_q, where Q is the total number of columns, and s_q is the subproblem solution associated with column lambda_q.","category":"page"},{"location":"api/presolve/#Updating-bounds-of-pure-and-representative-master-variables","page":"Presolve","title":"Updating bounds of pure & representative master variables","text":"","category":"section"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"Consider a pure master variable x^rm pure_j with barx^rm pure_jneq 0 and bounds lb_jub_j before augmenting the partial solution. ","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"If barx^rm pure_j  0, then we have lb_jleftarrow 0, ub_jleftarrow ub_j - barx^rm pure_j.","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"If barx^rm pure_j  0, then we have lb_jleftarrow lb_j - barx^rm pure_j, ub_jleftarrow 0.","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"Consider a representative master variable x^rm repr_j with bounds lb^g_j ub^g_j before augmenting the partial solution. Assume that x^rm repr_j represents exactly one variable x^k_j in subproblem k with bounds lb^l_j ub^l_j before augmenting the partial solution. This assumption should be verified before augmenting the partial solution!  For the clarity of presentation, we omit index j for the remainder of this  section.","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"After augmenting the partial solution, the following inequalities should be satisfied: $ lb^g - \\bar{x}^{\\rm repr}\\leq x^{\\rm repr} \\leq ub^g - \\bar{x}^{\\rm repr}.$","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"At the same time, we should have  minlb^lcdot L_k lb^lcdot U_kleq x^rm reprleq maxub^lcdot U_k ub^lcdot L_k","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"Thus, the following update should be done  $ lb^g\\leftarrow \\max\\left{lb^g - \\bar{x}^{\\rm repr},\\; \\min{lb^l\\cdot Lk,\\; lb^l\\cdot Uk}\\right}$ $ ub^g\\leftarrow  \\min\\left{ub^g - \\bar{x}^{\\rm repr},\\; \\max{ub^l\\cdot Uk,\\; ub^l\\cdot Lk}\\right}$","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"Example 1: 0leq x^kleq 3, 0leq x^rm reprleq 6, L_k=0, U_k=2. Let barx^rm repr=2. Then after augmenting the partial solution, we have  $ \\max\\left{-2,\\; 0\\right}\\leq x^{\\rm repr} \\leq \\min\\left{4,\\; 3\\right} \\Rightarrow 0 \\leq x^{\\rm repr} \\leq 3$","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"Example 2: 0leq x^kleq 5, 3leq x^rm reprleq 6, L_k=0, U_k=2. Let barx^rm repr=2. Then after augmenting the partial solution, we have  $ \\max\\left{1,\\; 0\\right}\\leq x'{\\rm repr} \\leq \\min\\left{4,\\; 5\\right} \\Rightarrow 1 \\leq x'{\\rm repr} \\leq 4$","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"Example 3: -1leq x^kleq 4, -2leq x^rm reprleq 2, L_k=0, U_k=2. Let barx^rm repr=-1. Then after augmenting the partial solution, we have  $ \\max\\left{-1,\\; -1\\right}\\leq x^{\\rm repr} \\leq \\min\\left{3,\\; 4\\right} \\Rightarrow -1 \\leq x^{\\rm repr} \\leq 3$","category":"page"},{"location":"api/presolve/","page":"Presolve","title":"Presolve","text":"","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nWe assume that readers are familiar with integer programming and exact optimization methods.Coluna is under active development. Some features are undocumented because they are very experimental. Current users are expected to read the source code.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a framework written in Julia to implement a decomposition approach to optimize  block-structured mixed-integer programs (MIP). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna relies on the tools of the JuMP-dev community at both ends of the problem treatment. It uses the JuMP modeling language upfront and MathOptInterface (MOI) to delegate master  and subproblems to MIP solvers. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The user introduces an original MIP that models his problem using the JuMP along our specific  extension BlockDecomposition that offers a syntax to specify the problem decomposition.  Coluna reformulates the original MIP using Dantzig-Wolfe and Benders decomposition  techniques.  Then, Coluna optimizes the reformulation using the algorithm chosen by the user.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna offers a \"black-box\" implementation of the branch-and-cut-and-price algorithm:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI). \nBlockDecomposition allows the user to provide Coluna with his decomposition of the model.   The BlockDecomposition syntax allows the user to implicitly define subsystems in the MIP on which the decomposition is based.   These subsystems are described by rows and/or columns indices.\nThe reformulation associated with the decomposition defined by the user is automatically generated by Coluna,  without requiring any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound.\nA default column (and cut) generation procedure is implemented.  It relies on underlying MOI optimizers to handle master and subproblems.   However, the user can use pricing callbacks to solve the subproblems.\nA branching scheme that preserves the pricing problem structure is offered by default;   it runs based on priorities and directives specified by the user on the original variables.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Coluna is a package for Julia 1.6+.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It requires JuMP to model the problem, BlockDecomposition to define the decomposition, and a MIP solver supported by MathOptInterface to optimize the master and the subproblems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can install Coluna and its dependencies through the package manager of Julia by entering :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add Coluna","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Atoptima, Mathematical Optimization Society (MOS), Région Nouvelle-Aquitaine, University of Bordeaux, and Inria","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
